@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f opt_selcrack

@c
/*
 * @a S.Idreos
 * This cracker optimizer changes a query plan in order to use the selection cracking operators
 */
@mal
pattern optimizer.selcrack():str
address OPTselcrack;
pattern optimizer.selcrack(mod:str, fcn:str):str
address OPTselcrack
comment "Selection cracking";

module crackers;
pattern crackers.selcrackprelude():void
address SCprelude;
crackers.selcrackprelude();
@h
#ifndef _OPT_SELCRACK_
#define _OPT_SELCRACK_
#include "opt_support.h"

#define maxTables 10

#define OPTDEBUGselcrack  if ( optDebug & ((lng)1 <<DEBUG_OPT_SELCRACK) )
opt_export str SCprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str OPTselcrack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "monetdb_config.h"
#include "opt_selcrack.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "opt_prelude.h"
#include "opt_pipes.h"
#include "opt_statistics.h"
#include "mtime.h"

#define match2(X,M,F) ( (X) && getFunctionId(X) && getFunctionId(X)==F && \
	getModuleId(X) && getModuleId(X)==M)

str
SCprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;

	addPipeDefinition(cntxt, "cracker_pipe",
			"optimizer.inline();"
			"optimizer.remap();"
			"optimizer.evaluate();"
			"optimizer.costModel();"
			"optimizer.coercions();"
			"optimizer.emptySet();"
			"optimizer.aliases();"
			"optimizer.selcrack();"
			"optimizer.deadcode();"
			"optimizer.commonTerms();"
			"optimizer.groups();"
			"optimizer.joinPath();"
			"optimizer.reorder();"
			"optimizer.deadcode();"
			"optimizer.reduce();"
			"optimizer.dataflow();"
			"optimizer.history();"
			"optimizer.multiplex();"
			"optimizer.garbageCollector();");

	return MAL_SUCCEED;
}

/* find all algebra select structions in a mal block mb and change them to the corresponding crackers command
    */
static int
OPTselcrackImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, *old;
	int update= 0, i, limit, actions=0, j;
	int no_of_leftjoins=0;	
	
	str tables[maxTables];
	int crackedTables=0;

	for(j=0;j<maxTables;j++)
		 tables[j] = NULL;	
	OPTDEBUGselcrack
		printf("Crack optimizer started\n");

	(void) cntxt;/* Tell compilers that we know that we do not */
        (void) stk; /* use these function parameters, here.       */ 
	(void) pci;
	
 	 /* In general, a MAL optimizer transforms a given MAL program into a
         * modified one by sequentially walking through the given program
         * and concurrently creating a new one from scratch by
         * (1) copying statements as is, modified, or in a different order,
         * or (2) omitting statements or (3) introducing new statements.
         */

        /* check for logical error: mb must never be NULL */
        assert (mb != NULL);

        /* safe the old stage of the MAL block */
	limit = mb->stop;
	old = mb->stmt;
	
	for (i = 0; i < limit; i++) {
		p = old[i];
		if( getModuleId(p)== sqlRef )
            update |= getFunctionId(p)== appendRef || 
					  getFunctionId(p)== replaceRef ||
					  getFunctionId(p)== deleteRef;
	}
	if (update)
		return 0;
	/*If there are more than one leftjoins in the plan, we do not want to replace or delete none of them*/
	for (i = 0; i < limit; i++) {
		p = old[i];
		if (match2(old[j], algebraRef, leftjoinRef))
			no_of_leftjoins++;
	}


	/* iterate over the instructions of the input MAL program */
	for (i = 0; i < limit; i++) {
		p = old[i];

		/* add a property "can be cracked" to every base relation that is a candidate for selection cracking */
		/* also, for every candidate bat, maintain the table name */
		if ( match2(p, sqlRef, bindRef) ){  
			ValRecord v, *vp;

		  	/* crack only supported data types */
			switch( update = getTailType(mb->var[getArg(p,0)]->type) ){
			case TYPE_int: case TYPE_lng: case TYPE_sht:
			case TYPE_flt: case TYPE_dbl: case TYPE_oid:
				break;
			case TYPE_wrd: /* to be moved up */
			default:
					if ( update == TYPE_date)
						break;
					continue;
			}

			/* avoid cracking delta bats used for updates */
			if (mb->var[getArg(p,5)]->value.val.ival != 0 ) 
				continue;		
				
			varSetProp(mb, getArg(p, 0), canBeCrackedProp, 0, NULL); /* add a property "can be cracked" to every base relation that is a candidate for selection cracking */


			vp = VALset(&v, TYPE_str, GDKstrdup(getVar(mb,getArg(p,2))->value.val.sval));  /* also, for every candidate bat, maintain the table name */
			varSetProp(mb, getArg(p,0), tableProp, op_eq, vp);

			continue;
		}

		/* propagate the canBeCracked property */
		if ( match2(p, batRef, setWriteModeRef) || 
			  match2(p, batcalcRef, dblRef) || 
			  match2(p, batcalcRef, intRef) ){ 

			if (varGetProp(mb, getArg(p, 1), canBeCrackedProp) != NULL){
				varSetProp(mb, getArg(p, 0), canBeCrackedProp, 0, NULL);
				if (varGetProp(mb, getArg(p, 1), tableProp) != NULL){
					ValRecord v, *vp;
					vp = VALset(&v, TYPE_str, GDKstrdup(varGetProp(mb, getArg(p,1), tableProp)->value.val.sval));
					varSetProp(mb, getArg(p, 0), tableProp, op_eq, vp);
				}
			}
		
			continue;
		}

		if (match2(p, algebraRef, semijoinRef)){
			if (varGetProp(mb, getArg(p, 1), canBeCrackedProp) != NULL){
				ValRecord v, *vp;
				vp = VALset(&v, TYPE_int,&i);
				varSetProp(mb, getArg(p, 0), canBeJoinselectProp, op_eq, vp);
			}
			continue;
		}

		/* make the actual command changes */
		if (match2(p, algebraRef, selectRef) ||
		    match2(p, algebraRef, uselectRef) || 
		    match2(p, algebraRef, thetauselectRef)){ 
				
			
			int j=0,k=0,m=0;
			bit found = FALSE;
			bit found2 = FALSE;

			if (varGetProp(mb, getArg(p,1), canBeCrackedProp) != NULL){
				bit alreadyCracked = FALSE;

				/* see if we have already used a crackers select for this table */
				for(j=0;j<crackedTables;j++)
					if (strcmp(tables[j],varGetProp(mb, getArg(p,1), tableProp)->value.val.sval) == 0)
						alreadyCracked = TRUE;
	
				/* if not then go ahead and use one*/
				if (!alreadyCracked){
					tables[crackedTables]=GDKstrdup(varGetProp(mb, getArg(p,1), tableProp)->value.val.sval);
					crackedTables++;
					if (match2(p, algebraRef, uselectRef))
					{
						setFunctionId(p, putName("select", 6));
	
					}
					else if (match2(p, algebraRef, thetauselectRef))
					{
						setFunctionId(p, putName("thetaselect", 11));
	
					}
					
					setModuleId(p, putName("crackers", 8));
					
					setVarType(mb, getArg(p,0), getArgType(mb,p,1)); /*We force the return type to be equal to the type of the first argument*/
					setVarUDFtype(mb, getArg(p,0));

                       			for (j = i+1; !found  && j < limit; j++){
						if(match2(old[j], algebraRef, semijoinRef) || no_of_leftjoins>1)
						{ break; }
						if (match2(old[j], algebraRef, leftjoinRef)){
							for (k = old[j]->retc; !found && k < old[j]->argc; k++)
								found = (getArg(old[j], k) == getArg(p, 1));
							if(found)
							{
								for (m = j+1; m < limit; m++)
								{
									for (k = old[m]->retc; k < old[m]->argc; k++){
										found2 = (getArg(old[m], k) == getArg(old[j], 0));
										if (found2) 
											break;
									
									}
									getArg(old[m], k) = getArg(p, 0);
									
									
									continue;
									
								}
							
							}
						}
						
						continue;
					}
					
	
					actions++;
					continue;
				}
				
			}

		}
	}

	return actions;
}

str OPTselcrack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme;
	str fcnnme;
	str msg = MAL_SUCCEED;
	Symbol s = NULL;
	lng t, clk = GDKusec();
	int actions = 0;
	char optimizer[256];
	InstrPtr q = copyInstruction(p);

	optimizerInit();
	snprintf(optimizer, 256, "%s", getFunctionId(p));
	OPTDEBUGselcrack mnstr_printf(cntxt->fdout, "=APPLY OPTIMIZER %s\n", getModuleId(p));
	if (p && p->argc > 1) {
		if (getArgType(mb, p, 1) != TYPE_str ||
			getArgType(mb, p, 2) != TYPE_str ||
			!isVarConstant(mb, getArg(p, 1)) ||
			!isVarConstant(mb, getArg(p, 2))
			)
			throw(MAL, optimizer, ILLARG_CONSTANTS);

		if (stk != 0) {
			modnme = *(str *) getArgReference(stk, p, 1);
			fcnnme = *(str *) getArgReference(stk, p, 2);
		} else {
			modnme = getArgDefault(mb, p, 1);
			fcnnme = getArgDefault(mb, p, 2);
		}
		removeInstruction(mb, p);
		s = findSymbol(cntxt->nspace, putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

		if (s == NULL) {
			char buf[1024];
			snprintf(buf, 1024, "%s.%s", modnme, fcnnme);
			throw(MAL, optimizer, RUNTIME_OBJECT_UNDEFINED ":%s", buf);
		}
		mb = s->def;
		stk = 0;
	} else if (p)
		removeInstruction(mb, p);
	if (mb->errors) {
		/* when we have errors, we still want to see them */
		addtoMalBlkHistory(mb, getModuleId(q));
		freeInstruction(q);
		return MAL_SUCCEED;
	}

	actions = OPTselcrackImplementation(cntxt, mb, stk, p);

	msg = optimizerCheck(cntxt, mb, optimizer, actions, t = (GDKusec() - clk), OPT_CHECK_ALL);
	OPTDEBUGselcrack {
		mnstr_printf(cntxt->fdout, "=FINISHED %s  %d\n", optimizer, actions);
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT | LIST_MAPI);
	}
	DEBUGoptimizers
	mnstr_printf(cntxt->fdout, "#opt_reduce: " LLFMT " ms\n", t);
	QOTupdateStatistics(getModuleId(q), actions, t);
	addtoMalBlkHistory(mb, getModuleId(q));
	freeInstruction(q);
	return msg;
}

