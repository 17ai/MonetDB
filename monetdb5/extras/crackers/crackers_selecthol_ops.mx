@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f crackers_selecthol_ops

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold, Eleni Petraki
 * @d March 2006 - July 2007
 * @* Select Operators
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(bte,simple,,bte)@
@:@1(sht,simple,,sht)@
@:@1(int,simple,,int)@
@:@1(lng,simple,,lng)@
@:@1(flt,simple,,flt)@
@:@1(dbl,simple,,dbl)@
@:@1(date,atom,TYPE_,loc)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_SELECTHOL_H_
#define _CRACKERS_SELECTHOL_H_

/* Exported signatures */
@:TypeSwitch(SelectholFunctions_decl)@

#endif /* _CRACKERS_SELECTHOL_H */
/*
 * @- Exported signatures
 */
@= SelectholFunctions_decl
crackers_export str CRKselectholBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKuselectholBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKselectholValue_@1(int *vid, int *bid, @1 *value);
crackers_export str CRKuselectholValue_@1(int *vid, int *bid, @1 *value);
crackers_export str CRKselecthol_@1(int *vid, int *bid, @1 *low, @1 *hgh);
crackers_export str CRKuselecthol_@1(int *vid, int *bid, @1 *low, @1 *hgh);
crackers_export str CRKthetaselecthol_@1(int *vid, int *bid, @1 *val, str *op);
crackers_export str CRKthetauselecthol_@1(int *vid, int *bid, @1 *val, str *op);
@

@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/*This function picks randomly 5 oids and their respective values and then chooses the median*/
@= FndMedian
	static @1 FndMedian_@1(BAT *c,oid a,oid b)
	{
		@1 *t;
		@1 arr[5]={0,0,0,0,0};
		int i, j, k; 
		@1 temp;
		
		oid p;
		int cnt=0;
		t=(@1 *)Tloc(c,BUNfirst(c));
		for(cnt=0;cnt<5;cnt++)
		{
			p=(rand()%(b-a+1))+a;
			arr[cnt]=t[p];
		}
		for ( i = 1 ; i <= 4 ; i++ )
		{
			for ( j = 0 ; j < i ; j++ )
			{
				if ( arr[j] > arr[i] )
				{
					temp = arr[j] ;
					arr[j] = arr[i] ;

					for ( k = i ; k > j ; k-- )
						arr[k] = arr[k - 1] ;

					arr[k + 1] = temp ;
				}
			}
		}
		
		return arr[2];
	}
@c

@:TypeSwitch(FndMedian)@


/* Local support functions and macros */
@:TypeSwitch(crackOperations)@

/* Exported functions */
@:TypeSwitch(SelectholFunctions_impl)@
/*
 * @- Exported functions
 */
@= SelectholFunctions_impl

str
CRKselectholBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, TRUE);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, TRUE);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE);
}

str
CRKuselectholBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, FALSE);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, FALSE);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
}

str
CRKselectholValue_@1(int *vid, int *bid, @1 *value){
	bit inclusive = TRUE;
	return CRKuselectholBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

str
CRKuselectholValue_@1(int *vid, int *bid, @1 *value){
	bit inclusive = TRUE;
	return CRKuselectholBounds_@1(vid, bid, value, value, &inclusive, &inclusive);
}

str
CRKselecthol_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	bit inclusive = TRUE;
	return CRKselectholBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

str
CRKuselecthol_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	bit inclusive = TRUE;
	return CRKuselectholBounds_@1(vid, bid, low, hgh, &inclusive, &inclusive);
}

str
CRKthetaselecthol_@1(int *vid, int *bid, @1 *val, str *OP){
	ptr nilptr = ATOMnilptr(TYPE_@1); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@1 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
		high = NULL;
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetaselecthol", "unknown operator");
	}

	return CRKselectholBounds_@1(vid, bid, low, high, &lin, &rin);
}

str
CRKthetauselecthol_@1(int *vid, int *bid, @1 *val, str *OP){
	ptr nilptr = ATOMnilptr(TYPE_@1); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@1 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetauselecthol", "unknown operator");
	}

	return CRKuselectholBounds_@1(vid, bid, low, high, &lin, &rin);
}


@

 * @- Local support functions and macros

@= crkThreeTree
        /*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree@4_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree@4_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree@4_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree@4_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
				
	/*if (vl != -1 && vh != -1){*/
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,hgh,HBound,vh,c);
	
@
@= crkThreeTreeCopy
        /*printf("crack in three pieces\n");*/
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeCopy_LE_RE_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeCopy_LE_RO_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeCopy_LO_RE_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeCopy_LO_RO_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);

        /*if (vl != -1 && vh != -1){*/
                if (vl>0) _vl=vl-1; else _vl=vl;
                addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                addCrackerIndex_@1(m,hgh,HBound,vh,c);

@

@= crkTwoLTree
	/*CRACK in two pieces cl1-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero@2_RE_@1(b,*low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero@2_LE_@1(b,*low, cl1, ch1,&vl);

	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/
@
@= crkTwoRTree
	/*CRACK in two pieces cl2-ch2 using <incHgh bound*/
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero@2_LE_@1(b,*hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero@2_RE_@1(b,*hgh, cl2, ch2,&vh);

@
@= CreateResult
createView:

	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	else
		view = BATslice(b, vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);

	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
@
@= RangeSelectBody
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	oid vl=0, vh=0, posl, posh;
	/* vl and vh are the low and high index values to create the view with the result */
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	/* index values in the case we have to crack
		|cl1...........ch1|.....................|cl2.........ch2|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	oid _vl=0,temp_vl=0,temp_vh=0;
	bit HBound, foundLow=0, foundHgh=0;
	bit LBound=FALSE;

	bit copy=TRUE;
	
	int countBatElements;
	int L1=2048000; /*Number of integers that can fit into L1 cache (size: 8192KB)*/

	/*k and randomoid are used for DD1R*/
	@1 k,temp_h;

	FrequencyNode* FN;
	FrequencyNode *FrequencyStructA = getFrequencyStruct('A');
	FN=searchBAT(FrequencyStructA,*bid);
	
	fprintf(stderr,"This is from selcrack_HOL operators\n");	
	fprintf(stderr,"FN->bid=%d\n",FN->bid);

	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.crack", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);
	/*fprintf(stderr,"*BID=%d\n",*bid);*/
	/* if this is the first time we selecthol something from this bat,
		we have to create the crack index for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if (copy){
			if ((bo = BATdescriptor(*bid)) == NULL)
				throw(MAL, "crackers.crackRange", "Cannot access descriptor");
			b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
			if ( bo->htype == TYPE_void)
				b = BATmaterializeh(b);
			b->hsorted = FALSE;
			b->tsorted = FALSE;
			b->hdense = FALSE;
			b->tdense = FALSE;
			/*BATkey(b,TRUE);*/
			BATkey(BATmirror(b),FALSE);
			b->batRestricted= BAT_READ;
			BATmode(b,PERSISTENT);
			bo->batRestricted= BAT_READ;

			m = newCrackerIndex_@1(*bid,b->batCacheid);
		
			countBatElements=BATcount(b);
			/*fprintf(stderr,"BATcount(b)=%d",countBatElements);*/
			FN->f1 = FN->f1 + 1;
			FN->weight = changeWeight_1(FN,countBatElements,L1);	

			if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
				throw(MAL, "crackers.crackRange", "Cannot access crack index");

			/* Since the index is empty we know we have to crack
			   anyway so crack in three pieces cl-ch */
			posl = BUNfirst(b);
			posh = BUNlast(b)-1;

			/*printf(" "LLFMT" \n ",posh-posl);*/
			@:crkThreeTree@5(@1,posl,posh,@5)@

			FN->c = FN->c + 3;
			
			BBPincref(b->batCacheid,TRUE);
			BBPunfix(bo->batCacheid);
			goto createView;
		}
		else{
                        if ((bo = BATdescriptor(*bid)) == NULL)
                                throw(MAL, "crackers.crackRange", "Cannot access descriptor");

                        b=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
                        b->hsorted = FALSE;
                        b->tsorted = FALSE;
                        b->hdense = FALSE;
                        b->tdense = FALSE;
                        BATkey(BATmirror(b),FALSE);
                        b->batRestricted= BAT_READ;
                        BATmode(b,PERSISTENT);
                        BATsetcount(b,BATcount(bo));
                        bo->batRestricted= BAT_READ;

                        m = newCrackerIndex_@1(*bid,b->batCacheid);

                        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                                throw(MAL, "crackers.crackRange", "Cannot access crack index");

                        /* Since the index is empty we know we have to crack
                           anyway so crack in three pieces cl-ch */
                        posl = BUNfirst(b);
                        posh = BUNlast(b)-1;

                        /*printf(" "LLFMT" \n ",posh-posl);*/
                        @:crkThreeTreeCopy(@1,posl,posh,@5)@

                        BBPincref(b->batCacheid,TRUE);
                        BBPunfix(bo->batCacheid);
                        goto createView;
                }
		
	}
	
	/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where our range falls after this
		search if we have a match on the low range vl will hold the
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment
		by one since we want the values that are after this index
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices
		(in the crack index) found either as a match or to crack.
		This is used later on to determine which pieces we have to crack */

	/* Check if this bat was previously cracked but the map is not there anymore
		this may happen if we chose to forget the index because of updates, so now we
		have to create a new one and crack in three pieces anyway */
	if (CrackerIndex[m].reCreate == 1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
	
		posl = BUNfirst(b);
		posh = BUNlast(b)-1;

		@:crkThreeTree@5(@1,posl,posh,@5)@
		goto createView;
	}
	
	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

		
	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);


	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0 && LBound==FALSE) cl1++;
	if (cl2 != 0) cl2++;

	/*printf("cl1 "OIDFMT" cl2 "OIDFMT" ", cl1,cl2  );*/
	
	
       
	if(foundLow==0 || foundHgh==0) FN->f1 = FN->f1 + 1;
	else	FN->f2 = FN->f2 +1; 
	/* If one or both of the result view bounds were not found using the
	index then we have to crack */

	temp_h=*hgh;

	if (foundLow == 0){
			k=FndMedian_@1(b,cl1,ch1);
			*hgh=k;
			/*fprintf(stderr,"Random=%d Low=%d \n",k,(int)*low);*/

			

			foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
			if (cl2 != 0) cl2++;
			@:crkTwoRTree@5(@1,@5)@
			if (IndexSize <IndexStop)
			{
					
				addCrackerIndex_@1(m,hgh,HBound,vh,c);
				FN->c = FN->c + 1;
				
			}
			
		        foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);
			if(foundLow==0)
			{

				if (cl1 != 0 && LBound==FALSE) cl1++;
				 @:crkTwoLTree@5(@1,@5)@

                        	if (IndexSize <IndexStop){
                                        if (vl>0) _vl=vl-1; else _vl=vl;
                                        addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
					FN->c = FN->c + 1;
                                        temp_vl=vl;
                        	}
				
			}else temp_vl=cl1;
			

		} else{ 
			temp_vl = cl1;
			
		} 
	
	
	*hgh=temp_h;
	/* find out where in the index the high falls */
        foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
	if (cl2 != 0)   cl2++;
	
	
	if (foundHgh == 0){
			k=FndMedian_@1(b,cl2,ch2);
			*low=k;
			/*fprintf(stderr,"Random=%d High=%d\n",k,(int)*hgh);*/
			


			foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);
			if (cl1 != 0 && LBound==FALSE) cl1++;
			@:crkTwoLTree@5(@1,@5)@

                       	if (IndexSize <IndexStop){
                                 if (vl>0) _vl=vl-1; else _vl=vl;
                                 addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
				FN->c = FN->c + 1;
			}
			foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);
			if(foundHgh==0)
			{
				if (cl2 != 0)   cl2++;

				@:crkTwoRTree@5(@1,@5)@

                        	if (IndexSize <IndexStop)
                        	{

                                	addCrackerIndex_@1(m,hgh,HBound,vh,c);
					FN->c = FN->c + 1;
                                
                        	}
                        	temp_vh=vh;
			}else temp_vh=ch2;
				
		} else{
			 temp_vh = ch2;
		}
	   	
	vl=temp_vl;
	vh=temp_vh;
	if(foundLow != 0 && foundHgh != 0)
	{
		vl = cl1;
		vh = ch2;
	}
	countBatElements=BATcount(b);
	/*fprintf(stderr,"BATcount(b)=%d\n",countBatElements);*/
	if(FN->weight >= 0)
		FN->weight = changeWeight_1(FN,countBatElements,L1);
	/*if(FN->weight <0)
		deleteNode(FrequencyStructA,FN->bid);
	*/
	printFrequencyStruct(FrequencyStructA);

	@:CreateResult()@
	return MAL_SUCCEED;
@
@= crackOperations


/* This function takes a range and returns a view with the result. 
To do that, we first search the index to determine which parts of the result we already
know and which parts we have to crack. Then we crack, if necessary,
the appropriate pieces, update the index and return the result */
static str
CRKRangeTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){	
	@:RangeSelectBody(@1,@2,@3,@4,)@
}

static str
CRKRangeLeftNilTree_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	oid vl=0, vh=0;
	oid cl2=0, ch2=0;
	bit HBound,foundHgh=0;
	/*int gapH = 1;*/
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we selecthol something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl2 = BUNfirst(b);
		ch2 = BUNlast(b)-(oid)1;
		@:crkTwoRTree(@1)@
		addCrackerIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNfirst(b);
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (CrackerIndex[m].cid == -1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl2 = BUNfirst(b);
		ch2 = BUNlast(b)-(oid)1;
		@:crkTwoRTree(@1)@
		addCrackerIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNfirst(b);

		goto createView;
	}

	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	vl = BUNfirst(b);

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;

	if (foundHgh == 0){
		@:crkTwoRTree(@1)@
		if (IndexSize <IndexStop)
			 addCrackerIndex_@1(m,hgh,HBound,vh,c);
	} 	
	else
		vh = ch2;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}

static str
CRKRangeRightNilTree_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	oid vl=0, vh=0;
	oid cl1=0, ch1=0;
	bit foundLow=0;
	/*int gapL = 1;*/
	bit LBound=FALSE;

	m = existsCrackerIndex(*bid);

	/* if this is the first time we selecthol something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl1 = BUNfirst(b);
		ch1 = BUNlast(b)-(oid)1;
		@:crkTwoLTree(@1)@
		 addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNlast(b)-(oid)1;
		
		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto createView;
	}
	
	if (CrackerIndex[m].cid == -1){
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl1 = BUNfirst(b);
		ch1 = BUNlast(b)-(oid)1;
		@:crkTwoLTree(@1)@
		addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNlast(b)-(oid)1;

		goto createView;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	vh = BUNlast(b)-(oid)1;


	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low,*inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;

	if (foundLow == 0){
		@:crkTwoLTree(@1)@
		if (IndexSize <IndexStop)
			addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
	} 	
	else
		vl = cl1;
		
	@:CreateResult()@
	return MAL_SUCCEED;
}
@
