@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f crackers

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Cracker index
 *
 * Database cracking aims at enhancing query processing by adapting the way
 * data is stored to the query workload. Adaptation happens through physical
 * reorganization of data. Each query reorganized the data in such a way that
 * future queries can be answered faster.
 *
 * For each BAT b, the system creates on demand a cracker column c, i.e.,
 * the first time a select operator is fired on b. From there on all queries that
 * perform a select operator on b will physically reorganize (i.e., crack) the cracker column c
 * such that the result set is in a consecutive area in c.
 * The result of the select operator is a non materialized view on c.
 *
 * For each cracker column c, there exists a cracker index, that maintains knowledge
 * on the various pieces created while cracking c. The cracker index is an AVLt-tree
 * data structure. Each select operator uses the appropriate cracker index to determine
 * which pieces it should crack, and updates the index afterwards.
 *
 * The more queries are fired on a bat b the more the cracker column c of b is cracked.
 * This way the cracker index on c, is continuously enriched with information that helps speed up
 * future queries. This way query processing improves as more queries are answered by adapting to
 * the query and data workload.
 *
 * Initial performance shows an exptected gain of at least on order of magnitude,
 * due to analysing less data during the select operator and also due to non materializing
 * the select operator result set.
 *
 * The cracker index can be created for the time being on
 * tail columns of type {int,lng,dbl,flt,time,date,sht}. The head
 * is always of type @sc{oid}.
 *
 * In addition, the cracker index can be used to feed a generator
 * for pieces satisfying a range constraint.
 * A cracker partition is indicated by the index in the cidx
 * table. It can be used to initialize a BATview to represent
 * the partition during processing.
 *
 * Updates support for cracker columns happens again in a self-organizing way.
 * Incoming updates (inserts,deletes or updates) are kept in separate columns for
 * each BAT as pending updates. While processing queries, if the crackers select
 * operator detects that some of the pending updates should be taken into account,
 * then updates are "merged" into the cracker column on the fly by also updating the
 * cracker index accordingly.
 *
 * Since the cracker columns are physically reorganized the result of a select operator is not
 * ordered in the same way as the rest of the bats of the same relation. This has side-effects
 * during projection operations. We cannot use ordered fetch joins anymore.
 * This decrades performance significantly
 * when multiple projections exist in a query plan.
 *
 * This problem is solved by the second generation cracing, i.e.,
 * sideways cracking that uses cracker maps instead of cracker columns.
 * A cracker map contains the values of two attributes of the same relation.
 * These are attributes used together in query plans. The main idea is that
 * cracking based on one of these attributes (the head of the map) is forwarded on the tail.
 * This way projections can be performed by performing simple cracking operations on maps.
 * Multiple maps can exist for each attribute A as head consisting the map set of A. All maps in the same
 * map set S are aligned before used in a query plan. Aligment happens by keeping a history of all cracking
 * operations in maps of S and ensuring that the same cracks have been applied to all necessary maps
 * and in the same order. Sideways cracking maintains the advantage of cracking even
 * in the presence of multiple projection operations.
 *
 * Ongoing work.
 * Multitable cracking.
 *
 * The cracker module should be prepared to deal with any of the base types.
 * For strings this becomes an issue.
 *
 * The current implementation uses an unprotected cracker
 * index. This limits the interface at slightly more overhead
 * of searching the cracker index upon each call.
 *
 * Currently crakcer structures are in memory. They need to be stored in disk and become persistent.
 *
 * Repeated cracking leads to an ever growing index. This process
 * can be stopped by setting the granule size,
 * i.e.  the minimum number of tuples in each piece,
 * or the maximum number of pieces.
 *
 * The implementation is geared at early experimentation
 * without all the details to make the code robust and
 * ultra fast.
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch_temp2
@:@1(@2,int)@
@:@1(@2,date)@
@
@= TypeSwitch_1
@:@1(@2,bte)@
@:@1(@2,sht)@
@:@1(@2,int)@
@:@1(@2,lng)@
@:@1(@2,flt)@
@:@1(@2,dbl)@
@:@1(@2,date)@
@
@= TypeSwitch_2
@:TypeSwitch_temp2(@1,int)@
@:TypeSwitch_temp2(@1,date)@
@:TypeSwitch_temp2(@1,dbl)@
@:@1(date,lng)@
@:@1(date,dbl)@
@:@1(date,str)@
@:@1(int,str)@
@:@1(dbl,str)@
@:@1(dbl,int)@
@:@1(dbl,dbl)@
@:@1(int,lng)@
@
@= TypeSwitch_joins1
@:@1(int,int)@
@:@1(int,oid)@
@
@= TypeSwitch_joins2
@:@1(int)@
@
@mal
# @- MAL file
module crackers;

@:TypeSwitch_1(Select)@
@:TypeSwitch_1(Index)@
@:TypeSwitch_1(CoreUnordered)@




#
@= Select
command select(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";


command selectst(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectst(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectst(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

@
@= Index
command printCrackerIndexBATpart(b:bat[:any_1,:@2]):void
address CRKprintCrackerIndexBATpart
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@2]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:oid,:@2]):bat[:oid,:@2]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printAVLTree_int(b:bat[:any_1,:@2]):void
address CRKprintAVLTree_int
comment "Print the AVL Tree of the cracker index (for debugging purposes)";
@
@= CoreUnordered
command zcrackUnordered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackUnorderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackUnorderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@

 
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

#include "mtime.h"
#include "crackers_index.h"
#include "crackers_select_ops.h"
#include "crackers_selectst_ops.h"
#include "crackers_core_unordered.h"
#include "crackers_AVL_tree.h"

#ifdef LIBCRACKERS 
extern int maxCrackMap;
extern CrackerIndexNode *CrackerIndex;
extern int IndexEntries;
extern int IndexSize;
extern int IndexStop;
extern struct storageManagement *StorageInfo;
#endif

#endif /* _CRACKERS_H */


@c
/*
 * @+ Implementation
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

int maxCrackMap = 0;

CrackerIndexNode *CrackerIndex;

struct storageManagement *StorageInfo = NULL;

int IndexEntries = 20000000; /* Initial size used for the bat that stores index values */

/* Temp variables used to test the effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 10000000;
