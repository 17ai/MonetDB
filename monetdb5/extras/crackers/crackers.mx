@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f crackers

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Cracker index
 *
 * Database cracking aims at enhancing query processing by adapting the way
 * data is stored to the query workload. Adaptation happens through physical
 * reorganization of data. Each query reorganized the data in such a way that
 * future queries can be answered faster.
 *
 * For each BAT b, the system creates on demand a cracker column c, i.e.,
 * the first time a select operator is fired on b. From there on all queries that
 * perform a select operator on b will physically reorganize (i.e., crack) the cracker column c
 * such that the result set is in a consecutive area in c.
 * The result of the select operator is a non materialized view on c.
 *
 * For each cracker column c, there exists a cracker index, that maintains knowledge
 * on the various pieces created while cracking c. The cracker index is an AVLt-tree
 * data structure. Each select operator uses the appropriate cracker index to determine
 * which pieces it should crack, and updates the index afterwards.
 *
 * The more queries are fired on a bat b the more the cracker column c of b is cracked.
 * This way the cracker index on c, is continuously enriched with information that helps speed up
 * future queries. This way query processing improves as more queries are answered by adapting to
 * the query and data workload.
 *
 * Initial performance shows an exptected gain of at least on order of magnitude,
 * due to analysing less data during the select operator and also due to non materializing
 * the select operator result set.
 *
 * The cracker index can be created for the time being on
 * tail columns of type {int,lng,dbl,flt,time,date,sht}. The head
 * is always of type @sc{oid}.
 *
 * In addition, the cracker index can be used to feed a generator
 * for pieces satisfying a range constraint.
 * A cracker partition is indicated by the index in the cidx
 * table. It can be used to initialize a BATview to represent
 * the partition during processing.
 *
 * Updates support for cracker columns happens again in a self-organizing way.
 * Incoming updates (inserts,deletes or updates) are kept in separate columns for
 * each BAT as pending updates. While processing queries, if the crackers select
 * operator detects that some of the pending updates should be taken into account,
 * then updates are "merged" into the cracker column on the fly by also updating the
 * cracker index accordingly.
 *
 * Since the cracker columns are physically reorganized the result of a select operator is not
 * ordered in the same way as the rest of the bats of the same relation. This has side-effects
 * during projection operations. We cannot use ordered fetch joins anymore.
 * This decrades performance significantly
 * when multiple projections exist in a query plan.
 *
 * This problem is solved by the second generation cracing, i.e.,
 * sideways cracking that uses cracker maps instead of cracker columns.
 * A cracker map contains the values of two attributes of the same relation.
 * These are attributes used together in query plans. The main idea is that
 * cracking based on one of these attributes (the head of the map) is forwarded on the tail.
 * This way projections can be performed by performing simple cracking operations on maps.
 * Multiple maps can exist for each attribute A as head consisting the map set of A. All maps in the same
 * map set S are aligned before used in a query plan. Aligment happens by keeping a history of all cracking
 * operations in maps of S and ensuring that the same cracks have been applied to all necessary maps
 * and in the same order. Sideways cracking maintains the advantage of cracking even
 * in the presence of multiple projection operations.
 *
 * Ongoing work.
 * Multitable cracking.
 *
 * The cracker module should be prepared to deal with any of the base types.
 * For strings this becomes an issue.
 *
 * The current implementation uses an unprotected cracker
 * index. This limits the interface at slightly more overhead
 * of searching the cracker index upon each call.
 *
 * Currently crakcer structures are in memory. They need to be stored in disk and become persistent.
 *
 * Repeated cracking leads to an ever growing index. This process
 * can be stopped by setting the granule size,
 * i.e.  the minimum number of tuples in each piece,
 * or the maximum number of pieces.
 *
 * The implementation is geared at early experimentation
 * without all the details to make the code robust and
 * ultra fast.
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch_temp2
@:@1(@2,int)@
@:@1(@2,date)@
@
@= TypeSwitch_1
@:@1(@2,bte)@
@:@1(@2,sht)@
@:@1(@2,int)@
@:@1(@2,lng)@
@:@1(@2,flt)@
@:@1(@2,dbl)@
@:@1(@2,date)@
@:@1(@2,lng)@
@
@= TypeSwitch_2
@:TypeSwitch_temp2(@1,int)@
@:TypeSwitch_temp2(@1,date)@
@:TypeSwitch_temp2(@1,dbl)@
@:@1(date,lng)@
@:@1(date,dbl)@
@:@1(date,str)@
@:@1(int,str)@
@:@1(dbl,str)@
@:@1(dbl,int)@
@:@1(dbl,dbl)@
@:@1(int,lng)@
@:@1(lng,date)@
@:@1(lng,lng)@
@
@= TypeSwitch_joins1
@:@1(int,int)@
@:@1(int,oid)@
@
@= TypeSwitch_joins2
@:@1(int)@
@
@mal
# @- MAL file
module crackers;

@:TypeSwitch_1(Select)@
@:TypeSwitch_1(Index)@
@:TypeSwitch_1(CoreUnordered)@
@:TypeSwitch_1(Validate)@
@:TypeSwitch_1(Updates)@
@:TypeSwitch_2(Sideways)@
@:TypeSwitch_1(JoinSelect)@
@:TypeSwitch_1(Aggregation)@


command getTotalStorage( ):void
address CRKgetTotalStorage
comment "Get the number of total tuples stored in sideways maps";

command setStorageThreshold(threshold:lng):void
address CRKsetStorageThreshold
comment "set the maximum number of total tuples that can be stored in sideways maps";

command fmclearReferences():void
address CRKclearReferencesFullMaps
comment "clear all references ";

command fmremoveMap():void
address CRKremoveFullMap
comment "clear all debugging map ";

#

@= Select

# original single-threaded versions

command select(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command select(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselect(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselect_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

# new multi-threaded versions

command select(b:bat[:oid,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselect_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command select(b:bat[:oid,:@2],l:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command select(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselect_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselect(b:bat[:any_1,:@2],l:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselect(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetauselect(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKthetauselect_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetaselect(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:@2]
address CRKthetaselect_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command parallelselect(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKparallelselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command paralleluselect(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKparalleluselectBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";


command selectst(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectst(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectst(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";


# new multi-threaded stochastic versions

command selectst(b:bat[:oid,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectst_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command selectst(b:bat[:oid,:@2],l:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectstValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command selectst(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectstBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectst_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectst(b:bat[:any_1,:@2],l:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectstValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectst(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectstBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetauselectst(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKthetauselectst_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetaselectst(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:@2]
address CRKthetaselectst_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";



command selectstpl(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectstpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectstpl(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectstplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectstpl(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectstplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectstpl(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectstpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectstpl(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectstplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectstpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectstplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectstpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectstpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectstpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectstpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selecthol(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselecthol_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selecthol(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectholValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selecthol(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectholBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselecthol(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselecthol_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselecthol(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectholValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselecthol(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectholBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselecthol(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselecthol_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselecthol(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselecthol_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholst(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectholst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholst(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectholstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholst(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectholstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholst(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectholst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholst(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectholstValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholst(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectholstBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectholst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectholst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectholst(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectholst_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholpl(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectholpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholpl(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectholplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectholpl(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectholplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholpl(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectholpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholpl(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectholplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectholpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectholplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectholpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectholpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectholpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectholpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";


# new multi-threaded versions for holistic indexing

command selectholpl(b:bat[:oid,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectholpl_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command selectholpl(b:bat[:oid,:@2],l:@2, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectholplValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command selectholpl(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:oid,:@2]
address CRKselectholplBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectholpl(b:bat[:any_1,:@2],l:@2,h:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectholpl_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectholpl(b:bat[:any_1,:@2],l:@2, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectholplValue_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command uselectholpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKuselectholplBounds_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetauselectholpl(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:void]
address CRKthetauselectholpl_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";

command thetaselectholpl(b:bat[:any_1,:@2],v:@2,op:str, nthreads:int, vector_elements:int):bat[:any_1,:@2]
address CRKthetaselectholpl_@2_MT
comment "Retrieve the subset using a cracker
        index producing preferably a BATview;
        nthreads == nil  ->  original single-threaded implementation,
        nthreads == 0    ->  revised single-threaded implementation,
        nthreads <  0    ->  1st (inferior) version of new multi-threaded implementation,
        nthreads >  0    ->  2nd (superior) version of new multi-threaded implementation.";


/*concurrent cracking*/

command selectpl(b:bat[:oid,:@2],l:@2,h:@2):bat[:oid,:@2]
address CRKselectpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectpl(b:bat[:oid,:@2],l:@2):bat[:oid,:@2]
address CRKselectplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command selectpl(b:bat[:oid,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectpl(b:bat[:any_1,:@2],l:@2,h:@2):bat[:any_1,:void]
address CRKuselectpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectpl(b:bat[:any_1,:@2],l:@2):bat[:any_1,:void]
address CRKuselectplValue_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command uselectpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):bat[:any_1,:void]
address CRKuselectplBounds_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetauselectpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:void]
address CRKthetauselectpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";

command thetaselectpl(b:bat[:any_1,:@2],v:@2,op:str):bat[:any_1,:@2]
address CRKthetaselectpl_@2
comment "Retrieve the subset using a cracker
        index producing preferably a BATview.";
@
@= JoinSelect
command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:void] ):bat[:oid,:void]
address CRKjoinSelectDefault_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	The result is a new [:oid,:void] BAT.";

command joinuselect( right:bat[:oid,:@2], l:@2, h:@2, li:bit, hi:bit, left:bat[:oid,:void], inPlace:bit , isForeignKey:bit):bat[:oid,:void]
address CRKjoinSelectBounds_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";

command jointhetauselect( right:bat[:oid,:@2],v:@2,op:str, left:bat[:oid,:void], inPlace:bit , isForeignKey:bit):bat[:oid,:void]
address CRKjointhetauselect_@2
comment "Join left and right on head-OIDs.
	From right, only those BUNs qualify that satisfy the range-restriction on the tail.
	If inPlace is TRUE (and left has an OID head and is not a BAT-view), we operate in-place,
	overwriting left and returning it as result. Otherwise, the result is a new [:oid,:void] BAT.
	If isForeignKey is TRUE, we assume that each tuple from left finds a match in right,
	and hence skip the respective check.
	(NOTE: This may lead to CRASHES, if isForeignKey is incorrectly passed as TRUE!)";

command joinselect( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command jointhetaselect( b:bat[:oid,:@2],v:@2,op:str):bat[:oid,:bit]
address CRKjointhetaSelectSideways_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command joinselecthol( b:bat[:oid,:@2],l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSidewayshol_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";

command jointhetaselecthol( b:bat[:oid,:@2],v:@2,op:str):bat[:oid,:bit]
address CRKjointhetaSelectSidewayshol_@2
comment "From cpair, only those BUNs qualify that satisfy the range-restriction on the tail.
        The result is a new [:oid,:bit] BAT that reflects the positions of buns in cpair. 
	For each tuple that qualifies in cpair, the respective position in the pivot is marked with a 1";
@
@= Updates
command insertionsPartiallyForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_PartiallyForget_@2
comment "Append c to the cracked BAT of b and partially forget 
         the cracker index, i.e., forget only what is affected";

command insertionsBForce(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_Force_@2
comment "Merge the insertions BAT with the cracker bat and update the cracker index";


command printCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKprintCrackerInsertions
comment "Print the pending insertions of the cracker BAT of b";

command printCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKprintCrackerDeletions
comment "Print the pending deletions of the cracker BAT of b";

command sizeCrackerInsertions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerInsertions
comment "Get the size of the pending insertions of the cracker BAT of b";

command sizeCrackerDeletions(b:bat[:any_1,:@2]):void
address CRKsizeCrackerDeletions
comment "Get the size of the pending deletions of the cracker BAT of b";

command insertionsForget(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertions_Forget
comment "Append c to the cracked BAT of b and completelly forget the cracker index";

command insertionsBOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeed
comment "Keep the insertions BAT separatelly and do a complete merge 
         only if a relevant query arrives in the future";

command insertionsBOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGradually
comment "Keep the insertions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeInsertionsB_OnNeedGraduallyRipple
comment "Keep the insertions BAT separatelly and merge only what is needed 
         using the ripple strategy if a relevant query arrives in the future";

command deletionsOnNeed(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeed
comment "Keep the deletions BAT separatelly and do a complete merge only 
         if a relevant query arrives in the future";

command deletionsOnNeedGradually(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGradually
comment "Keep the deletions BAT separatelly and merge only what is 
         needed if a relevant query arrives in the future";

command deletionsOnNeedGraduallyRipple(b:bat[:any_1,:@2], c:bat[:any_1,:@2]):void
address CRKmergeDeletions_OnNeedGraduallyRipple
comment "Keep the deletions BAT separatelly and merge only what is 
         needed using ripple if a relevant query arrives in the future";

command extendCrackerBAT(b:bat[:any_1,:@2], P:lng):void
address CRKextendCrackerBAT
comment "Extend the cracker column by P positions";
@
@= Index
command printCrackerIndexBATpart(b:bat[:any_1,:@2]):void
address CRKprintCrackerIndexBATpart
comment "Print the cracker index of b";

command printCrackerBAT(b:bat[:any_1,:@2]):void
address CRKprintCrackerBAT
comment "Print the cracker BAT of b";

command getCrackerBAT(b:bat[:oid,:@2]):bat[:oid,:@2]
address CRKgetCrackerBAT
comment "Get the cracker BAT of b";

command printAVLTree_int(b:bat[:any_1,:@2]):void
address CRKprintAVLTree_int
comment "Print the AVL Tree of the cracker index (for debugging purposes)";
@
@= CoreUnordered
command zcrackUnordered (b:bat[:oid,:@2], mid:@2) :bat[:oid,:@2]
address CRKcrackUnorderedZero_@2
comment "Break a BAT into two pieces with
	 tail<=mid, tail>mid,
	 respectively.";

command zcrackUnordered (b:bat[:oid,:@2], low:@2, hgh:@2) :bat[:oid,:@2]
address CRKcrackUnorderedThree_@2
comment "Break a BAT into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively.";
@
@= Validate
@:crack_validate(@2,Ordered,; maintaining the head-oid order within each piece)@
@:crack_validate(@2,Unordered,)@

command verifyCrackerIndex(b:bat[:any_1,:@2]):void
address CRKverifyCrackerIndex_@2
comment "Check the cracker index and column, whether each value is in the correct chunk";
@
@= crack_validate
command zcrack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2Zero_validate_@1
comment "Validate whether a BAT is correctly broken into two pieces with
	 tail<=mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], mid:@1) :bit
address CRKcrack@2One_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<mid, tail==mid, tail>mid,
	 respectively@3.";

command crack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Two_validate_@1
comment "Validate whether a BAT is correctly broken into five pieces with
	 tail<low, tail==low, low<tail<hgh, tail==hgh, tail>hgh,
	 respectively@3.";

command zcrack@2_validate (b:bat[:oid,:@1], low:@1, hgh:@1) :bit
address CRKcrack@2Three_validate_@1
comment "Validate whether a BAT is correctly broken into three pieces with
	 tail<=low, low<tail<=hgh, tail>hgh,
	 respectively@3.";
@
@= Sideways
command getMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):bat[:@1,:@2]
address getCrackerMap
comment "Get a certain map";

command DeleteMap( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):void
address DeleteCrackerMap
comment "Throw away a certain map"; 

command insert( b:bat[:oid,:@1], bp:bat[:oid,:@2], c:bat[:@1,:@2]):void
address CRKinsert
comment "Keep the insertions BAT separatelly and merge in the future on demand with the Ripple";

command printPendingInsertions( b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKprintPendingInsertions
comment "Print the pending insertions";

command extendCrackerMap(b:bat[:oid,:@1], bp:bat[:oid,:@2], P:lng):void
address CRKextendCrackerMap
comment "Extend the cracker map by P positions";

command sizePendingInsertions(b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKsizePendingInsertions
comment "Get the size of the pending insertions for this map";



command hselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSideways_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSideways_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command dselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKdselectBoundsSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 disjunctive predicate outside the cracked area. Return a bit vector.";


command joinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command jointhetaselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, op:str):bat[:oid,:bit]
address CRKjointhetaSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command djoinselect( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKdjoinSelectSideways_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 0, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If yes mark the pivot BUN as 1.";


command project( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrack_@1_@2
comment "Sync map and project the tail";

command project( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProject_@1_@2
comment "Sync map and project tail based on pivot";

command projectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectH_@1_@2
comment "Sync map and project head based on pivot";

command positionproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],PositionPivot:bat[:oid,:oid],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKPositionProject_@1_@2
comment "Sync the cracking pair and project the tail. The pivot holds the positions to be projected";

command markedproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMarkedProject_@1_@2
comment "Sync the cracking pair and project the tail. The result bat has a marked head";

command dproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@2]
address CRKdProject_@1_@2
comment "Sync the cracking pair and project the tail. Use for disjunctive queries that require a larger bit vector";

command dprojectH( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@1]
address CRKdProjectH_@1_@2
comment "Sync the cracking pair and project the head. Use for disjunctive queries that require a larger bit vector";

command positionproject( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:oid]):bat[:oid,:@2]
address CRKdPositionProject_@1_@2
comment "Sync the cracking pair and project the tail. Use position based pivot";

command pmselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKselectBoundsIncrementalSideways_@1_@2
comment "Crack based on @1 and evaluate the @2 conjunctive predicate. Return a bit vector.";

command pmtselect(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBoundsTailIncrementalSideways_@1_@2
comment "Crack based on @1 and project the @2 tail .";

command pmjoinselect(b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectIncrementalSideways_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair(collection of pieces) satisfies the range restriction. If not mark the pivot BUN as 0.";

command pmproject(b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectIncrementalSideways_@1_@2
comment "Sync the map and project the tail based on the pivot";

command pmmaxTail(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMaxTailIncrementalSideways_@1_@2
comment "Sync/crack the map and get the max of the tail";

command pmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReference
comment "add bp reference to map set of b";

command pmclearReferences(b:bat[:oid,:@1]):void
address CRKclearReferences
comment "clear all references to b";

command fmaddReference(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReferenceFullMaps
comment "add bp reference to map set of b";

command fmcreateMap(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKcreateFullMap_@1_@2
comment "make new map for debugging";



command getMaphol( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):bat[:@1,:@2]
address getCrackerMaphol
comment "Get a certain map";

command DeleteMaphol( b:bat[:oid,:@1], bp:bat[:oid,:@2] ):void
address DeleteCrackerMaphol
comment "Throw away a certain map"; 

command inserthol( b:bat[:oid,:@1], bp:bat[:oid,:@2], c:bat[:@1,:@2]):void
address CRKinserthol
comment "Keep the insertions BAT separatelly and merge in the future on demand with the Ripple";

command printPendingInsertionshol( b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKprintPendingInsertionshol
comment "Print the pending insertions";

command extendCrackerMaphol(b:bat[:oid,:@1], bp:bat[:oid,:@2], P:lng):void
address CRKextendCrackerMaphol
comment "Extend the cracker map by P positions";

command sizePendingInsertionshol(b:bat[:oid,:@1], bp:bat[:oid,:@2]):void
address CRKsizePendingInsertionshol
comment "Get the size of the pending insertions for this map";



command hselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKhselectBoundsSidewayshol_@1_@2
comment "Retrieve the subset head using a cracker
        index producing preferably a BATview.";

command tselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKtselectBoundsSidewayshol_@1_@2
comment "Retrieve the subset tail using a cracker
        index producing preferably a BATview.";

command dselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKdselectBoundsSidewayshol_@1_@2
comment "Crack based on @1 and evaluate the @2 disjunctive predicate outside the cracked area. Return a bit vector.";


command joinselecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectSidewayshol_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command jointhetaselecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, op:str):bat[:oid,:bit]
address CRKjointhetaSelectSidewayshol_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If not mark the pivot BUN as 0.";

command djoinselecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKdjoinSelectSidewayshol_P_@1_@2
comment "Use the pivot. For each tuple in pivot with a 0, check if the respective tuple (in the same position)
	 in the tail of cpair satisfies the range restriction. If yes mark the pivot BUN as 1.";


command projecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2], l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectCrackhol_@1_@2
comment "Sync map and project the tail";

command projecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjecthol_@1_@2
comment "Sync map and project tail based on pivot";

command projectHhol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@1]
address CRKProjectHhol_@1_@2
comment "Sync map and project head based on pivot";

command positionprojecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2],PositionPivot:bat[:oid,:oid],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKPositionProjecthol_@1_@2
comment "Sync the cracking pair and project the tail. The pivot holds the positions to be projected";

command markedprojecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMarkedProjecthol_@1_@2
comment "Sync the cracking pair and project the tail. The result bat has a marked head";

command dprojecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@2]
address CRKdProjecthol_@1_@2
comment "Sync the cracking pair and project the tail. Use for disjunctive queries that require a larger bit vector";

command dprojectHhol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit]):bat[:oid,:@1]
address CRKdProjectHhol_@1_@2
comment "Sync the cracking pair and project the head. Use for disjunctive queries that require a larger bit vector";

command positionprojecthol( b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:oid]):bat[:oid,:@2]
address CRKdPositionProjecthol_@1_@2
comment "Sync the cracking pair and project the tail. Use position based pivot";

command pmselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit,l2:@2,h2:@2,li2:bit,hi2:bit):bat[:oid,:bit]
address CRKselectBoundsIncrementalSidewayshol_@1_@2
comment "Crack based on @1 and evaluate the @2 conjunctive predicate. Return a bit vector.";

command pmtselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKselectBoundsTailIncrementalSidewayshol_@1_@2
comment "Crack based on @1 and project the @2 tail .";

command pmjoinselecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2], pivot:bat[:oid,:bit], cl:@1, ch:@1, cli:bit, chi:bit, l:@2, h:@2, li:bit, hi:bit ):bat[:oid,:bit]
address CRKjoinSelectIncrementalSidewayshol_@1_@2
comment "Use the pivot. For each tuple in pivot with a 1, check if the respective tuple (in the same position)
	 in the tail of cpair(collection of pieces) satisfies the range restriction. If not mark the pivot BUN as 0.";

command pmprojecthol(b:bat[:oid,:@1],bp:bat[:oid,:@2],pivot:bat[:oid,:bit],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKProjectIncrementalSidewayshol_@1_@2
comment "Sync the map and project the tail based on the pivot";

command pmmaxTailhol(b:bat[:oid,:@1],bp:bat[:oid,:@2],l:@1,h:@1,li:bit,hi:bit):bat[:oid,:@2]
address CRKMaxTailIncrementalSidewayshol_@1_@2
comment "Sync/crack the map and get the max of the tail";

command pmaddReferencehol(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReferencehol
comment "add bp reference to map set of b";

command pmclearReferenceshol(b:bat[:oid,:@1]):void
address CRKclearReferenceshol
comment "clear all references to b";

command fmaddReferencehol(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKaddReferenceFullMapshol
comment "add bp reference to map set of b";

command fmcreateMaphol(b:bat[:oid,:@1],bp:bat[:oid,:@2]):void
address CRKcreateFullMaphol_@1_@2
comment "make new map for debugging";
@
@= Aggregation
command sumhol(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):@2
address CRKsumholBounds_@2
comment "Calculate aggregate sum of range l-h.";

command sumholpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):@2
address CRKsumholplBounds_@2
comment "Calculate aggregate sum of range l-h.";

command sumpl(b:bat[:any_1,:@2],l:@2,h:@2,li:bit,hi:bit):@2
address CRKsumplBounds_@2
comment "Calculate aggregate sum of range l-h.";
@

@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_H_
#define _CRACKERS_H_

/*#define DEBUG_CRACKERS*/
/*#define DEBUG_CRACKERS_INSERTIONS*/

#ifdef WIN32
#ifndef LIBCRACKERS
#define crackers_export extern __declspec(dllimport)
#else
#define crackers_export extern __declspec(dllexport)
#endif
#else
#define crackers_export extern
#endif

#include "mtime.h"
#include "crackers_index.h"
#include "crackers_validation.h"
#include "crackers_select_ops.h"
#include "crackers_parallelselect_ops.h"
#include "crackers_selectst_ops.h"
#include "crackers_selectstpl_ops.h"
#include "crackers_selecthol_ops.h"
#include "crackers_selectholst_ops.h"
#include "crackers_selectholpl_ops.h"
#include "crackers_selectpl_ops.h"
#include "crackers_holistic.h"
#include "crackers_holisticsideways.h"
#include "crackers_core_unordered.h"
#include "crackers_multicore_unordered.h"
#include "crackers_AVL_tree.h"
#include "crackers_updates.h"
#include "crackers_sideways.h"
#include "crackers_sidewayshol.h"

#ifdef LIBCRACKERS 
extern int maxCrackMap;
extern CrackerIndexNode *CrackerIndex;
extern int IndexEntries;
extern int IndexSize;
extern int IndexStop;
extern struct storageManagement *StorageInfo;
#endif

#endif /* _CRACKERS_H */


@c
/*
 * @+ Implementation
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

int maxCrackMap = 0;

CrackerIndexNode *CrackerIndex;

struct storageManagement *StorageInfo = NULL;

int IndexEntries = 20000000; /* Initial size used for the bat that stores index values */


/* Temp variables used to test the effect of stop updating the index, they operate only on one cracker bat */
int IndexSize = 0;
int IndexStop = 10000000;
