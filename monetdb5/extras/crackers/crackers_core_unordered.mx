@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f crackers_core_unordered

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Core Cracking (unordered)
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(bte,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@
@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(lng,,simple,,lng,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@
@= TypeSwitch_4
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,lng,simple,,,@2)@
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(lng,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@
@:@1(lng,lng,simple,,,@2)@
@:@1(lng,int,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@
@= TypeSwitch_5
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(lng,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
@:TypeSwitch_4(operationsSideways,_decl)@
@:TypeSwitch_2(operationsSideways_str,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
/*
 * @- Exported signatures
 */
@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid, int nthreads, int vector_elements);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@
 * @- Signatures shared within the crackers module/library
@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3,<=,>)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3,<,>=)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@
@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos, int nthreads, int vector_elements);
@
@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc);
@
@= operationsSideways
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@
@= operationsSideways_str
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RO,LT,GE,LT,GE,@3,@4)@
@
@= crackInTwoUnorderedPiecesSideways_decl
str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, oid first, oid last, oid *pos);
@
@= crackInTwoUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, oid first, oid last, oid *pos);
@
@= crackInThreeUnorderedPiecesSideways_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@
@= crackInThreeUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"
#include<math.h>
//#define CRACK_MUTLI_THREAD_DEBUG

/* argument struct for countThread & crackThread functions */
typedef struct {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	int id;            /* thread id */
 #endif
	const BAT *b;      /* BAT to be cracked */
	const void *mval;  /* pivot value */
	BUN first;         /* offset of first value in slice */
	BUN last;          /* offset of last value in slice */
	BUN pos_r;         /* first(!) pos of right(!) piece */
	const char *msg;   /* error message */
	BUN m;             /* size of half slice */
	BUN ml;             /* size of left slice */
	BUN mr;             /* size of right slice */
	int vector_elements;
} c_Thread_t;

typedef struct {
	BUN left, right;
} cursorDeltas;

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@
@:TypeSwitch_4(operationsSideways,_impl)@
@:TypeSwitch_2(operationsSideways_str,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
/*
 * @- Exported functions
 */
@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid, int nthreads, int vector_elements){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
       /* if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(BUN) 0, BATcount(b)-1, &pos, nthreads, vector_elements);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@
 * @- Functions shared within the crackers module/library
@= crackInTwoUnorderedPieces_impl


/* original single-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_ST( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1  *ft, *lt, *t0;
	oid *fh, *lh;
        oid hdummy;
        @1 tdummy;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
        lng t_0, t_1;
	
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_ST ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, last);
	t_0 = GDKusec();
 #endif

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        fh = (oid*)Hloc(b, BUNfirst(b) + first);
        lh = (oid*)Hloc(b, BUNfirst(b) + last);

        while(ft<lt) {
                if (@5_@3(ft, &mval,@6@1)){
                        ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@
                        lt--;lh--;
                        ft++;fh++;
                }
        }

	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = (oid) BUNfirst(b);
			else	
				*pos = (oid) (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = (oid) (lt - t0); 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = (oid) (lt - t0);
		else
			*pos = (oid) BUNfirst(b);
	}		

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_ST ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) -> "OIDFMT" : %.6f secs\n",
		b->batCacheid, (lng) mval, first, last, *pos, (dbl) (t_1 - t_0) / 1000000.0);
 #endif
		
        return MAL_SUCCEED;
}


/* revised single-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_STxx ( const BAT *b, const @1 mval, const BUN first, const BUN last, const BUN m, BUN *pos_r
 #ifdef CRACK_MUTLI_THREAD_DEBUG
                                 , const char *secs
 #endif
                                )
{
	BUN p = first, q = last, pp = p + m - 1, qq = q + 1 - m;
	oid *src_h;
	@1  *src_t;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STxx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, pp, qq, last, m);
	t_0 = GDKusec();
 #endif

	assert(b);
	assert(pos_r);

	/* input (source) arrays */
	src_h = (oid*) Hloc(b, BUNfirst(b));
	src_t = (@1 *) Tloc(b, BUNfirst(b));

	if (m && pp + 1 < qq) {
		/* crack disjoint left- & right-half of piece / slice */
		while (p <= pp && q >= qq) {
#if 1 /* option 1a */
			/* skip over smaller values from beginning */
			while (p <= pp && src_t[p] @7 mval)
				p++;
			if (p > pp) {
				/* exhausted left half, skip to right one */
				p = qq;
				break; /* not really required */
			}
#endif
#if 0 /* option 1b */
			/* skip over smaller value from beginning */
			if (src_t[p] @7 mval) {
				p++;
				if (p > pp) {
					/* exhausted left half, skip to right one */
					p = qq;
					break; /* not really required */
				}
			}
#endif
			else {
				/* skip over larger values from end */
				while (q >= qq && src_t[q] @8 mval)
					q--;
				if (q < qq) {
					/* exhausted right half, skip to left one */
					q = pp;
					break; /* not really required */
				} else {
					/* swap values */
#if 1 /* option 2a */
					const oid h = src_h[p];
					const @1  t = src_t[p];
					src_h[p] = src_h[q];
					src_t[p] = src_t[q];
					src_h[q] = h;
					src_t[q] = t;
#endif
#if 0 /* option 2b */
					oid h;
					@1  t;
					h = src_h[p];
					src_h[p] = src_h[q];
					src_h[q] = h;
					t = src_t[p];
					src_t[p] = src_t[q];
					src_t[q] = t;
#endif
					p++;
					q--;
					if (p > pp) {
						/* exhausted left half, skip to right one */
						p = qq;
					}
					if (q < qq) {
						/* exhausted left half, skip to right one */
						q = pp;
					}
					if (p > pp || q < qq) {
						break; /* not really required */
					}
				}
			}
		}
	}

	/* crack (remaining) consequtive piece / slice */
	if (!(m && pp + 1 < qq) || p >= qq || q <= pp) {
		while (p < q) {
#if 1 /* option 3a */
			/* skip over smaller values from beginning */
			while (p < q && src_t[p] @7 mval) {
				p++;
			}
#endif
#if 0 /* option 3b */
			/* skip over smaller value from beginning */
			if (src_t[p] @7 mval) {
				p++;
			} else 
#endif
			{
				/* skip over larger values from end */
				while (p < q && src_t[q] @8 mval) {
					q--;
				}
				if (p < q)
				{
					/* swap values */
#if 1 /* option 4a */
					const oid h = src_h[p];
					const @1  t = src_t[p];
					src_h[p] = src_h[q];
					src_t[p] = src_t[q];
					src_h[q] = h;
					src_t[q] = t;
#endif
#if 0 /* option 4b */
					oid h;
					@1  t;
					h = src_h[p];
					src_h[p] = src_h[q];
					src_h[q] = h;
					t = src_t[p];
					src_t[p] = src_t[q];
					src_t[q] = t;
#endif
					p++;
					q--;
				}
			}
		}
	}

	/* return pivot position, i.e., first(!) pos in right(!) piece */
	assert(p >= first && p <= last);
	if (m && pp + 1 < qq) {
		if (p <= pp + 1) {
			assert(p == first || src_t[p-1] @7 mval);
			while (p <= pp && src_t[p] @7 mval)
				p++;
			if (p == pp + 1)
				p = qq;
		}
		if (p >= qq) {
			assert((p == qq && src_t[pp] @7 mval) || (p > qq && src_t[p-1] @7 mval));
			while (p <= last && src_t[p] @7 mval)
				p++;
		}
	} else {
		assert(p == first || src_t[p-1] @7 mval);
		while (p <= last && src_t[p] @7 mval)
			p++;
	}

	assert(p >= first && p <= last + 1);
	assert(p == first || (m && pp + 1 < qq && p == qq && src_t[pp] @7 mval) || (!(m && pp + 1 < qq && p == qq) && src_t[p-1] @7 mval));
	assert(p == last + 1 || src_t[p] @8 mval);
#ifndef NDEBUG
	for (q = first; q < p; q++) {
		if (m && pp + 1 < qq && q == pp + 1) {
			q = qq;
			if (q >= p)
				break;
		}
		if (!(src_t[q] @7 mval))
			fprintf(stderr,"a "BUNFMT": %d !@7 %d\n",q,(int)src_t[q],(int)mval);
	}
	for (q = p; q <= last; q++) {
		if (m && pp + 1 < qq && q == pp + 1)
			q = qq;
		if (!(src_t[q] @8 mval))
			fprintf(stderr,"b "BUNFMT": %d !@8 %d\n",q,(int)src_t[q],(int)mval);
	}
#endif
	*pos_r = p;

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STxx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) -> "BUNFMT" : %.6f %s\n",
		b->batCacheid, (lng) mval, first, pp, qq, last, m, *pos_r, (dbl) (t_1 - t_0) / 1000000.0, secs);
 #endif

	return MAL_SUCCEED;
}

/* revised single-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_STxxx ( const BAT *b, const @1 mval, const BUN first, const BUN last, const BUN ml, const BUN mr, BUN *pos_r
 #ifdef CRACK_MUTLI_THREAD_DEBUG
                                 , const char *secs
 #endif
                                )
{
	BUN p = first, q = last, pp = p + ml - 1, qq = q + 1 - mr;
	oid *src_h;
	@1  *src_t;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STxx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, pp, qq, last, m);
	t_0 = GDKusec();
 #endif

	assert(b);
	assert(pos_r);

	/* input (source) arrays */
	src_h = (oid*) Hloc(b, BUNfirst(b));
	src_t = (@1 *) Tloc(b, BUNfirst(b));

	if (ml && mr && pp + 1 < qq) {
		/* crack disjoint left- & right-half of piece / slice */
		while (p <= pp && q >= qq) {
			/* skip over smaller values from beginning */
			while (p <= pp && src_t[p] @7 mval)
				p++;
			if (p > pp) {
				/* exhausted left half, skip to right one */
				p = qq;
				break; /* not really required */
			}
			else {
				/* skip over larger values from end */
				while (q >= qq && src_t[q] @8 mval)
					q--;
				if (q < qq) {
					/* exhausted right half, skip to left one */
					q = pp;
					break; /* not really required */
				} else {
					/* swap values */
					const oid h = src_h[p];
					const @1  t = src_t[p];
					src_h[p] = src_h[q];
					src_t[p] = src_t[q];
					src_h[q] = h;
					src_t[q] = t;
					p++;
					q--;
					if (p > pp) {
						/* exhausted left half, skip to right one */
						p = qq;
					}
					if (q < qq) {
						/* exhausted left half, skip to right one */
						q = pp;
					}
					if (p > pp || q < qq) {
						break; /* not really required */
					}
				}
			}
		}
	}

	/* crack (remaining) consequtive piece / slice */
	if (!(ml && mr && pp + 1 < qq) || p >= qq || q <= pp) {
		while (p < q) {
			/* skip over smaller values from beginning */
			while (p < q && src_t[p] @7 mval) {
				p++;
			}
			/* skip over larger values from end */
			while (p < q && src_t[q] @8 mval) {
				q--;
			}
			if (p < q)
			{
			/* swap values */
				const oid h = src_h[p];
				const @1  t = src_t[p];
				src_h[p] = src_h[q];
				src_t[p] = src_t[q];
				src_h[q] = h;
				src_t[q] = t;
				p++;
				q--;
			}
		}
	}

	/* return pivot position, i.e., first(!) pos in right(!) piece */
	assert(p >= first && p <= last);
	if (ml && mr && pp + 1 < qq) {
		if (p <= pp + 1) {
			assert(p == first || src_t[p-1] @7 mval);
			while (p <= pp && src_t[p] @7 mval)
				p++;
			if (p == pp + 1)
				p = qq;
		}
		if (p >= qq) {
			assert((p == qq && src_t[pp] @7 mval) || (p > qq && src_t[p-1] @7 mval));
			while (p <= last && src_t[p] @7 mval)
				p++;
		}
	} else {
		assert(p == first || src_t[p-1] @7 mval);
		while (p <= last && src_t[p] @7 mval)
			p++;
	}

	assert(p >= first && p <= last + 1);
	assert(p == first || (ml && mr && pp + 1 < qq && p == qq && src_t[pp] @7 mval) || (!(ml && mr && pp + 1 < qq && p == qq) && src_t[p-1] @7 mval));
	assert(p == last + 1 || src_t[p] @8 mval);
#ifndef NDEBUG
	for (q = first; q < p; q++) {
		if (ml && mr && pp + 1 < qq && q == pp + 1) {
			q = qq;
			if (q >= p)
				break;
		}
		if (!(src_t[q] @7 mval))
			fprintf(stderr,"a "BUNFMT": %d !@7 %d\n",q,(int)src_t[q],(int)mval);
	}
	for (q = p; q <= last; q++) {
		if (ml && mr && pp + 1 < qq && q == pp + 1)
			q = qq;
		if (!(src_t[q] @8 mval))
			fprintf(stderr,"b "BUNFMT": %d !@8 %d\n",q,(int)src_t[q],(int)mval);
	}
#endif
	*pos_r = p;

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STxx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) -> "BUNFMT" : %.6f %s\n",
		b->batCacheid, (lng) mval, first, pp, qq, last, m, *pos_r, (dbl) (t_1 - t_0) / 1000000.0, secs);
 #endif

	return MAL_SUCCEED;
}

static str
CRKcrackUnorderedZero_@2_@1_STx ( const BAT *b, const @1 mval, const BUN first, const BUN last, const BUN m, oid *pos
 #ifdef CRACK_MUTLI_THREAD_DEBUG
                                 , const char *secs
 #endif
                                )
{
	str msg;
	BUN pos_r;

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, last, m);
	t_0 = GDKusec();
 #endif

	assert(b);
	assert(pos);
	assert(m == 0 || first + m - 1 + 1 == last + 1 - m);

	msg = CRKcrackUnorderedZero_@2_@1_STxx ( b, mval, first, last, m, &pos_r
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	                                            , "se"
 #endif
	                                           );
	/* pivot: turn first of right piece into last of left piece (if possible) */
	*pos = (oid) (pos_r == 0 ? 0 : pos_r - 1);

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STx ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) -> "OIDFMT" : %.6f %s\n",
		b->batCacheid, (lng) mval, first, last, m, *pos, (dbl) (t_1 - t_0) / 1000000.0, secs);
 #endif

	return msg;
}


/* crackThread for new multi-threaded crack code */
static void*
CRKcrackUnorderedZero_@2_@1_MT_crackThread ( void *arg_p )
{
	c_Thread_t *arg = (c_Thread_t*) arg_p;
	@1 mval = * (@1*) arg->mval;
	BUN pos_r;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_crackThread ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) ...\n",
		arg->id, (lng) mval, arg->first, arg->last, arg->m);
	t_0 = GDKusec();
 #endif

	/* call actual cracking routine for this slice */
	arg->msg = CRKcrackUnorderedZero_@2_@1_STxx ( arg->b, mval, arg->first, arg->last, arg->m, &pos_r
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	                                            , "se"
 #endif
	                                           );
	arg->pos_r = pos_r;

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_crackThread ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) -> "BUNFMT" : %.6f s\n",
		arg->id, (lng) mval, arg->first, arg->last, arg->m, pos_r, (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	pthread_exit(NULL);
	return NULL;
}


/* new multi-threaded crack code; Alternative 2 */
static str
CRKcrackUnorderedZero_@2_@1_MT ( const BAT *b, const @1 mval, const BUN first, const BUN last, oid *pos, int nthreads, int alt)
{
	BUN n = last - first + 1; /* total # tuples / values */
	BUN m;                    /* # tuples / values per slice */
	BUN mm;                   /* # tuples / values in tmp arrays */
	BUN f, l;                 /* first / last BUN per slice */
	pthread_t *c_Thread;      /* threads array */
	c_Thread_t *c_Thread_arg; /* thread arguments array */
	oid *src_h = (oid*) Hloc(b, BUNfirst(b)), *tmp_h;
	@1  *src_t = (@1 *) Tloc(b, BUNfirst(b)), *tmp_t;
	int i, j;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1, t_2;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d, %d ) ...\n",
		b->batCacheid, (lng) mval, first, last, nthreads, alt);
	t_0 = GDKusec();
 #endif

	/* adjust nthreads */
	if (nthreads == 0) {
		/* automatic setting */
		nthreads = GDKnr_threads;
	}
	if ((BUN) nthreads > n / 1000) {
		/* more threads / smaller slices does not make sense */
		nthreads = (int) (n / 1000) + 1;
	}
	m = (n / nthreads) / alt;
	mm = (alt == 1) ? m : 3 * m;

	tmp_h = GDKmalloc(mm * sizeof(oid));
	tmp_t = GDKmalloc(mm * sizeof(@1 ));
	c_Thread = GDKmalloc (nthreads * sizeof(pthread_t));
	c_Thread_arg  = GDKzalloc(alt * nthreads * sizeof(c_Thread_t));
	if (!tmp_h || !tmp_t || !c_Thread || !c_Thread_arg) {
		if (tmp_h)
			GDKfree(tmp_h);
		if (tmp_t)
			GDKfree(tmp_t);
		if (c_Thread)
			GDKfree(c_Thread);
		if (c_Thread_arg)
			GDKfree(c_Thread_arg);
		throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): GDKmalloc() failed.");
	}

	/* initilize crackThread arguments */
	if (alt == 1) {
		/* Alternative 1:
		   - each thread cracks one consecutive slice */
		for (i = 0, f = first, l = f + m - 1; i < nthreads; i++, f += m, l += m) {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
			c_Thread_arg[i].id      = i;
 #endif
			c_Thread_arg[i].b       = b;
			c_Thread_arg[i].mval    = &mval;
			c_Thread_arg[i].first   = f;
			c_Thread_arg[i].last    = (i < nthreads - 1) ? l : last;
			c_Thread_arg[i].m       = 0;
		}
	} else /* alt == 2 */ {
		/* Alternative 2:
		   - nthreads-1 threads crack two disjoint half-slices
		     (from either end of the input piece), each
		   - last thread cracks center consecutive slice */
		for (i = 0, f = first, l = last; i < nthreads; i++, f += m, l -= m) {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
			c_Thread_arg[i].id      = i;
 #endif
			c_Thread_arg[i].b       = b;
			c_Thread_arg[i].mval    = &mval;
			c_Thread_arg[i].first   = f;
			c_Thread_arg[i].last    = l;
			if (nthreads!=1)
				c_Thread_arg[i].m = (i < nthreads - 1) ? m : l - f + 1;
			else
				c_Thread_arg[i].m = 0;
		}
	}

	/* crack slices concurrently */
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_2 = GDKusec();
 #endif
	/* spawn crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (pthread_create(&c_Thread[i], NULL, CRKcrackUnorderedZero_@2_@1_MT_crackThread, &c_Thread_arg[i])) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed spaning crackThread %d.", i);
		}
	}
	/* join crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (pthread_join(c_Thread[i], NULL)) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed joining crackThread %d.", i);
		 }
	}
	/* check for & report failing crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (c_Thread_arg[i].msg != MAL_SUCCEED) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): crackThread %d failed with '%s'.", i, c_Thread_arg[i].msg);
		 }
	}
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d, %d ) crack : %.6f sec\n",
		b->batCacheid, (lng) mval, first, last, nthreads, alt, (dbl) (t_1 - t_2) / 1000000.0);
 #endif

	/* "meta-crack":
	   move "wrong" parts of slices to correct final location */
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_2 = GDKusec();
 #endif
	if (alt == 2) {
		/* Alt. 2: treat each half-slice as individual slice */
		for (i = 0, j = 2 * nthreads - 2; i < nthreads - 1; i++, j--) {
			assert(i < j - 1);
			assert(c_Thread_arg[i].m > 0);
			c_Thread_arg[j].m     = c_Thread_arg[i].m;
			c_Thread_arg[j].last  = c_Thread_arg[i].last;
			c_Thread_arg[j].first = c_Thread_arg[i].last  - c_Thread_arg[i].m + 1;
			c_Thread_arg[i].last  = c_Thread_arg[i].first + c_Thread_arg[i].m - 1;
			assert(first <= c_Thread_arg[i].first);
			assert(c_Thread_arg[i].first < c_Thread_arg[i].last);
			assert(c_Thread_arg[i].last /*+ 1*/ < c_Thread_arg[j].first);
			assert(c_Thread_arg[j].first < c_Thread_arg[j].last);
			assert(c_Thread_arg[j].last <= last);
			if (c_Thread_arg[i].pos_r < c_Thread_arg[j].first) {
				c_Thread_arg[j].pos_r = c_Thread_arg[j].first;
			} else {
				c_Thread_arg[j].pos_r = c_Thread_arg[i].pos_r;
				c_Thread_arg[i].pos_r = c_Thread_arg[i].last + 1;
			}
		}
		assert(i == j);
	}
	i = 0;
	j = alt * nthreads - alt;
	while (i < j) {
#if 1 /* option 5a */
		/* skip over entirely smaller slices from beginning */
		while (i < j && c_Thread_arg[i].pos_r > c_Thread_arg[i].last) {
			i++;
		}
#endif
#if 0 /* option 5b */
		/* skip over entirely smaller slice from beginning */
		if (c_Thread_arg[i].pos_r > c_Thread_arg[i].last) {
			i++;
		} else
#endif
		{
			/* skip over entirely larger slices from end */
			while (i < j && (c_Thread_arg[j].pos_r <=  c_Thread_arg[j].first)) {
				j--;
			}
			if (i < j) {
				/* size of "wrong" part of left slice with larger values */
				const BUN si = c_Thread_arg[i].last + 1 - c_Thread_arg[i].pos_r;
				/* size of "wrong" part of right slice with smaller values */
				const BUN sj = c_Thread_arg[j].pos_r - c_Thread_arg[j].first;
				const BUN sk = MIN( si , sj );
				const BUN sh = sk * sizeof(oid);
				const BUN st = sk * sizeof(@1);
				const BUN pi = c_Thread_arg[i].pos_r;
				const BUN pj = c_Thread_arg[j].pos_r - sk;

				assert(si <= mm);
				assert(sj <= mm);

#if 0 /* option 6a */
				memcpy(tmp_h, &src_h[pi], sh);
				memcpy(tmp_t, &src_t[pi], st);
				memcpy(&src_h[pi], &src_h[pj], sh);
				memcpy(&src_t[pi], &src_t[pj], st);
				memcpy(&src_h[pj], tmp_h, sh);
				memcpy(&src_t[pj], tmp_t, st);
#endif
#if 1 /* option 6b */
				memcpy(tmp_h, &src_h[pi], sh);
				memcpy(&src_h[pi], &src_h[pj], sh);
				memcpy(&src_h[pj], tmp_h, sh);
				memcpy(tmp_t, &src_t[pi], st);
				memcpy(&src_t[pi], &src_t[pj], st);
				memcpy(&src_t[pj], tmp_t, st);
#endif

				c_Thread_arg[i].pos_r += sk;
				c_Thread_arg[j].pos_r -= sk;

				assert((si <= sj) == (c_Thread_arg[i].pos_r == c_Thread_arg[i].last + 1));
				assert((sj <= si) == (c_Thread_arg[j].pos_r == c_Thread_arg[j].first));

				i += (si <= sj);
				j -= (sj <= si);
			}
		}
	}
	/* determine pivot */
	f = BUN_NONE;
	for (i = 0, j = alt * nthreads - alt; i <= j; j--) {
		l = c_Thread_arg[j].pos_r;
		if (l == last + 1 ||
		    (l <= last && src_t[l] @8 mval &&
		     (l == first || src_t[l - 1] @7 mval))) {
			if (f == BUN_NONE) {
				f = l;
			} else {
				assert(f == l);
			}
		}
	}
	assert(f != BUN_NONE);
	assert((f == last + 1 && src_t[f-1] @7 mval) || src_t[f]   @8 mval);
	assert((f == first    && src_t[f]   @8 mval) || src_t[f-1] @7 mval);
#ifndef NDEBUG
	for (l = first; l < f; l++)
		if (!(src_t[l] @7 mval))
			fprintf(stderr,"c "BUNFMT": %d !@7 %d\n",l,(int)src_t[l],(int)mval);
	for (l = f; l <= last; l++)
		if (!(src_t[l] @8 mval))
			fprintf(stderr,"d "BUNFMT": %d !@8 %d\n",l,(int)src_t[l],(int)mval);
#endif
	/* pivot: turn first of right piece into last of left piece (if possible) */
	*pos = (oid) (f == 0 ? 0 : f - 1);
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d, %d ) meta-crack : %.6f sec\n",
		b->batCacheid, (lng) mval, first, last, nthreads, alt, (dbl) (t_1 - t_2) / 1000000.0);
 #endif

	GDKfree(tmp_h);
	GDKfree(tmp_t);
	GDKfree(c_Thread);
	GDKfree(c_Thread_arg);

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d, %d ) -> "OIDFMT" : %.6f secs\n",
		b->batCacheid, (lng) mval, first, last, nthreads, alt, *pos, (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	return MAL_SUCCEED;
}
static cursorDeltas performCrackOnVectors_@2_@1(const @1* input, @1* leftOutput, @1* rightOutput, const @1 pivot, const oid* inputPayload, oid* leftOutputPayload, oid* rightOutputPayload, int vector_elements){
	BUN rightOutI = 0, leftOutI = 0, inI;
	unsigned int  isLessThan;

	for (inI = 0; inI < (BUN)vector_elements; inI++){
		rightOutput[rightOutI] = input[inI];
		rightOutputPayload[rightOutI] = inputPayload[inI];
		isLessThan = (input[inI] @7 pivot);
		rightOutI -= (~isLessThan)&1;
		leftOutput[leftOutI] = input[inI];
		leftOutputPayload[leftOutI] = inputPayload[inI];
		leftOutI += isLessThan;
	}
	return (cursorDeltas){.left = leftOutI, .right = rightOutI};
}
static cursorDeltas performCrackOnVectors_left_@2_@1(const @1* input, @1* leftOutput, @1* rightOutput, const @1 pivot, const oid* inputPayload, oid* leftOutputPayload, oid* rightOutputPayload, BUN max, BUN skip, int vector_elements){
	BUN rightOutI = 0, leftOutI = 0, inI;
	unsigned int  isLessThan;

	for (inI = 0; inI < (BUN)vector_elements; inI++){
		rightOutput[rightOutI] = input[inI];
		rightOutputPayload[rightOutI] = inputPayload[inI];
		isLessThan = (input[inI] @7 pivot);
		rightOutI -= (~isLessThan)&1;
		leftOutput[leftOutI] = input[inI];
		leftOutputPayload[leftOutI] = inputPayload[inI];
		leftOutI += isLessThan;
		leftOutI += (leftOutI == max) * skip;
	}
	return (cursorDeltas){.left = leftOutI, .right = rightOutI};
}

static cursorDeltas performCrackOnVectors_right_@2_@1(const @1* input, @1* leftOutput, @1* rightOutput, const @1 pivot, const oid* inputPayload, oid* leftOutputPayload, oid* rightOutputPayload, BUN min, BUN skip, int vector_elements){
	BUN rightOutI = 0, leftOutI = 0, inI;
	unsigned int  isLessThan;

	for (inI = 0; inI < (BUN)vector_elements; inI++){
		rightOutput[rightOutI] = input[inI];
		rightOutputPayload[rightOutI] = inputPayload[inI];
		isLessThan = (input[inI] @7 pivot);
		rightOutI -= (~isLessThan)&1;
		rightOutI -= (rightOutI == min) * skip;
		leftOutput[leftOutI] = input[inI];
		leftOutputPayload[leftOutI] = inputPayload[inI];
		leftOutI += isLessThan;
	}
	return (cursorDeltas){.left = leftOutI, .right = rightOutI};
}

static cursorDeltas performCrackOnVectors_left_right_@2_@1(const @1* input, @1* leftOutput, @1* rightOutput, const @1 pivot, const oid* inputPayload, oid* leftOutputPayload, oid* rightOutputPayload, BUN max, BUN min, BUN skip, int vector_elements){
	BUN rightOutI = 0, leftOutI = 0, inI;
	unsigned int  isLessThan;

	for (inI = 0; inI < (BUN)vector_elements; inI++){
		rightOutput[rightOutI] = input[inI];
		rightOutputPayload[rightOutI] = inputPayload[inI];
		isLessThan = (input[inI] @7 pivot);
		rightOutI -= (~isLessThan)&1;
		rightOutI -= (rightOutI == min) * skip;
		leftOutput[leftOutI] = input[inI];
		leftOutputPayload[leftOutI] = inputPayload[inI];
		leftOutI += isLessThan;
		leftOutI += (leftOutI == max) * skip;
	}
	return (cursorDeltas){.left = leftOutI, .right = rightOutI};
}

static str CRKvectorized_x_@2_@1 (
	/* input */
	const BAT* buffer,      /* attribute (array) */
	const @1 pivot, /* pivot value for attribute*/
	BUN first_left,  /* first position of to-be-cracked piece */
	BUN last_right,  /* last position of to-be-cracked piece */
	BUN ml, 
	BUN mr, 
	BUN *pos_r, /*return position*/
	int vector_elements  /*size of vector*/
) {
	BUN last_left = first_left + ml - 1, first_right = last_right + 1 - mr;
	BUN valueCount = ( (ml && mr && last_left + 1 < first_right) ?  ml + mr : last_right - first_left + 1 );
	const BUN vectorCount = valueCount/vector_elements;
	BUN lowerReadCursor = first_left, upperReadCursor = last_right + 1;
	BUN lowerWriteCursor = first_left, upperWriteCursor = last_right;
	BUN vectorI = 0, vectorR = 3, skip, skip_left, skip_right;
	cursorDeltas deltas;
	oid *src_h = (oid*) Hloc(buffer, BUNfirst(buffer));
	@1  *src_t = (@1 *) Tloc(buffer, BUNfirst(buffer));
	oid *src_h_local = (oid*) GDKmalloc(vector_elements * 3 * sizeof(oid));
	@1  *src_t_local = (@1 *) GDKmalloc(vector_elements * 3 * sizeof(@1));

	assert(buffer && src_h_local && src_t_local);
	assert(pos_r);
	assert(valueCount%(2*vector_elements) == 0);
	assert(!(ml && mr && last_left + 1 < first_right) || (ml%(2*vector_elements) == 0 && mr%(2*vector_elements) == 0));

	if(2*vectorR > vectorCount)
	{
		GDKfree(src_h_local);
		GDKfree(src_t_local);
		src_t_local = NULL;
		src_h_local = NULL;
		return CRKcrackUnorderedZero_@2_@1_STxxx (buffer, pivot, first_left, last_right, ml, mr, pos_r);
	}

        memcpy(src_h_local, src_h + first_left, sizeof(oid)*2*vector_elements);
        memcpy(src_h_local + 2*vector_elements, src_h + upperReadCursor-vector_elements, sizeof(oid)*vector_elements);
        memcpy(src_t_local, src_t + first_left, sizeof(@1)*2*vector_elements);
        memcpy(src_t_local + 2*vector_elements, src_t + upperReadCursor-vector_elements, sizeof(@1)*vector_elements);

	lowerReadCursor += 2*vector_elements;
	upperReadCursor -= vector_elements;

	if (ml && mr && last_left + 1 < first_right) {
		/* we have two disjoint half-pieces */
		for (; vectorI < vectorCount; vectorI++)	{
			assert (lowerWriteCursor <= upperWriteCursor);
			if (lowerWriteCursor >= first_right) {
				/* do remainder on consecutive right half */
				ml = mr = 0;
				first_left = first_right;
				last_left = last_right;
				break;
			}
			if (upperWriteCursor <= last_left) {
				/* do remainder on consecutive left half */
				ml = mr = 0;
				first_right = first_left;
				last_right = last_left;
				break;
			}
			assert (vectorR >= vectorCount || lowerWriteCursor + vector_elements <= lowerReadCursor);
			assert (vectorR >= vectorCount || upperWriteCursor - vector_elements >= upperReadCursor - 1);
			skip = first_right - last_left - 1;
			if (lowerWriteCursor <= last_left && lowerWriteCursor > last_left - vector_elements + 1 &&
			    upperWriteCursor >= first_right && upperWriteCursor < first_right + vector_elements - 1) {
				deltas = performCrackOnVectors_left_right_@2_@1(src_t_local+(vectorI%3)*vector_elements, src_t + lowerWriteCursor, src_t + upperWriteCursor, pivot, src_h_local+(vectorI%3)*vector_elements, src_h + lowerWriteCursor, src_h + upperWriteCursor, (BUN) last_left - lowerWriteCursor + 1, (BUN) first_right - upperWriteCursor - 1, skip, vector_elements);
			} else
			if (lowerWriteCursor <= last_left && lowerWriteCursor > last_left - vector_elements + 1) {
				deltas = performCrackOnVectors_left_@2_@1(src_t_local+(vectorI%3)*vector_elements, src_t + lowerWriteCursor, src_t + upperWriteCursor, pivot, src_h_local+(vectorI%3)*vector_elements, src_h + lowerWriteCursor, src_h + upperWriteCursor, (BUN) last_left - lowerWriteCursor - 1, skip, vector_elements);
			} else
			if (upperWriteCursor >= first_right && upperWriteCursor < first_right + vector_elements - 1) {
				deltas = performCrackOnVectors_right_@2_@1(src_t_local+(vectorI%3)*vector_elements, src_t + lowerWriteCursor, src_t + upperWriteCursor, pivot, src_h_local+(vectorI%3)*vector_elements, src_h + lowerWriteCursor, src_h + upperWriteCursor, (BUN) first_right - upperWriteCursor - 1, skip, vector_elements);
			} else {
				deltas = performCrackOnVectors_@2_@1(src_t_local+(vectorI%3)*vector_elements, src_t + lowerWriteCursor, src_t + upperWriteCursor, pivot, src_h_local+(vectorI%3)*vector_elements, src_h + lowerWriteCursor, src_h + upperWriteCursor, vector_elements);
			}
			lowerWriteCursor += deltas.left;
			upperWriteCursor += deltas.right;
			if (lowerWriteCursor == last_left + 1)
				lowerWriteCursor = first_right;
			if (upperWriteCursor == first_right - 1)
				upperWriteCursor = last_left;
			if (vectorR < vectorCount) {
				skip_left = 0, skip_right = 0;
				if (lowerWriteCursor < first_right && lowerReadCursor > last_left) {
					skip_left = first_right - last_left;
				}
				if (upperReadCursor - 1 < first_right && upperWriteCursor > last_left) {
					skip_right = first_right - last_left;
				}
				if(lowerReadCursor-lowerWriteCursor-skip_left < upperWriteCursor-(upperReadCursor-1)-skip_right){
       					memcpy(src_h_local + (vectorI%3)*vector_elements, src_h + lowerReadCursor, sizeof(oid)*vector_elements);
				        memcpy(src_t_local + (vectorI%3)*vector_elements, src_t + lowerReadCursor, sizeof(@1)*vector_elements);
					lowerReadCursor+=vector_elements;
					if (lowerReadCursor == last_left + 1)
						lowerReadCursor = first_right;
				} else {
      					memcpy(src_h_local + (vectorI%3)*vector_elements, src_h + upperReadCursor-vector_elements, sizeof(oid)*vector_elements);
				        memcpy(src_t_local + (vectorI%3)*vector_elements, src_t + upperReadCursor-vector_elements, sizeof(@1)*vector_elements);
					upperReadCursor-=vector_elements;
					if (upperReadCursor == first_right)
						upperReadCursor = last_left + 1;
				}
				vectorR++;
			}
		}

	} else {
		ml = mr = 0;
		first_right = first_left;
		last_left = last_right;
	}

	for (; vectorI < vectorCount; vectorI++)	{
		/* we only have one consecutive (half-) piece (remaining) */
		assert (lowerWriteCursor <= upperWriteCursor);
		assert (vectorR >= vectorCount || lowerWriteCursor + vector_elements <= lowerReadCursor);
		assert (vectorR >= vectorCount || upperWriteCursor - vector_elements >= upperReadCursor - 1);
		deltas = performCrackOnVectors_@2_@1(src_t_local+(vectorI%3)*vector_elements, src_t + lowerWriteCursor, src_t + upperWriteCursor, pivot, src_h_local+(vectorI%3)*vector_elements, src_h + lowerWriteCursor, src_h + upperWriteCursor, vector_elements);


		lowerWriteCursor += deltas.left;
		upperWriteCursor += deltas.right;
		if (vectorR < vectorCount) {
			if(lowerReadCursor-lowerWriteCursor < upperWriteCursor-(upperReadCursor-1)){
    				memcpy(src_h_local + (vectorI%3)*vector_elements, src_h + lowerReadCursor, sizeof(oid)*vector_elements);
				memcpy(src_t_local + (vectorI%3)*vector_elements, src_t + lowerReadCursor, sizeof(@1)*vector_elements);
				lowerReadCursor+=vector_elements;
			} else {
  				memcpy(src_h_local + (vectorI%3)*vector_elements, src_h + upperReadCursor-vector_elements, sizeof(oid)*vector_elements);
			        memcpy(src_t_local + (vectorI%3)*vector_elements, src_t + upperReadCursor-vector_elements, sizeof(@1)*vector_elements);
				upperReadCursor-=vector_elements;
			}
			vectorR++;
		}
	}

	assert (vectorR == vectorCount);
	//assert(lowerReadCursor == upperReadCursor || (lowerReadCursor == first_right && upperReadCursor == last_left + 1));

	*pos_r = lowerWriteCursor;

	GDKfree(src_h_local);
	GDKfree(src_t_local);

	return MAL_SUCCEED;
}


/* crackThread for new multi-threaded crack code */
static void*
cracking_MT_vectorized_crackThread_@2_@1 ( void *arg_p )
{
	c_Thread_t *arg = (c_Thread_t*) arg_p;
	@1 mval = * (@1*) arg->mval;
	BUN pos_r;

	/* call actual cracking routine for this slice */
	arg->msg = CRKvectorized_x_@2_@1 ( arg->b, mval, arg->first, arg->last, arg->ml, arg->mr, &pos_r, arg->vector_elements);
	arg->pos_r = pos_r;

	pthread_exit(NULL);
	return NULL;
}

static str CRKvectorized_MT_@2_@1 (const BAT *b, BUN first, BUN last, const @1 pivot, oid *pos, int nthreads, int alt, const @1 pivot_P, int vector_elements)
{
        BUN n = last - first + 1; /* total # tuples / values */
        BUN ml;                   /* # tuples / values in left slice */
        BUN mr;                   /* # tuples / values in right slice */
        BUN mm;                   /* # tuples / values in tmp arrays */
        BUN f, l;                 /* first / last BUN per slice */
	BUN last_vector_pos = last;	  /* position of the last element in the last vector*/
	pthread_t *c_Thread;      /* threads array */
        c_Thread_t *c_Thread_arg; /* thread arguments array */
        int i, j;
	oid *src_h = (oid*) Hloc(b, BUNfirst(b)), *tmp_h;
	@1  *src_t = (@1 *) Tloc(b, BUNfirst(b)), *tmp_t;
	BUN remaining_elements = 0;

	/* adjust nthreads */
	if (nthreads == 0) {
		/* automatic setting */
		nthreads = GDKnr_threads;
	}
        if ((BUN) nthreads > n / 1000) {
                /* more threads / smaller slices does not make sense */
                nthreads = (int) (n / 1000) + 1;
        }

	mm = (n / nthreads);
	remaining_elements = (mm % (2 * vector_elements)) * nthreads;
	mm = (n - remaining_elements) / nthreads;
	remaining_elements += ((n - remaining_elements) % nthreads);
	last_vector_pos -= remaining_elements;
	mm -= ((n - remaining_elements) % nthreads);
        if (alt == 1) {
		ml = 0;
		mr = 0;
	} else /* alt == 2 */ {
		ml = (BUN) round(((double) (mm * pivot_P) / 100.0) / (2*vector_elements)) * 2*vector_elements;
		mr = mm - ml;
		if (ml == 0 || mr == 0) {
			alt = 1;
			ml = 0;
			mr = 0;
		}
	}

	tmp_h = GDKmalloc(mm * sizeof(oid));
	tmp_t = GDKmalloc(mm * sizeof(@1 ));
	c_Thread = GDKmalloc (nthreads * sizeof(pthread_t));
        c_Thread_arg  = GDKmalloc(alt * nthreads * sizeof(c_Thread_t));
	if (!tmp_h || !tmp_t || !c_Thread || !c_Thread_arg) {
		if (tmp_h)
			GDKfree(tmp_h);
		if (tmp_t)
			GDKfree(tmp_t);
		if (c_Thread)
			GDKfree(c_Thread);
		if (c_Thread_arg)
			GDKfree(c_Thread_arg);
		throw (MAL, "crackers.select", "CRKvectorized_MT_@2_@1(): GDKmalloc() failed.");
	}

        /* initialize crackThread arguments */
        if (alt == 1) {
                /* Alternative 1: each thread cracks one consecutive slice */
                for (i = 0, f = first, l = f + mm - 1; i < nthreads; i++, f += mm, l += mm) {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
			c_Thread_arg[i].id      = i;
 #endif
                        c_Thread_arg[i].b       = b;
                        c_Thread_arg[i].mval    = &pivot;
                        c_Thread_arg[i].first   = f;
                        c_Thread_arg[i].last    = (i < nthreads - 1) ? l : last_vector_pos;
                        c_Thread_arg[i].ml      = 0;
                        c_Thread_arg[i].mr      = 0;
			c_Thread_arg[i].vector_elements = vector_elements;
                }
        } else /* alt == 2 */ {
                /* Alternative 2: nthreads-1 threads crack two disjoint half-slices (from either end of the input piece), each - last thread cracks center consecutive slice */
                for (i = 0, f = first, l = last_vector_pos; i < nthreads; i++, f += ml, l -= mr) {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
			c_Thread_arg[i].id      = i;
 #endif
                        c_Thread_arg[i].b       = b;
                        c_Thread_arg[i].mval    = &pivot;
                        c_Thread_arg[i].first   = f;
                        c_Thread_arg[i].last    = l;
                        c_Thread_arg[i].ml = (i < nthreads - 1) ? ml : 0;
                        c_Thread_arg[i].mr = (i < nthreads - 1) ? mr : 0;
			c_Thread_arg[i].vector_elements = vector_elements;
                }
        }

	/* spawn crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (pthread_create(&c_Thread[i], NULL, cracking_MT_vectorized_crackThread_@2_@1, &c_Thread_arg[i])) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKvectorized_MT_@2_@1(): Failed spaning crackThread %d.", i);
		}
	}
	/* join crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (pthread_join(c_Thread[i], NULL)) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKvectorized_MT_@2_@1(): Failed joining crackThread %d.", i);
		 }
	}
	/* check for & report failing crackThreads */
	for (i = 0; i < nthreads; i++) {
		if (c_Thread_arg[i].msg != MAL_SUCCEED) {
			GDKfree(tmp_h);
			GDKfree(tmp_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKvectorized_MT_@2_@1(): crackThread %d failed with '%s'.", i, c_Thread_arg[i].msg);
		 }
	}

        /* "meta-crack": move "wrong" parts of slices to correct final location */
        if (alt == 2) {
                /* Alt. 2: treat each half-slice as individual slice */
                for (i = 0, j = 2 * nthreads - 2; i < nthreads - 1; i++, j--) {
			assert(i < j - 1);
			assert(c_Thread_arg[i].ml > 0 && c_Thread_arg[i].mr > 0);
                        c_Thread_arg[j].ml    = c_Thread_arg[i].mr;
                        c_Thread_arg[j].last  = c_Thread_arg[i].last;
                        c_Thread_arg[j].first = c_Thread_arg[i].last  - c_Thread_arg[i].mr + 1;
                        c_Thread_arg[i].last  = c_Thread_arg[i].first + c_Thread_arg[i].ml - 1;
			assert(first <= c_Thread_arg[i].first);
			assert(c_Thread_arg[i].first < c_Thread_arg[i].last);
			assert(c_Thread_arg[i].last /*+ 1*/ < c_Thread_arg[j].first);
			assert(c_Thread_arg[j].first < c_Thread_arg[j].last);
			assert(c_Thread_arg[j].last <= last_vector_pos);
			if (c_Thread_arg[i].pos_r < c_Thread_arg[j].first) {
				c_Thread_arg[j].pos_r = c_Thread_arg[j].first;
			} else {
				c_Thread_arg[j].pos_r = c_Thread_arg[i].pos_r;
				c_Thread_arg[i].pos_r = c_Thread_arg[i].last + 1;
			}
                        c_Thread_arg[j].ml = c_Thread_arg[i].mr = 0;
                        c_Thread_arg[j].mr = c_Thread_arg[i].mr = 0;
                }
		assert(i == j);       
	}
        i = 0;
        j = alt * nthreads - alt;
        while (i < j) {
		/* skip over entirely smaller slices from beginning */
		while (i < j && c_Thread_arg[i].pos_r > c_Thread_arg[i].last)
                        i++;
		{
			/* skip over entirely larger slices from end */
			while (i < j && (c_Thread_arg[j].pos_r <=  c_Thread_arg[j].first))
				j--;
			if (i < j) {
				/* size of "wrong" part of left slice with larger values */
				const BUN si = c_Thread_arg[i].last + 1 - c_Thread_arg[i].pos_r;
				/* size of "wrong" part of right slice with smaller values */
				const BUN sj = c_Thread_arg[j].pos_r - c_Thread_arg[j].first;
				const BUN sk = si > sj ? sj : si;
				const BUN st = sk * sizeof(@1);
				const BUN stp = sk * sizeof(oid);
				const BUN pi = c_Thread_arg[i].pos_r;
				const BUN pj = c_Thread_arg[j].pos_r - sk;

				assert(si <= mm);
				assert(sj <= mm);
                                memcpy(tmp_t, &src_t[pi], st);
                                memcpy(&src_t[pi], &src_t[pj], st);
                                memcpy(&src_t[pj], tmp_t, st);

                               	memcpy(tmp_h, &src_h[pi], stp);
                               	memcpy(&src_h[pi], &src_h[pj], stp);
                               	memcpy(&src_h[pj], tmp_h, stp);

				c_Thread_arg[i].pos_r += sk;
				c_Thread_arg[j].pos_r -= sk;

				assert((si <= sj) == (c_Thread_arg[i].pos_r == c_Thread_arg[i].last + 1));
				assert((sj <= si) == (c_Thread_arg[j].pos_r == c_Thread_arg[j].first));

				i += (si <= sj);
				j -= (sj <= si);
                        }
                }
        }

        /* determine pivot (This is useful only for result validation)*/
        f = BUN_NONE;
        for (i = 0, j = alt * nthreads - alt; i <= j; j--) {
                l = c_Thread_arg[j].pos_r;
		if (l == last_vector_pos + 1 || (l <= last_vector_pos && src_t[l] @8 pivot && (l == first || src_t[l - 1] @7 pivot)))
		{
                        if (f == BUN_NONE) {
                                f = l;
                        } 
			/*else {
                                assert(f == l);
                        }*/
                }
        }

	if(remaining_elements > 0)
	{
		BUN qualifying_elements = 0;
		BUN lowerCursor = last_vector_pos + 1, upperCursor = last;
		oid *tmp_head = GDKmalloc(remaining_elements * sizeof(oid));
		@1 *tmp_tail = GDKmalloc(remaining_elements * sizeof(@1 ));
		assert (tmp_head && tmp_tail);

	        if (f == BUN_NONE) /*if there are not qualifying tuples*/
	        {
        	        f = first;
        	}

		while (lowerCursor < upperCursor)
		{
			while (lowerCursor < upperCursor && src_t[lowerCursor] @7 pivot)
			{
				lowerCursor++;
				qualifying_elements++;
			}

			while (lowerCursor < upperCursor && src_t[upperCursor] @8 pivot)
				upperCursor--;
			
			if (lowerCursor < upperCursor) {
				@1 tmp = src_t[lowerCursor];
				oid tmp_oid = src_h[lowerCursor];
				src_t[lowerCursor] = src_t[upperCursor];
				src_h[lowerCursor] = src_h[upperCursor];
				src_t[upperCursor] = tmp;
				src_h[upperCursor] = tmp_oid;
				lowerCursor++;
				upperCursor--;
				qualifying_elements++;
			} 
		}
		if (lowerCursor == upperCursor && src_t[lowerCursor] @7 pivot)
			qualifying_elements += 1;

		if (qualifying_elements > 0)
		{
			if(qualifying_elements <= (last_vector_pos - f + 1))
			{
				memcpy(tmp_head, src_h + f, sizeof(oid)*qualifying_elements);
				memcpy(src_h +  f, src_h + last_vector_pos + 1, sizeof(oid)*qualifying_elements);
				memcpy(src_h + last_vector_pos + 1, tmp_head, sizeof(oid)*qualifying_elements);
				memcpy(tmp_tail, src_t + f, sizeof(@1)*qualifying_elements);
				memcpy(src_t + f, src_t + last_vector_pos + 1, sizeof(@1)*qualifying_elements);
				memcpy(src_t + last_vector_pos + 1, tmp_tail, sizeof(@1)*qualifying_elements);
			}
			else
			{
				BUN copied_elements = last_vector_pos - f + 1;
				memcpy(tmp_head, src_h + f, sizeof(oid)*copied_elements);
				memcpy(src_h +  f, src_h + last_vector_pos + 1 + qualifying_elements - copied_elements, sizeof(oid)*copied_elements);
				memcpy(src_h + last_vector_pos + 1 + qualifying_elements - copied_elements, tmp_head, sizeof(oid)*copied_elements);
				memcpy(tmp_tail, src_t + f, sizeof(@1)*copied_elements);
				memcpy(src_t + f, src_t + last_vector_pos + 1 + qualifying_elements - copied_elements, sizeof(@1)*copied_elements);
				memcpy(src_t + last_vector_pos + 1 + qualifying_elements - copied_elements, tmp_tail, sizeof(@1)*copied_elements);
			}			
		}
		f += qualifying_elements;
		GDKfree(tmp_head);
		GDKfree(tmp_tail);
	}

        assert(f != BUN_NONE);
	assert((f == last + 1 && src_t[f-1] @7 pivot) || src_t[f]   @8 pivot);
	assert((f == first    && src_t[f]   @8 pivot) || src_t[f-1] @7 pivot);

        *pos = (BUN) (f == 0 ? 0 : f - 1);

	GDKfree(tmp_h);
	GDKfree(tmp_t);
	GDKfree(c_Thread);
	GDKfree(c_Thread_arg);
	return MAL_SUCCEED;
}

/* crack implementation dispatcher */
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, BUN first, BUN last, oid *pos, int nthreads, int vector_elements){
	str msg = MAL_SUCCEED;
	int selectivity = 50;

	assert(b);
	assert(last >= first);
	assert(pos);

	if (nthreads == int_nil && vector_elements == int_nil) {
		/* original single-threaded crack code */
		msg = CRKcrackUnorderedZero_@2_@1_ST(b, mval, first, last, pos);
	} else
	if (nthreads != int_nil && vector_elements == int_nil)
	{
		if (nthreads == 0) {
			/* revised single-threaded crack code */
			msg = CRKcrackUnorderedZero_@2_@1_STx(b, mval, first, last, 0, pos);
		} else
		if (nthreads < 0) {
			/* new multi-threaded crack code; Alternative 1 */
			msg = CRKcrackUnorderedZero_@2_@1_MT(b, mval, first, last, pos, -nthreads, 1);
		} else
		if (nthreads > 0) {
			/* new multi-threaded crack code; Alternative 2 */
			msg = CRKcrackUnorderedZero_@2_@1_MT(b, mval, first, last, pos, nthreads, 2);
		} 
	}
	else
	if (nthreads != int_nil && vector_elements != int_nil)
	{
		if (nthreads == 0) {
			/* revised single-threaded crack code */
			msg = CRKcrackUnorderedZero_@2_@1_STx(b, mval, first, last, 0, pos);
		} else
		if (nthreads < 0) {
			/* new multi-threaded crack code; Alternative 1 */
			msg = CRKvectorized_MT_@2_@1(b, first, last, mval, pos, -nthreads, 1, selectivity, vector_elements);
		} else
		if (nthreads > 0) {
			/* new multi-threaded crack code; Alternative 2 */
			msg = CRKvectorized_MT_@2_@1(b, first, last, mval, pos, nthreads, 2, selectivity, vector_elements);
		} 

	}
	else {
		throw(MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1(): Illegal combination of threads and vector_elements: %d", nthreads);
	}

	return msg;
}

@
@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}


str
CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc){

        @1  *ft, *lt, *tmax, *t0;
	oid fh, lh, hmax; /*hold actual  oid values in this version*/
	BUN firstBUN;

        @1  *ft2, *lt2, *tmax2; 
	oid *fh2, *lh2, *hmax2;
	BUN firstBUN2;

        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = first;
        hmax = last;

	firstBUN2 = BUNfirst(bc);
        ft2   = (@1*)Tloc(bc, firstBUN2 + first);
        tmax2 = (@1 *)Tloc(bc, firstBUN2 + last);
        fh2   = (oid*)Hloc(bc, firstBUN2 + first);
        hmax2 = (oid*)Hloc(bc, firstBUN2 + last);
	
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
		*tmax2=*tmax;
		*hmax2=hmax;
                tmax--;hmax--;
                tmax2--;hmax2--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt  = tmax;  lh  = hmax;
        lt2 = tmax2; lh2 = hmax2;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
                        tmax--;hmax--;
                        tmax2--;hmax2--;
                }else{
			*lt2=*lt;
			*lh2=lh;
		}	
                lt--; lh--;
                lt2--;lh2--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
	*ft2=*ft;
	*fh2=fh;
        while(ft<=lt) {
                if (@8_@4(ft2, &low,@9@1)){
                        ft++; fh++;
                        ft2++;fh2++;
			if(ft<=lt){
				*ft2=*ft;
				*fh2=fh;
			}
		}
                else {
			*lt2=*ft2;
			*lh2=*fh2;
			*ft2=*lt;
			*fh2=lh;
                        if(@8_@5(lt2, &low,@9@1) && lt>ft){
                                if(@8_@7(lt2, &hgh,@9@1) ){
					@:shuffle(@1,lt2,tmax2,lh2,hmax2)@
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
					*lt2=*tmax2;
					*lh2=*hmax2;
					*tmax2=*lt;
					*hmax2=lh;
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }else{
					*lt2=*lt;
					*lh2=lh;
				}
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(bc, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

@
 * @- Local support functions and macros
@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@
@= shuffle2
        *@7 = *@2;
        *@6 = *@3;

        *@9 = @4;
        *@8 = @5;
@
@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = (@2)tdummy;
@= shuffleSidewaysStr
	hdummy = *(@1*) @2;
	*(@1*) @2= *(@1*) @3;
        *(@1*) @3= hdummy;

	switch (b->T->width) {
	case 1:
		tdummy= (var_t)*(unsigned char*) @4;
		*(unsigned char*) @4= *(unsigned char*) @5;
		*(unsigned char*) @5 = (unsigned char)tdummy;
		break;
	case 2:
		tdummy= (var_t)*(unsigned short*) @4;
		*(unsigned short*) @4= *(unsigned short*) @5;
		*(unsigned short*) @5 = (unsigned short)tdummy;
		break;
#if SIZEOF_VAR_T == 8
	case 4:
		tdummy= (var_t)*(unsigned int*) @4;
		*(unsigned int*) @4= *(unsigned int*) @5;
		*(unsigned int*) @5 = (unsigned int)tdummy;
		break;
#endif
	default:
		tdummy= *(var_t*) @4;
		*(var_t*) @4= *(var_t*) @5;
		*(var_t*) @5 = tdummy;
		break;
	}
@

@= printVarTypes
{
/* @1: the type; e.g., bte sht int oid wrd flt dbl lng str */
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s \n", MyBuf);
	GDKfree(MyBuf);
}
@
@= crackInTwoUnorderedPiecesSideways_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        @2 *vmt, *vlt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (@2*)Tloc(b, firstBUN+first);
        vlt = (@2*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@
@= crackInThreeUnorderedPiecesSideways_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        @2 *vmt, *vlt, *hmaxt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (@2*)Tloc(b, firstBUN+first);
        hmaxt = (@2*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt--;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
                }
                vl--; vlt--;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt ++;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt--;
                                }
                                vl --; vlt --;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = (oid)-1;
		*posh = (oid)-1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@
@= crackInTwoUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        char *vmt, *vlt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (char*)Tloc(b, firstBUN+first);
        vlt = (char*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt += b->T->width;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt -= b->T->width;
			}
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        vl  --;
			vlt -= b->T->width;
                        vm  ++;
			vmt += b->T->width;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@
@= crackInThreeUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        char *vmt, *vlt, *hmaxt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (char*)Tloc(b, firstBUN+first);
        hmaxt = (char*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt-=b->T->width;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt-=b->T->width;
                }
                vl--; vlt-=b->T->width;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt += b->T->width;
                } else {
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt-=b->T->width;
                                }
                                vl --; vlt -= b->T->width;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = 0;/*-1;*/
		*posh = 0;/*-1;*/
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@
