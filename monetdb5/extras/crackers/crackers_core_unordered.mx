@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f crackers_core_unordered

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Core Cracking (unordered)
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(bte,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@
@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(lng,,simple,,lng,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@
@= TypeSwitch_4
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,lng,simple,,,@2)@
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(lng,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@
@:@1(lng,lng,simple,,,@2)@
@:@1(lng,int,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@
@= TypeSwitch_5
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(lng,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
@:TypeSwitch_4(operationsSideways,_decl)@
@:TypeSwitch_2(operationsSideways_str,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
/*
 * @- Exported signatures
 */
@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid, int nthreads);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@
 * @- Signatures shared within the crackers module/library
@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3,<=,>)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3,<,>=)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@
@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos, int nthreads);
@
@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc);
@
@= operationsSideways
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@
@= operationsSideways_str
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RO,LT,GE,LT,GE,@3,@4)@
@
@= crackInTwoUnorderedPiecesSideways_decl
str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, oid first, oid last, oid *pos);
@
@= crackInTwoUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, oid first, oid last, oid *pos);
@
@= crackInThreeUnorderedPiecesSideways_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@
@= crackInThreeUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

#define CRACK_MUTLI_THREAD_DEBUG

/* argument struct for countThread & crackThread functions */
typedef struct {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	int id;            /* thread id */
 #endif
	BUN n;             /* # tuples / values per piece / thread */
	BUN *cnt_off;      /* counts/offsets pair:
	                      [0] = first piece / smaller values
	                      [1] = second piece / larger values */
	const void *mval;  /* pivot value */
	const void *src_t; /* input / source tail */
	const oid *src_h;  /* input / source head */
	void *dst_t;       /* output / destination tail */
	oid *dst_h;        /* output / destination head */
} c_Thread_t;

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@
@:TypeSwitch_4(operationsSideways,_impl)@
@:TypeSwitch_2(operationsSideways_str,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
/*
 * @- Exported functions
 */
@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid, int nthreads){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
       /* if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(BUN) 0, BATcount(b)-1, &pos, nthreads);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@
 * @- Functions shared within the crackers module/library
@= crackInTwoUnorderedPieces_impl


/* original single-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_ST( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1  *ft, *lt, *t0;
	oid *fh, *lh;
        oid hdummy;
        @1 tdummy;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
        lng t_0, t_1;
	
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_ST ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, last);
	t_0 = GDKusec();
 #endif

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        fh = (oid*)Hloc(b, BUNfirst(b) + first);
        lh = (oid*)Hloc(b, BUNfirst(b) + last);

        while(ft<lt) {
                if (@5_@3(ft, &mval,@6@1)){
                        ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@
                        lt--;lh--;
                        ft++;fh++;
                }
        }

	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = (oid) BUNfirst(b);
			else	
				*pos = (oid) (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = (oid) (lt - t0); 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = (oid) (lt - t0);
		else
			*pos = (oid) BUNfirst(b);
	}		

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_ST ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) -> "OIDFMT" : %.6f secs\n",
		b->batCacheid, (lng) mval, first, last, *pos, (dbl) (t_1 - t_0) / 1000000.0);
 #endif
		
        return MAL_SUCCEED;
}


/* revised single-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_STx ( const BAT *b, const @1 mval, const BUN first, const BUN last, oid *pos )
{
	BUN p = 0, q = last - first;
	oid *src_h;
	@1  *src_t;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STx ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) ...\n",
		b->batCacheid, (lng) mval, first, last);
	t_0 = GDKusec();
 #endif

	/* input (source) arrays */
	src_h = (oid*) Hloc(b, BUNfirst(b) + first);
	src_t = (@1 *) Tloc(b, BUNfirst(b) + first);

	while (p < q) {
		/* skip over smaller values from beginning */
		while (p < q && src_t[p] @7 mval /*@5_@3(&src_t[p], &mval, @6@1)*/)
			p++;
		/* skip over larger values from end */
		while (p < q && src_t[q] @8 mval /*@5_@4(&src_t[q], &mval, @6@1)*/)
			q--;
		if (p < q) {
			/* swap values */
			const oid h = src_h[p];
			const @1  t = src_t[p];
			src_h[p] = src_h[q];
			src_t[p] = src_t[q];
			src_h[q] = h;
			src_t[q] = t;
			p++;
			q--;
		}
	}

	/* return pivot position */
	q = last - first;
	while (p <= q && src_t[p] @7 mval /*@5_@3(&src_t[p], &mval, @6@1)*/)
		p++;
	*pos = (oid) (first + p - 1);

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_STx ( %d, "LLFMT", "BUNFMT", "BUNFMT" ) -> "OIDFMT" : %.6f secs\n",
		b->batCacheid, (lng) mval, first, last, *pos, (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	return MAL_SUCCEED;
}


/* countThread for new multi-threaded crack code */
static void*
CRKcrackUnorderedZero_@2_@1_MT_countThread ( void *arg_p )
{
	c_Thread_t *arg = (c_Thread_t*) arg_p;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	const int id = arg->id;                   /* thread id */
 #endif
	const BUN n = arg->n;                     /* # tuples / values per piece / thread */
	BUN *cnt = arg->cnt_off;                  /* counts/offsets pair:
	                                             [0] = first piece / smaller values
	                                             [1] = second piece / larger values */
	const @1 mval = * (@1*) arg->mval;        /* pivot value */
	const @1 *src_t = (const @1*) arg->src_t; /* input / source tail */
	BUN i;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_countThread ( %d, "LLFMT", "BUNFMT" ) ...\n",
		id, (lng) mval, n);
	t_0 = GDKusec();
 #endif

	/* count smaller / larger values */
	for (i = 0; i < n; i++) {
		/* [0] = first piece / smaller values */
		/* [1] = second piece / larger values */
		cnt[src_t[i] @8 mval /*@5_@4(&src_t[i], &mval, @6@1)*/]++;
	}

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_countThread ( %d, "LLFMT", "BUNFMT" ) -> "BUNFMT", "BUNFMT" : %.6f s\n",
		id, (lng) mval, n, cnt[0], cnt[1], (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	pthread_exit(NULL);
	return NULL;
}


/* crackThread for new multi-threaded crack code */
static void*
CRKcrackUnorderedZero_@2_@1_MT_crackThread ( void *arg_p )
{
	c_Thread_t *arg = (c_Thread_t*) arg_p;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	const int id = arg->id;             /* thread id */
 #endif
	const BUN n = arg->n;               /* # tuples / values per piece / thread */
	BUN *off = arg->cnt_off;            /* counts/offsets pair:
	                                       [0] = first piece / smaller values
	                                       [1] = second piece / larger values */
	const @1 mval = * (@1*) arg->mval;  /* pivot value */
	const @1 *src_t = (@1*) arg->src_t; /* input / source tail */
	const oid *src_h = arg->src_h;      /* input / source head */
	@1 *dst_t = (@1*) arg->dst_t;       /* output / destination tail */
	oid *dst_h = arg->dst_h;            /* output / destination head */
	BUN i;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_crackThread ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) ...\n",
		id, (lng) mval, n, off[0], off[1]);
	t_0 = GDKusec();
 #endif

	/* crack into temp. arrays */
	for (i = 0; i < n; i++) {
		const bit x = src_t[i] @8 mval /*@5_@4(&src_t[i], &mval, @6@1)*/;
		dst_h[off[x]] = src_h[i];
		dst_t[off[x]] = src_t[i];
		off[x]++;
	}

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT_crackThread ( %d, "LLFMT", "BUNFMT", "BUNFMT", "BUNFMT" ) : %.6f s\n",
		id, (lng) mval, n, off[0], off[1], (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	pthread_exit(NULL);
	return NULL;
}


/* new multi-threaded crack code */
static str
CRKcrackUnorderedZero_@2_@1_MT ( const BAT *b, const @1 mval, const BUN first, const BUN last, oid *pos, int nthreads )
{
	const BUN n = last - first + 1; /* total # tuples / values */
	BUN m;                          /* # tuples / values per piece / thread */
	BUN l;                          /* total # smaller values */
	BUN *cnt, *off;                 /* counts/offsets pair:
	                                   [0] = first piece / smaller values
	                                   [1] = second piece / larger values */
	oid *src_h, *dst_h;             /* head of input (source) & output (destination) */
	@1  *src_t, *dst_t;             /* tail of input (source) & output (destination) */
	pthread_t *c_Thread;            /* threads array */
	c_Thread_t *c_Thread_arg;       /* thread arguments array */
	int i, j;
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	lng t_0, t_1, t_2;

	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d ) ...\n",
		b->batCacheid, (lng) mval, first, last, nthreads);
	t_0 = GDKusec();
 #endif

	/* adjust nthreads */
	if (nthreads == 0) {
		/* automatic setting */
		nthreads = GDKnr_threads;
	}
	if ((BUN) nthreads > n / 1000) {
		/* more threads / smaller pieces does not make sense */
		nthreads = (int) (n / 1000) + 1;
	}

	/* input (source) arrays */
	src_h = (oid*) Hloc(b, BUNfirst(b) + first);
	src_t = (@1 *) Tloc(b, BUNfirst(b) + first);

	/* allocate temporary data structures */
	cnt = GDKzalloc(nthreads * 2 * sizeof(BUN));
	off = GDKzalloc(nthreads * 2 * sizeof(BUN));
	dst_h = GDKmalloc(n * sizeof(oid));
	dst_t = GDKmalloc(n * sizeof(@1 ));
	c_Thread = GDKmalloc (nthreads * sizeof(pthread_t));
	c_Thread_arg  = GDKzalloc(nthreads * sizeof(c_Thread_t));
	if (!cnt || !off || !dst_h || !dst_t || !c_Thread || !c_Thread_arg) {
		if (cnt)
			GDKfree(cnt);
		if (off)
			GDKfree(off);
		if (dst_h)
			GDKfree(dst_h);
		if (dst_t)
			GDKfree(dst_t);
		if (c_Thread)
			GDKfree(c_Thread);
		if (c_Thread_arg)
			GDKfree(c_Thread_arg);
		throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): GDKmalloc() failed.");
	}

	/* initilize countThread arguments */
	m = n / nthreads;
	for (i = 0, j = 0; i < nthreads; i++, j += 2) {
 #ifdef CRACK_MUTLI_THREAD_DEBUG
		c_Thread_arg[i].id      = i;
 #endif
		c_Thread_arg[i].n       = m;
		c_Thread_arg[i].cnt_off = &cnt[j];
		c_Thread_arg[i].mval    = &mval;
		c_Thread_arg[i].src_t   = &src_t[i * m];
		/* other arguments not needed for countThread */
	}
	c_Thread_arg[nthreads - 1].n = n - (nthreads - 1) * m;

	/* count smaller / larger values */
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_2 = GDKusec();
 #endif
	for (i = 0; i < nthreads; i++) {
		if (pthread_create(&c_Thread[i], NULL, CRKcrackUnorderedZero_@2_@1_MT_countThread, &c_Thread_arg[i])) {
			GDKfree(cnt);
			GDKfree(off);
			GDKfree(dst_h);
			GDKfree(dst_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed creating countThread %d.", i);
		}
	}
	for (i = 0; i < nthreads; i++) {
		if (pthread_join(c_Thread[i], NULL)) {
			GDKfree(cnt);
			GDKfree(off);
			GDKfree(dst_h);
			GDKfree(dst_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed joining countThread %d.", i);
		 }
	}
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d ) count : %.6f sec\n",
		b->batCacheid, (lng) mval, first, last, nthreads, (dbl) (t_1 - t_2) / 1000000.0);
 #endif

	/* turn local counts into global offsets */
	l = 0;
	for (j = 0, i = nthreads * 2; j < i; j += 2)
		l += cnt[j];
	off[0] = 0;
	off[1] = l;
	for (j = 2, i = nthreads * 2; j < i; j += 2) {
		off[j] = off[j - 2] + cnt[j - 2];
		off[j + 1] = off[j - 1] + cnt[j - 1];
	}

	/* initilize crackThread arguments */
	for (i = 0, j = 0; i < nthreads; i++, j += 2) {
		c_Thread_arg[i].cnt_off = &off[j];
		c_Thread_arg[i].src_h   = &src_h[i * m];
		c_Thread_arg[i].dst_h   = dst_h;
		c_Thread_arg[i].dst_t   = dst_t;
		/* other arguments already set for countThread */
	}

	/* crack into temp. arrays */
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_2 = GDKusec();
 #endif
	for (i = 0; i < nthreads; i++) {
		if (pthread_create(&c_Thread[i], NULL, CRKcrackUnorderedZero_@2_@1_MT_crackThread, &c_Thread_arg[i])) {
			GDKfree(cnt);
			GDKfree(off);
			GDKfree(dst_h);
			GDKfree(dst_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed creating crackThread %d.", i);
		}
	}
	for (i = 0; i < nthreads; i++) {
		if (pthread_join(c_Thread[i], NULL)) {
			GDKfree(cnt);
			GDKfree(off);
			GDKfree(dst_h);
			GDKfree(dst_t);
			GDKfree(c_Thread);
			GDKfree(c_Thread_arg);
			throw (MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1_MT(): Failed joining crackThread %d.", i);
		 }
	}
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d ) crack : %.6f sec\n",
		b->batCacheid, (lng) mval, first, last, nthreads, (dbl) (t_1 - t_2) / 1000000.0);
 #endif

	/* restore into BAT */
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_2 = GDKusec();
 #endif
	memcpy(src_h, dst_h, n * sizeof(oid));
	memcpy(src_t, dst_t, n * sizeof(@1 ));
 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d ) restore : %.6f sec\n",
		b->batCacheid, (lng) mval, first, last, nthreads, (dbl) (t_1 - t_2) / 1000000.0);
 #endif

	*pos = (oid) (first + l - 1);

	GDKfree(cnt);
	GDKfree(off);
	GDKfree(dst_h);
	GDKfree(dst_t);
	GDKfree(c_Thread);
	GDKfree(c_Thread_arg);

 #ifdef CRACK_MUTLI_THREAD_DEBUG
	t_1 = GDKusec();
	fprintf(stderr,
		"CRKcrackUnorderedZero_@2_@1_MT ( %d, "LLFMT", "BUNFMT", "BUNFMT", %d ) -> "OIDFMT" : %.6f secs\n",
		b->batCacheid, (lng) mval, first, last, nthreads, *pos, (dbl) (t_1 - t_0) / 1000000.0);
 #endif

	return MAL_SUCCEED;
}


/* crack implementation dispatcher */
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, BUN first, BUN last, oid *pos, int nthreads){
	assert(b);
	assert(last >= first);
	assert(pos);

	if (nthreads == int_nil) {
		/* original single-threaded crack code */
		return CRKcrackUnorderedZero_@2_@1_ST(b, mval, first, last, pos);
	} else
	if (nthreads == -1) {
		/* revised single-threaded crack code */
		return CRKcrackUnorderedZero_@2_@1_STx(b, mval, first, last, pos);
	} else
	if (nthreads >= 0) {
		/* new multi-threaded crack code */
		return CRKcrackUnorderedZero_@2_@1_MT(b, mval, first, last, pos, nthreads);
	} else {
		throw(MAL, "crackers.select", "CRKcrackUnorderedZero_@2_@1(): Illegal number of threads: %d", nthreads);
	}
}


@
@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}


str
CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc){

        @1  *ft, *lt, *tmax, *t0;
	oid fh, lh, hmax; /*hold actual  oid values in this version*/
	BUN firstBUN;

        @1  *ft2, *lt2, *tmax2; 
	oid *fh2, *lh2, *hmax2;
	BUN firstBUN2;

        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = first;
        hmax = last;

	firstBUN2 = BUNfirst(bc);
        ft2   = (@1*)Tloc(bc, firstBUN2 + first);
        tmax2 = (@1 *)Tloc(bc, firstBUN2 + last);
        fh2   = (oid*)Hloc(bc, firstBUN2 + first);
        hmax2 = (oid*)Hloc(bc, firstBUN2 + last);
	
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
		*tmax2=*tmax;
		*hmax2=hmax;
                tmax--;hmax--;
                tmax2--;hmax2--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt  = tmax;  lh  = hmax;
        lt2 = tmax2; lh2 = hmax2;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
                        tmax--;hmax--;
                        tmax2--;hmax2--;
                }else{
			*lt2=*lt;
			*lh2=lh;
		}	
                lt--; lh--;
                lt2--;lh2--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
	*ft2=*ft;
	*fh2=fh;
        while(ft<=lt) {
                if (@8_@4(ft2, &low,@9@1)){
                        ft++; fh++;
                        ft2++;fh2++;
			if(ft<=lt){
				*ft2=*ft;
				*fh2=fh;
			}
		}
                else {
			*lt2=*ft2;
			*lh2=*fh2;
			*ft2=*lt;
			*fh2=lh;
                        if(@8_@5(lt2, &low,@9@1) && lt>ft){
                                if(@8_@7(lt2, &hgh,@9@1) ){
					@:shuffle(@1,lt2,tmax2,lh2,hmax2)@
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
					*lt2=*tmax2;
					*lh2=*hmax2;
					*tmax2=*lt;
					*hmax2=lh;
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }else{
					*lt2=*lt;
					*lh2=lh;
				}
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(bc, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

@
 * @- Local support functions and macros
@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@
@= shuffle2
        *@7 = *@2;
        *@6 = *@3;

        *@9 = @4;
        *@8 = @5;
@
@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = (@2)tdummy;
@= shuffleSidewaysStr
	hdummy = *(@1*) @2;
	*(@1*) @2= *(@1*) @3;
        *(@1*) @3= hdummy;

	switch (b->T->width) {
	case 1:
		tdummy= (var_t)*(unsigned char*) @4;
		*(unsigned char*) @4= *(unsigned char*) @5;
		*(unsigned char*) @5 = (unsigned char)tdummy;
		break;
	case 2:
		tdummy= (var_t)*(unsigned short*) @4;
		*(unsigned short*) @4= *(unsigned short*) @5;
		*(unsigned short*) @5 = (unsigned short)tdummy;
		break;
#if SIZEOF_VAR_T == 8
	case 4:
		tdummy= (var_t)*(unsigned int*) @4;
		*(unsigned int*) @4= *(unsigned int*) @5;
		*(unsigned int*) @5 = (unsigned int)tdummy;
		break;
#endif
	default:
		tdummy= *(var_t*) @4;
		*(var_t*) @4= *(var_t*) @5;
		*(var_t*) @5 = tdummy;
		break;
	}
@

@= printVarTypes
{
/* @1: the type; e.g., bte sht int oid wrd flt dbl lng str */
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s \n", MyBuf);
	GDKfree(MyBuf);
}
@
@= crackInTwoUnorderedPiecesSideways_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        @2 *vmt, *vlt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (@2*)Tloc(b, firstBUN+first);
        vlt = (@2*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@
@= crackInThreeUnorderedPiecesSideways_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        @2 *vmt, *vlt, *hmaxt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (@2*)Tloc(b, firstBUN+first);
        hmaxt = (@2*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt--;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
                }
                vl--; vlt--;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt ++;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt--;
                                }
                                vl --; vlt --;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = (oid)-1;
		*posh = (oid)-1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@
@= crackInTwoUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        char *vmt, *vlt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (char*)Tloc(b, firstBUN+first);
        vlt = (char*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt += b->T->width;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt -= b->T->width;
			}
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        vl  --;
			vlt -= b->T->width;
                        vm  ++;
			vmt += b->T->width;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@
@= crackInThreeUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        char *vmt, *vlt, *hmaxt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (char*)Tloc(b, firstBUN+first);
        hmaxt = (char*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt-=b->T->width;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt-=b->T->width;
                }
                vl--; vlt-=b->T->width;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt += b->T->width;
                } else {
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt-=b->T->width;
                                }
                                vl --; vlt -= b->T->width;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = 0;/*-1;*/
		*posh = 0;/*-1;*/
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@
