@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f crackers_multicore_unordered

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* MultiCore Cracking (unordered)
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(int,simple,,@2)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_MULTICORE_UNORDERED_H_
#define _CRACKERS_MULTICORE_UNORDERED_H_

#ifdef LIBCRACKERS

typedef struct {
        BAT *array;
        int *temp_array;
	oid *temp_array_oid;
        int *data_less;
        int *data_greater;
        oid left;
        oid right;
        int tid;
        int pivot;
} thread_data_t;

typedef struct {
        BAT *array;
        int *temp_array;
	oid *temp_array_oid;
        int *data_less;
        int *data_greater;
        int nthreads; /*number of threads*/
        int n; /*number of array elements*/
        oid left;
        oid right;
        int tid;
        int pivot;
} thread_data_new_t;

typedef struct {
        BAT *array;
        int *temp_array;
        oid *temp_array_oid;
        int nthreads; /*number of threads*/
        oid first;
        oid last;
	int tempfirst;
	int templast;
        int tid;
} thread_data_restore_t;

/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(MultiCoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_MULTICORE_UNORDERED_H */
/*
 * @- Exported signatures
 */
@= MultiCoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedThreeParallel_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@
 * @- Signatures shared within the crackers module/library
@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@
@= crackInTwoUnorderedPieces_decl
str CRKscanUnorderedZeroParallel_@2_@1( BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads, int *data_less, int *data_greater);
str CRKreorganizeUnorderedZeroParallel_@2_@1( BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads, int *data_less, int *data_greater);
str CRKrestoreUnorderedZeroParallel_@2_@1( BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads, int *data_less, int *data_greater, oid *pos);
void *threadFuncScan_@2_@1(void *arg);
void *threadFuncReorganize_@2_@1(void *arg);
void *threadFuncRestore_@2_@1(void *arg);
@
@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThreeParallel_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThreeCopyParallel_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc);
@

@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@

/* Exported functions */
@:TypeSwitch(MultiCoreUnorderedFunctions_impl,)@
/*
 * @- Exported functions
 */
@= MultiCoreUnorderedFunctions_impl
str
CRKcrackUnorderedThreeParallel_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThreeParallel_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@
 * @- Functions shared within the crackers module/library
@= crackInTwoUnorderedPieces_impl
str
CRKscanUnorderedZeroParallel_@2_@1(BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads, int *data_less, int *data_greater)
{
	int i;
	oid partition_elements;
        thread_data_t *data;

        pthread_t **thread = (pthread_t **) GDKmalloc (sizeof(pthread_t *) * nthreads);
        for (i = 0; i < nthreads; i++)
                thread[i] = (pthread_t *) GDKmalloc (sizeof(pthread_t));

        data = GDKmalloc (nthreads * sizeof(thread_data_t));


        partition_elements=(last-first+1)/nthreads;
        for (i = 0; i < nthreads; i++) {
		data[i].array = b;
                data[i].temp_array = temp_array;
		data[i].temp_array_oid = temp_array_oid;
                data[i].data_less = data_less;
                data[i].data_greater = data_greater;
                data[i].left = first + i*partition_elements;
                data[i].pivot = mval;
                if(i==(nthreads-1))
                        data[i].right = last;
                else
                        data[i].right = first + (i*partition_elements)+partition_elements-1;

                data[i].tid = i;

                if (pthread_create (thread[i], NULL, threadFuncScan_@2_@1, &data[i]))
                {
                        printf("Failed to create thread %d.\n",i);
                        exit (-1);
                }
        }
        // Wait for threads
        for (i = 0; i < nthreads; i++) {
                if (pthread_join(*thread[i], NULL)) {
                        printf ("Error joining thread %d.\n", i);
                        exit (-1);
                 }
        }

        /* Clean up. */
        for (i = 0; i < nthreads; i++)
                GDKfree(thread[i]);

        GDKfree(thread);

	return MAL_SUCCEED;
}
str 
CRKreorganizeUnorderedZeroParallel_@2_@1(BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads,int *data_less, int* data_greater) {

	int i;
	oid partition_elements;
	thread_data_new_t *data;

    	pthread_t **thread = (pthread_t **) GDKmalloc (sizeof(pthread_t *) * nthreads);

	/* Allocate memory for the pthread_ts. */
 	for (i = 0; i < nthreads; i++) 
    		thread[i] = (pthread_t *) GDKmalloc (sizeof(pthread_t));
	
	/* Allocate memory for thread data. */
    	data = GDKmalloc (nthreads * sizeof(thread_data_new_t));

	/* Now create the threads. */
  	partition_elements=(last-first+1)/nthreads;
        //printf("Each partition consists of %d elements (almost).\n",partition_elements);	
	for (i = 0; i < nthreads; i++) {

	    	data[i].array = b;
		data[i].temp_array = temp_array; 
		data[i].temp_array_oid = temp_array_oid;
		data[i].data_less = data_less;
		data[i].data_greater = data_greater;  	
		data[i].n = last-first+1;
		data[i].nthreads = nthreads; 
		data[i].left = first + i*partition_elements;
                data[i].pivot = mval;
                if(i==(nthreads-1))
                        data[i].right = last;
                else
                        data[i].right = first + (i*partition_elements)+partition_elements-1;

                data[i].tid = i;

		if (pthread_create (thread[i], NULL, threadFuncReorganize_@2_@1, &data[i]))
		{
            		printf("Failed to create thread %d.\n",i);
    			exit (-1);
		}
	}
    	// Wait for threads
	for (i = 0; i < nthreads; i++) {
    		if (pthread_join(*thread[i], NULL)) {
      			printf ("Error joining thread %d.\n", i);
      			exit (-1);
   		 }
  	}

	/* Clean up. */
  	for (i = 0; i < nthreads; i++)
    		GDKfree(thread[i]);
  	
  	GDKfree(thread);
	return MAL_SUCCEED;
}

str
CRKrestoreUnorderedZeroParallel_@2_@1(BAT *b, @1 *temp_array, oid *temp_array_oid, @1 mval, oid first, oid last, int nthreads,int *data_less, int *data_greater,oid *pos) {

        int i;
	@1 *lt, *t0;
        oid partition_elements, position=0;
        thread_data_restore_t *data;

        pthread_t **thread = (pthread_t **) GDKmalloc (sizeof(pthread_t *) * nthreads);

	(void) data_greater;

        /* Allocate memory for the pthread_ts. */
        for (i = 0; i < nthreads; i++)
                thread[i] = (pthread_t *) GDKmalloc (sizeof(pthread_t));

        /* Allocate memory for thread data. */
        data = GDKmalloc (nthreads * sizeof(thread_data_restore_t));

        /* Now create the threads. */
        partition_elements=(last-first+1)/nthreads;
        //printf("Each partition consists of %d elements (almost).\n",partition_elements);
        for (i = 0; i < nthreads; i++) {

                data[i].array = b;
                data[i].temp_array = temp_array;
                data[i].temp_array_oid = temp_array_oid;
                data[i].nthreads = nthreads;
                data[i].first = first + i*partition_elements;
		data[i].tempfirst = i*partition_elements;
                if(i==(nthreads-1))
		{
                        data[i].last = last;
                	data[i].templast = partition_elements-1;
		}
		else
		{
                        data[i].last = first + (i*partition_elements)+partition_elements-1;
			data[i].templast = (i*partition_elements)+partition_elements-1;
		}
                data[i].tid = i;
		if (pthread_create (thread[i], NULL, threadFuncRestore_@2_@1, &data[i]))
                {
                        printf("Failed to create thread %d.\n",i);
                        exit (-1);
                }
        }
        // Wait for threads
        for (i = 0; i < nthreads; i++) {
                if (pthread_join(*thread[i], NULL)) {
                        printf ("Error joining thread %d.\n", i);
                        exit (-1);
                 }
        }

        /* Clean up. */
        for (i = 0; i < nthreads; i++)
                GDKfree(thread[i]);

        GDKfree(thread);

	for (i = 0; i < nthreads; i++)
                position=position+data_less[i];

	t0 = (@1 *)Tloc(b, BUNfirst(b));
	lt = (@1 *)Tloc(b, BUNfirst(b) + first + position-1);

	if (@5_@4(lt, &mval,@6@1)){
        	if (lt==t0)
                	*pos = (oid) BUNfirst(b);
                else
                	*pos = (oid) (lt - t0) - 1; /*works for empty left piece also*/
        }
        else{
                *pos = (oid) (lt - t0);
                if (*pos==last) /*empty right piece*/
 	               *pos = *pos + 1;
       }

        return MAL_SUCCEED;
}


void
*threadFuncScan_@2_@1(void *arg) {
        
	thread_data_t *my_data = (thread_data_t *) arg;
	@1  *ft;
        oid *fh, *lh;

        /* set bounds for the iterator */
        ft = (@1 *)Tloc(my_data->array, BUNfirst(my_data->array) + my_data->left);
        fh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->left);
        lh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->right);

        while(fh<=lh) {
                if (@5_@3(ft, &my_data->pivot,@6@1)){
			my_data->data_less[my_data->tid]++;
                }
                else {
			my_data->data_greater[my_data->tid]++;
                }
		ft++; fh++;
        }
        
        pthread_exit(NULL);
}

void *threadFuncReorganize_@2_@1(void *arg) {
	int i;
	int positionLess=0;
	thread_data_new_t *my_data = (thread_data_new_t *) arg;
        int positionGreater=my_data->n;
	@1  *ft;
        oid *fh, *lh;

        /* set bounds for the iterator */
        ft = (@1 *)Tloc(my_data->array, BUNfirst(my_data->array) + my_data->left);
        fh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->left);
        lh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->right);


	for(i=0; i < my_data->nthreads && i < my_data->tid; i++)
		positionLess=positionLess+my_data->data_less[i];
	for(i=0; i < my_data->nthreads && i <= my_data->tid; i++)
		positionGreater=positionGreater - my_data->data_greater[i];

	while(fh<=lh) {
                if (@5_@3(ft, &my_data->pivot,@6@1)){
                	my_data->temp_array[positionLess]=*ft;
			my_data->temp_array_oid[positionLess]=*fh;
                	positionLess++;
		}
                else {
			my_data->temp_array[positionGreater]=*ft;
                        my_data->temp_array_oid[positionGreater]=*fh;
			positionGreater++;
                }
                ft++; fh++;
        }

	pthread_exit(NULL);
}

void *threadFuncRestore_@2_@1(void *arg) {
        thread_data_restore_t *my_data = (thread_data_restore_t *) arg;
        @1  *ft;
        oid *fh, *lh;

        /* set bounds for the iterator */
        ft = (@1 *)Tloc(my_data->array, BUNfirst(my_data->array) + my_data->first);
        fh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->first);
        lh = (oid*)Hloc(my_data->array, BUNfirst(my_data->array) + my_data->last);

        while(fh<=lh) {
                *ft=my_data->temp_array[my_data->tempfirst];
                *fh=my_data->temp_array_oid[my_data->tempfirst];
                my_data->tempfirst++;
                ft++; fh++;
        }

	pthread_exit(NULL);
}

@

@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThreeParallel_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}


str
CRKcrackUnorderedThreeCopyParallel_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc){

        @1  *ft, *lt, *tmax, *t0;
	oid fh, lh, hmax; /*hold actual  oid values in this version*/
	BUN firstBUN;

        @1  *ft2, *lt2, *tmax2; 
	oid *fh2, *lh2, *hmax2;
	BUN firstBUN2;

        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = first;
        hmax = last;

	firstBUN2 = BUNfirst(bc);
        ft2   = (@1*)Tloc(bc, firstBUN2 + first);
        tmax2 = (@1 *)Tloc(bc, firstBUN2 + last);
        fh2   = (oid*)Hloc(bc, firstBUN2 + first);
        hmax2 = (oid*)Hloc(bc, firstBUN2 + last);
	
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
		*tmax2=*tmax;
		*hmax2=hmax;
                tmax--;hmax--;
                tmax2--;hmax2--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt  = tmax;  lh  = hmax;
        lt2 = tmax2; lh2 = hmax2;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
                        tmax--;hmax--;
                        tmax2--;hmax2--;
                }else{
			*lt2=*lt;
			*lh2=lh;
		}	
                lt--; lh--;
                lt2--;lh2--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
	*ft2=*ft;
	*fh2=fh;
        while(ft<=lt) {
                if (@8_@4(ft2, &low,@9@1)){
                        ft++; fh++;
                        ft2++;fh2++;
			if(ft<=lt){
				*ft2=*ft;
				*fh2=fh;
			}
		}
                else {
			*lt2=*ft2;
			*lh2=*fh2;
			*ft2=*lt;
			*fh2=lh;
                        if(@8_@5(lt2, &low,@9@1) && lt>ft){
                                if(@8_@7(lt2, &hgh,@9@1) ){
					@:shuffle(@1,lt2,tmax2,lh2,hmax2)@
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
					*lt2=*tmax2;
					*lh2=*hmax2;
					*tmax2=*lt;
					*hmax2=lh;
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }else{
					*lt2=*lt;
					*lh2=lh;
				}
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(bc, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

@
 * @- Local support functions and macros
@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@
@= shuffle2
        *@7 = *@2;
        *@6 = *@3;

        *@9 = @4;
        *@8 = @5;
@
@= printVarTypes
{
/* @1: the type; e.g., bte sht int oid wrd flt dbl lng str */
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s \n", MyBuf);
	GDKfree(MyBuf);
}
@
