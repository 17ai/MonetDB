@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f array
@a M.L. Kersten, Y.Zhang, M. Ivanova
@+ Basic array support

Arrays are represented by a collection of BATs.
One for each dimension and one for the non-dimension attributes. 
The structure of the dimension is captured in
a shape description, which is an ordered list of tripples
(Start,Step,Stop) where for index variable i the constraint Start<=i<Stop holds
and where the step size is Step.

In the MAL instructions the shape descriptor should be the last
of the arguments. Since every dimension can be of a different
type, we have to rely on runtime type checking. Of course,
the SciQL compiler already can ensure proper type equality
for each shape tripple.
@{

@= array_mdefs
command series(start:@1, step:@1, stop:@1, N:int, M:int) :bat[:oid,:@1] 
address ARRAYseries_@1
comment  "Generates a single series BAT based on range condition, repeating each value N times and repeat the process M times.";

function series_ (start:@1, step:@1, stop:@1, N:int, M:int) (id:bat[:oid,:lng], dimval:bat[:oid,:@1]);
	b1 := array.series(start, step, stop, N, M);
	b2 := bat.mirror(b1);
	b3 := batcalc.lng(b2);
	return (b3,b1);
end series_;

@mal
module array;
@:array_mdefs(bte)@
@:array_mdefs(sht)@
@:array_mdefs(int)@
@:array_mdefs(lng)@
@:array_mdefs(flt)@
@:array_mdefs(dbl)@
@-
to be dealt with differently
@:array_mdefs(oid)@
@:array_mdefs(date)@
@:array_mdefs(daytime)@
@:array_mdefs(timestamp)@

@mal
pattern filler(idx:bat[:oid,:any_1], v:any_2):bat[:oid,:any_2]
address ARRAYfiller_bat
comment "Create an array value representation described by a series column and fill it with V";

pattern filler(cnt:lng, v:any_1):bat[:oid,:any_1]
address ARRAYfiller
comment "Create an array value representation of CNT items and fill it with V";

function filler_(cnt:lng, v:any_1)(id:bat[:oid,:lng], cellval:bat[:oid,:any_1]);
	b1 := array.filler(cnt, v);
	# TODO: why is a markH necessary here, but no in array.series?
	b2 := algebra.markH(b1, 0@0);
	b3 := bat.mirror(b2);
    b4 := batcalc.lng(b3);
	return (b4,b2);
end filler_;

#pattern sum(values:bat[:oid,:any_1], any...):bat[:oid,:any_1]
#address ARRAYtilesSum
#comment "Construct the sum over all tiles";

#pattern avg(values:bat[:oid,:any], any...):bat[:oid,:dbl]
#address ARRAYtilesAvg
#comment "Construct the average over all tiles";

pattern sum(val:any, any...):lng
address ARRAYtilesSum
comment "Construct the sum over all tiles";

pattern sum(val:any, any...):dbl
address ARRAYtilesSum
comment "Construct the sum over all tiles";

pattern avg(val:any, any...):dbl
address ARRAYtilesAvg
comment "Construct the average over all tiles";

pattern min(val:any_1, any...):any_1
address ARRAYtilesMin
comment "Construct the minimum over all tiles";

pattern max(val:any_1, any...):any_1
address ARRAYtilesMax
comment "Construct the maximum over all tiles";

module batarray;

# The BAT version of the AGGR functions over array tiles
pattern sum(val:bat[:oid,:any], any...):bat[:oid,:lng]
address ARRAYtilesSum
comment "Construct the sum over all tiles";

pattern sum(val:bat[:oid,:any], any...):bat[:oid,:dbl]
address ARRAYtilesSum
comment "Construct the sum over all tiles";

pattern avg(val:bat[:oid,:any], any...):bat[:oid,:dbl]
address ARRAYtilesAvg
comment "Construct the average over all tiles";

pattern min(val:bat[:oid,:any_1], any...):bat[:oid,:any_1]
address ARRAYtilesMin
comment "Construct the minimum over all tiles";

pattern max(val:bat[:oid,:any_1], any...):bat[:oid,:any_1]
address ARRAYtilesMax
comment "Construct the maximum over all tiles";

module array;

# unused functions

pattern map(dims:bat[:oid,:any]...):bat[:oid,:oid]
address ARRAYmap
comment "The argument is a double set of dimension columns. The first set describes the shape
of the target array and the second one holds the index values of interest into each dimension.
The result is a column with the oid positions of the elements in target.";

#TODO: tiles containing preceding cells of the anchor point are not handled by the current code.
pattern tiles(cells:bat[:oid,:any_1], template:bat[:oid,:oid]):bat[:oid,:oid]
address ARRAYtiles
comment "Construct the tiled cell id list using a template with relative offsets";

pattern unmap(cells:bat[:oid,:oid], dims:bat[:oid,:any]...):bat[:oid,:any]...
address ARRAYumap
comment "Extract the index columns from a shape based on the cell identifier list";

pattern isFixed(dims:bat[:oid,:any]...):bit
address ARRAYisFixed
comment "Determine fixed size property of an array";

pattern isUnbounded(dims:bat[:oid,:any]...):bit
address ARRAYisUnbounded
comment "Determine unboundedness property of an array";

pattern getDimensions(dims:bat[:oid,:any]...):int...
address ARRAYgetDimensions
comment "Extract the series sizes";

pattern replace(v1:bat[:oid, :any_1], idx:bat[:oid, :oid], v2:any_1):bat[:oid,:any_1]
address ARRAYreplaceScalar
comment "Replace values in v1 at the positions determined by idx with v2, return the modified v1.";

pattern replace(v1:bat[:oid, :any_1], idx:bat[:oid, :oid], v2:bat[:oid, :any_1]):bat[:oid,:any_1]
address ARRAYreplace
comment "Replace values in v1 at the positions determined by idx with values in v2, return the modified v1.";

command product(b:bat[:any_3,:any_1],c:bat[:any_4,:any_2]):bat[:any_1,:any_2]
address ARRAYproduct
comment "Produce an array product";

pattern embed(shapes:bat[:oid,:any]...):bat[:oid,:oid]
address ARRAYembed
comment "Take two shapes N and M and derive a mapping between the elements based on the index values.
It can be used to create an embedding of values from one array into another.";
@- Implementation
@include ../mal/prelude.mx
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include "gdk.h"
#include "algebra.h"		/* to include BATmin and BATmax */
#include "mtime.h"
#include <math.h>
#include <time.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define array_export extern __declspec(dllimport)
#else
#define array_export extern __declspec(dllexport)
#endif
#else
#define array_export extern
#endif

array_export str ARRAYisFixed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYisUnbounded(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYgetDimensions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYproduct(int *ret, int *bid, int *rid);
array_export str ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYumap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYreplaceScalar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYtiles(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesAvg(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMax(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYembed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@= array_defs
array_export str ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *grp, int *series);
array_export str ARRAYtilesSum_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesAvg_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMin_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMax_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@h
@:array_defs(bte)@
@:array_defs(sht)@
@:array_defs(int)@
@:array_defs(lng)@
@:array_defs(flt)@
@:array_defs(dbl)@
@-
to be dealt with differently
@:array_defs(oid)@
@:array_defs(date)@
@:array_defs(daytime)@
@:array_defs(timestamp)@

@h
/* The maximum number of series_ that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb_config.h"
#include "mal_client.h"
#include "array.h"

/*----------------------------------------------------------------------------*/

@c
#include "mal.h"
#include "mal_interpreter.h"
@= dim_wrapper_impl
str
ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *group, int *series)
{
	BAT *bn;
	@1 i, *o;
	BUN cnt= 0;
	int s,g;

	if ( *group < 1 )
		throw(MAL, "array.series", "#groups must be > 0,  got (%d)", *group);
	if ( *series < 1 )
		throw(MAL, "array.series", "#series must be > 0,  got (%d)", *series);

	if ( (*start < *stop && *step > 0) || (*start > *stop && *step < 0) ) {
		cnt =  (BUN) ceil(((*stop * 1.0 - *start) / *step)) * *group * *series ;
	} else
		throw(MAL, "array.series", "Illegal dimension range, [start:step:stop] have values: [@2:@2:@2]", *start, *step, *stop);
	bn = BATnew(TYPE_void, TYPE_@1, cnt);
	if ( bn == NULL)
		throw(MAL, "array.series", MAL_MALLOC_FAIL);

	o = (@1*)Tloc(bn, BUNfirst(bn));

	if ( *start < *stop && *step > 0) {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i < *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	} else {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i > *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	}
	BATsetcount(bn, cnt);
	BATseqbase(bn,0);
	bn->hdense = TRUE;
	BATkey(bn, TRUE);
	bn->hsorted = 1;
	bn->hrevsorted = (cnt <= 1);
	bn->tsorted = (cnt <= 1 || (*series == 1 && *step > 0));
	bn->trevsorted = (cnt <= 1 || (*series == 1 && *step < 0));
	bn->T->nonil = TRUE;

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

@c
@:dim_wrapper_impl(bte,%d)@
@:dim_wrapper_impl(sht,%d)@
@:dim_wrapper_impl(int,%d)@
@:dim_wrapper_impl(lng,%lld)@
@:dim_wrapper_impl(flt,%f)@
@:dim_wrapper_impl(dbl,%f)@
@-
to be dealt with differently
@:dim_wrapper_impl(oid," OIDFMT ")@
@:dim_wrapper_impl(date)@
@:dim_wrapper_impl(daytime)@
@:dim_wrapper_impl(timestamp)@

@-
@= arraymultiply
array_export str ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid);
str
ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid){
	BAT *bn, *b, *r;
	BUN p,q, s,t;
	@2 val;
	oid o= oid_nil;
	BATiter bi, ri;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	if( (r= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(TYPE_void, TYPE_@2, BATcount(b)*BATcount(r));

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(b,p,q){
		BATloop(r,s,t){
			val = (*(@1*) BUNtail(bi,p)) * (*(@1*)BUNtail(ri,s));
			BUNfastins(bn,&o,&val);
		}
	}
	BATseqbase(bn,0);
	bn->hdense = TRUE;
	BATkey(bn, TRUE);
	bn->hsorted = 1;
	bn->hrevsorted = (BATcount(bn) <= 1);
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arraymultiply(sht,lng)@
@:arraymultiply(sht,int)@
@:arraymultiply(int,int)@
@:arraymultiply(int,lng)@
@:arraymultiply(lng,lng)@
@:arraymultiply(flt,flt)@
@:arraymultiply(dbl,dbl)@

str
ARRAYproduct(int *ret, int *bid, int *rid)
{
	BAT *bn, *b, *r;
	BUN p, q, s, t;
	BATiter bi, ri;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if (BATcount(b) > BATcount(r) || (BATcount(b) % BATcount(r)) != BATcount(b)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(r->batCacheid);
		throw(MAL, "array.product", "Illegal argument bounds");
	}
	bn = BATnew(b->ttype, r->ttype, BATcount(r));

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(r, s, t) {
		BATloop(b, p, q) {
			BUNfastins(bn, BUNtail(bi, p), BUNtail(ri, s));
			s++;
		}
		s--;
	}
	/* not sorted at best we have some fixed offset partial sorting */
	bn->hsorted = 0;
	bn->hrevsorted = 0;
	bn->tsorted = 0;
	bn->trevsorted = 0;
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn, *b;
	BUN p, q;
	BATiter bi;
	int *ret = (int*) getArgReference(stk,pci,0);
	int bid = *(int*) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);
	int type = getArgType(mb,pci,2);

	if ((b = BATdescriptor(bid)) == NULL) 
		throw(MAL, "array.filler", RUNTIME_OBJECT_MISSING);
	
	bn = BATnew(b->htype, type, BATcount(b));

	bi = bat_iterator(b);
	BATloop(b,p,q){
		BUNfastins(bn, BUNhead(bi, p), ATOMvarsized(type)?*(str *)val:val);
	}
	BATseqbase(bn,b->hseqbase);
	bn->hdense = BAThdense(b);
	BATkey(bn, BAThkey(b));
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	bn->tsorted = b->trevsorted = 1;
	(void) cntxt;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn;
	int *ret = (int*) getArgReference(stk,pci,0);
	oid i = 0;
	lng cnt = *(lng *) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);
	int type = getArgType(mb,pci,2);

	(void) cntxt;

	if (cnt > (lng)BUN_MAX)
		throw(MAL, "array.filler", "BAT too large");

	if(!(bn = BATnew(TYPE_void, type, cnt)))
		throw(MAL, "array.filler", MAL_MALLOC_FAIL);

	for (i = 0; i < (oid)cnt; i++)
		BUNfastins(bn, &i, ATOMvarsized(type)?*(str *)val:val);

	BATsetcount(bn, cnt);
	BATseqbase(bn, 0);
	bn->hdense = TRUE;
	BATkey(bn, TRUE);
	bn->hsorted = 1;
	bn->hrevsorted = (cnt <= 1);
	bn->tsorted = bn->trevsorted = 1;
	switch(type){
		case TYPE_bit:
			bn->T->nonil = *(bit*)val==bit_nil?FALSE:TRUE;
			break;
		case TYPE_bte:
			bn->T->nonil = *(bte*)val==bte_nil?FALSE:TRUE;
			break;
		case TYPE_sht:
			bn->T->nonil = *(sht*)val==sht_nil?FALSE:TRUE;
			break;
		case TYPE_int:
			bn->T->nonil = *(int*)val==int_nil?FALSE:TRUE;
			break;
		case TYPE_flt:
			bn->T->nonil = *(flt*)val==flt_nil?FALSE:TRUE;
			break;
		case TYPE_dbl:
			bn->T->nonil = *(dbl*)val==dbl_nil?FALSE:TRUE;
			break;
		case TYPE_lng:
			bn->T->nonil = *(lng*)val==lng_nil?FALSE:TRUE;
			break;
		case TYPE_str:
			bn->T->nonil = (strcmp(*(str*)val, str_nil) == 0)?FALSE:TRUE;
			break;
		default:
			throw(MAL, "array.filler", "Unsupported data type");
	}
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b, *bn = NULL, *bo;
	int i,n = 0, error = 0;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc - pci->retc) % 2 != 0)
		throw(MAL, "array.map", "Unbalanced index arguments");

	b= (BAT**) GDKzalloc(sizeof(BAT*) * pci->argc-pci->retc);
	if( b == NULL)
		throw(MAL, "array.map", MAL_MALLOC_FAIL);

	for ( i=pci->retc; i< pci->argc; i++){
		if ((b[n++] = BATdescriptor(*(int*)getArgReference(stk,pci,i))) == NULL) {
			for ( n--; n>= 0; n--)
				BBPreleaseref(b[n]->batCacheid);
			GDKfree(b);
			throw(MAL, "array.map", RUNTIME_OBJECT_MISSING);
		}
	}
	/* type check the shapes and prepare iterators */
	for ( i= 0; i< n/2; i++) 
		error |= b[i]->ttype != b[i+n/2]->ttype;

	if ( error ){
		for ( n--; n>= 0; n--)
			BBPreleaseref(b[n]->batCacheid);
		GDKfree(b);
		throw(MAL, "array.map", "Incompatible index types");
	}

	/* select the oids we need by searching all matching index vectors */
	bn = b[0];
	for ( i=0; i<n/2; i++){
		bo = BATsemijoin(b[i],bn);
		bn= BATmirror(BATsemijoin(BATmirror(bo), BATmirror(b[i+n/2])));
		BBPreleaseref(bo->batCacheid);
	}
	bn = BATmark(bn,0);

	*(int*) getArgReference(stk,pci,0) = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	for ( n--; n>= 0; n--)
		BBPreleaseref(b[n]->batCacheid);
	GDKfree(b);
	return MAL_SUCCEED;
}

str
ARRAYumap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bn, *bo;
	int i;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc -1 - pci->retc) != pci->retc)
		throw(MAL, "array.unmap", "Unbalanced index arguments and return list");
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,pci->retc))) == NULL) 
		throw(MAL, "array.unmap", RUNTIME_OBJECT_MISSING);
	
	for ( i=pci->retc+1; i<pci->argc; i++){
		bo = BATdescriptor(*(int*)getArgReference(stk,pci,i));
		if ( bo == NULL){
			BBPreleaseref(b->batCacheid);
			throw(MAL, "array.unmap", RUNTIME_OBJECT_MISSING);
		}
		bn = BATsemijoin( bo,b);
		if ( bn ) {
			*(int*) getArgReference(stk,pci,i-pci->retc -1 ) = bn->batCacheid;
			BBPkeepref(bn->batCacheid);
		}
			BBPkeepref(bo->batCacheid);
	}
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYisFixed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.isFixed", PROGRAM_NYI);
}

str
ARRAYisUnbounded(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.isUnbounded", PROGRAM_NYI);
}

str
ARRAYgetDimensions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.getDimensions", PROGRAM_NYI);
}

str
ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bo, *bc, *bv,*bn;
	int *ret = (int*) getArgReference(stk,pci,0);

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	if ((bc = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	if ((bv = BATdescriptor(*(int*)getArgReference(stk,pci,3))) == NULL) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	if ( BATcount(bc) != BATcount(bv)){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		BBPreleaseref(bv->batCacheid);
		throw(MAL, "array.replace", "unbalanced array arguments");
	}
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	bo = BATjoin(bc,bv,0);
	if ( bo )
		bn = BATreplace(bn,bo, TRUE);
	if ( bn == NULL || bo == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		BBPreleaseref(bv->batCacheid);
		if ( bo == NULL) BBPreleaseref(bo->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bc->batCacheid);
	BBPreleaseref(bv->batCacheid);
	BBPreleaseref(bo->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYreplaceScalar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bc, *bn, *bo;
	int *ret = (int*) getArgReference(stk,pci,0);
	void *val = (void*) getArgReference(stk,pci,3);
	BATiter bi;
	BUN p,q;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	if ((bc = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	bo = BATnew(bc->ttype, b->ttype, TRUE);
	bi = bat_iterator(bc);
	BATloop(bc,p,q){
		oid o = *(oid*) BUNhead(bi,p);
		BUNins(bo, &o, val, TRUE);
	}
	bn=  BATreplace(b,bo,TRUE);
	BBPreleaseref(bo->batCacheid);
	if ( bn == NULL ){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bc->batCacheid);
		throw(MAL, "array.replace", RUNTIME_OBJECT_MISSING);
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(bc->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYtiles(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *bt, *bn;
	int *ret = (int*) getArgReference(stk,pci,0);
	BATiter bi, br;
	BUN p,q;
	BUN r,s;
	oid g = 0, limit;

	(void) cntxt;
	(void) mb;
	if ((b = BATdescriptor(*(int*)getArgReference(stk,pci,1))) == NULL) 
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	if ((bt = BATdescriptor(*(int*)getArgReference(stk,pci,2))) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.tiles", RUNTIME_OBJECT_MISSING);
	}
	bn = BATnew(TYPE_oid, TYPE_oid, TRUE);
	bi = bat_iterator(b);
	br = bat_iterator(bt);
	limit= BATcount(b);
	BATloop(b,p,q){
		g = *(oid*) BUNhead(bi,p);
		BATloop(bt,r,s){
			oid o = g + *(oid*) BUNhead(br,r);
			if ( o < limit)
				BUNins(bn, &g, &o, TRUE);
		}
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bt->batCacheid);
	return MAL_SUCCEED;
}

@= tilesAggr
# define AGGR_CLEANUP() \
{ \
	if (bVal) BBPreleaseref(bVal->batCacheid); \
	for (i = 0; i < ndims; i++) { \
		if(bDims[i]) BBPreleaseref(bDims[i]->batCacheid); \
		if(bOffsets[i]) BBPreleaseref(bOffsets[i]->batCacheid); \
	} \
	if(bDims) GDKfree(bDims); \
	if(bDimsT) GDKfree(bDimsT); \
	if(bOffsets) GDKfree(bOffsets); \
	if(bOffsetsT) GDKfree(bOffsetsT); \
	if(dMin) GDKfree(dMin); \
	if(dMax) GDKfree(dMax); \
	if(dSize) GDKfree(dSize); \
}
/* 
 * array.[sum|avg] inputs:
 *  (cell_val:BAT,
 *   dim_1:BAT,tile_member_offset_dim_1:BAT,size_dim_1, ...,
 *   dim_n:BAT,tile_member_offset_dim_n:BAT,size_dim_n)
 */
str
ARRAYtiles@4_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bVal = NULL, *bRes = NULL, **bDims = NULL, **bOffsets = NULL;
	int *ret = (int*) getArgReference(stk,pci,0), i = 0, ndims = 0, err = 0;
	@1 *bValT = NULL, elm = 0;
	@3 *bResT = NULL;
	int **bDimsT = NULL, **bOffsetsT = NULL;
	BUN p, r, arrcnt = 0, offcnt = 0, cnt = 0;
	@2 sum = 0;
	/* FIXME: this code only deal with INT dimensions */
	int cidx = 0, *dMin = NULL, *dMax = NULL, *dSize = NULL;
	oid arrbase = 0, offbase = 0, vid = 0, mul = 0;

	(void) cntxt;
	(void) mb;

	if ( (pci->argc - pci->retc - 1) % 3 != 0)
		throw(MAL, "array.@5", "Unbalanced argument sets");

	ndims = (pci->argc - pci->retc - 1) / 3;
	bDims = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bDimsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	bOffsets = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bOffsetsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	dMin = (int*) GDKzalloc(sizeof(int) * ndims);
	dMax = (int*) GDKzalloc(sizeof(int) * ndims);
	dSize = (int*) GDKzalloc(sizeof(int) * ndims);
	bVal = BATdescriptor(*(int*)getArgReference(stk,pci,1));
	if(!bDims || !bDimsT || !bOffsets || !bOffsetsT || !dMin || !dMax || !dSize || !bVal) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", RUNTIME_OBJECT_MISSING);
	}
	for (i = 0; i < ndims; i++) {
		bDims[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3));
		bOffsets[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3+1));
		if (!bDims[i] || !bOffsets[i]) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", RUNTIME_OBJECT_MISSING);
		}
		dSize[i] = *(int*)getArgReference(stk,pci,2+i*3+2);
	}
	/* type check the shapes, prepare iterators, and compute the min/max of the dimensions */
	if (!BAThdense(bVal)) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", "head of value BAT must be dense");
	}
	if (bVal->ttype != TYPE_@1) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", "tail of value BAT must be of type @1");
	}
	arrcnt = BATcount(bVal);
	arrbase = bVal->hseqbase;
	offbase = bOffsets[0]->hseqbase;
	offcnt = BATcount(bOffsets[0]);
	for (i = 0; i < ndims; i++) {
		if (!BAThdense(bDims[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all dimension BATs must be dense");
		}
		if (!BAThdense(bOffsets[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all offset BATs must be dense");
		}
		if (bDims[i]->hseqbase != arrbase || BATcount(bDims[i]) != arrcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all dimension BATs must be aligned with head of value BAT");
		}
		if (bOffsets[i]->hseqbase != offbase || BATcount(bOffsets[i]) != offcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "heads of all offset BATs must be aligned");
		}
		if (bDims[i]->ttype != TYPE_int || bDims[i]->ttype != bOffsets[i]->ttype) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", SEMANTIC_TYPE_MISMATCH);
		}
		BATmin(bDims[i], &(dMin[i]));
		BATmax(bDims[i], &(dMax[i]));
	}

	/* access tails as arrays */
	bValT = (@1*) Tloc(bVal, BUNfirst(bVal));
	for (i = 0; i < ndims; i++) {
		bDimsT[i] = (int*) Tloc(bDims[i], BUNfirst(bDims[i]));
		bOffsetsT[i] = (int*) Tloc(bOffsets[i], BUNfirst(bOffsets[i]));
	}

	/* For each anchor piont, compute all cells belong to this tile (bVal.head
	 * is the group nr.) and compute the SUM */
	bRes = 	BATnew(TYPE_void, TYPE_@3, BATcount(bVal));
	bResT = (@3*) Tloc(bRes, BUNfirst(bRes));
	for (p = 0 ; p < arrcnt ; p++) {
		sum = 0; cnt = 0;
		/* loop over all sets of offsets */
		for (r = 0; r < offcnt ; r++) {
			vid = 0; /* index into bVal for the value of a qualified tile member */
			mul = 1;
			err = 0;
			/* for the index of the anchor point on dimension d_i, check if the
			 * resulting index is within the dimension range after having
			 * shifted according this set of offset on dimension d_i.
			 * If yes, update 'vid' so that we know the OID of the qualified
			 * cell at the end; otherwise, skip.
			 */
			/* TODO: we can skip more.  If the j-th value bOffsets[i]
			 * disqualifies the index on dimension d_i, we can jump to the next
			 * of bOffsets[i] which value follows the j-th value */
			for (i = ndims - 1; i >= 0; i--) {
				cidx = bDimsT[i][p] + bOffsetsT[i][r];
				if (dMin[i] <= cidx && cidx <= dMax[i]) {
					vid += mul * (cidx - dMin[i]);
				} else {
					err = 1;
					break; /* skip remaining dimensions */
				}
				mul *= dSize[i];
			}
			if (!err) {
				elm = bValT[vid];
				if (elm != @1_nil) {
					cnt++;
					sum += elm;
				}
			}
		}
		bResT[p] = (cnt ? @6 : @3_nil);
	}
	AGGR_CLEANUP();
	BATsetcount(bRes, arrcnt);
	BATseqbase(bRes, arrbase);
	bRes->hdense = TRUE;
	BATkey(bRes, TRUE);
	bRes->hsorted = 1;
	bRes->hrevsorted = (arrcnt <= 1);
	bRes->tsorted = (arrcnt <= 1);
	bRes->trevsorted = (arrcnt <= 1);
	BATkey(BATmirror(bRes), FALSE);
	BBPkeepref(*ret = bRes->batCacheid);
	return MAL_SUCCEED;
}
@-
The compilating factor is that in general the tile enumeration is dense, while
the tile structure can go over its boundaries. For this to control, we first
embed the array into a slightly larger array, filled with nulls.

@c
@:tilesAggr(bte,lng,lng,Sum,sum, sum )@
@:tilesAggr(sht,lng,lng,Sum,sum, sum )@
@:tilesAggr(int,lng,lng,Sum,sum, sum )@
@:tilesAggr(lng,lng,lng,Sum,sum, sum )@
@:tilesAggr(flt,dbl,dbl,Sum,sum, sum )@
@:tilesAggr(dbl,dbl,dbl,Sum,sum, sum )@
@:tilesAggr(bte,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(sht,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(int,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(lng,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(flt,dbl,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(dbl,dbl,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
str
ARRAYtilesSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int type = getTailType(getArgType(mb,pci,1));
	switch(type){
	case TYPE_bte:
		return ARRAYtilesSum_bte(cntxt,mb,stk,pci);
	case TYPE_sht:
		return ARRAYtilesSum_sht(cntxt,mb,stk,pci);
	case TYPE_int:
		return ARRAYtilesSum_int(cntxt,mb,stk,pci);
	case TYPE_lng:
		return ARRAYtilesSum_lng(cntxt,mb,stk,pci);
	case TYPE_flt:
		return ARRAYtilesSum_flt(cntxt,mb,stk,pci);
	case TYPE_dbl:
		return ARRAYtilesSum_dbl(cntxt,mb,stk,pci);
	default:
		throw(MAL, "array.sum", "illegal/unsupported type");
	}
	return MAL_SUCCEED;
}

str
ARRAYtilesAvg(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int type = getTailType(getArgType(mb,pci,1));
	switch(type){
	case TYPE_bte:
		return ARRAYtilesAvg_bte(cntxt,mb,stk,pci);
	case TYPE_sht:
		return ARRAYtilesAvg_sht(cntxt,mb,stk,pci);
	case TYPE_int:
		return ARRAYtilesAvg_int(cntxt,mb,stk,pci);
	case TYPE_lng:
		return ARRAYtilesAvg_lng(cntxt,mb,stk,pci);
	case TYPE_flt:
		return ARRAYtilesAvg_flt(cntxt,mb,stk,pci);
	case TYPE_dbl:
		return ARRAYtilesAvg_dbl(cntxt,mb,stk,pci);
	default:
		throw(MAL, "array.sum", "illegal/unsupported type");
	}
	return MAL_SUCCEED;
}

@= tilesMinMax
# define MINMAX_CLEANUP() \
{ \
	if (bVal) BBPreleaseref(bVal->batCacheid); \
	for (i = 0; i < ndims; i++) { \
		if(bDims[i]) BBPreleaseref(bDims[i]->batCacheid); \
		if(bOffsets[i]) BBPreleaseref(bOffsets[i]->batCacheid); \
	} \
	if(bDims) GDKfree(bDims); \
	if(bDimsT) GDKfree(bDimsT); \
	if(bOffsets) GDKfree(bOffsets); \
	if(bOffsetsT) GDKfree(bOffsetsT); \
	if(dMin) GDKfree(dMin); \
	if(dMax) GDKfree(dMax); \
	if(dSize) GDKfree(dSize); \
}
/* 
 * array.[min|max] inputs:
 *  (cell_val:BAT,
 *   dim_1:BAT,tile_member_offset_dim_1:BAT,size_dim_1, ...,
 *   dim_n:BAT,tile_member_offset_dim_n:BAT,size_dim_n)
 */
str
ARRAYtiles@2_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bVal = NULL, *bRes = NULL, **bDims = NULL, **bOffsets = NULL;
	int *ret = (int*) getArgReference(stk,pci,0), i = 0, ndims = 0, err = 0;
	@1 *bValT = NULL, elm = 0;
	@1 *bResT = NULL;
	int **bDimsT = NULL, **bOffsetsT = NULL;
	BUN p, r, arrcnt = 0, offcnt = 0;
	@1 minmax = @1_nil;
	bit first = TRUE;
	/* FIXME: this code only deal with INT dimensions */
	int cidx = 0, *dMin = NULL, *dMax = NULL, *dSize = NULL;
	oid arrbase = 0, offbase = 0, vid = 0, mul = 0;

	(void) cntxt;
	(void) mb;

	if ( (pci->argc - pci->retc - 1) % 3 != 0)
		throw(MAL, "array.@3", "Unbalanced argument sets");

	ndims = (pci->argc - pci->retc - 1) / 3;
	bDims = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bDimsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	bOffsets = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bOffsetsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	dMin = (int*) GDKzalloc(sizeof(int) * ndims);
	dMax = (int*) GDKzalloc(sizeof(int) * ndims);
	dSize = (int*) GDKzalloc(sizeof(int) * ndims);
	bVal = BATdescriptor(*(int*)getArgReference(stk,pci,1));
	if(!bDims || !bDimsT || !bOffsets || !bOffsetsT || !dMin || !dMax || !dSize || !bVal) {
		MINMAX_CLEANUP();
		throw(MAL, "array.@3", RUNTIME_OBJECT_MISSING);
	}
	for (i = 0; i < ndims; i++) {
		bDims[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3));
		bOffsets[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3+1));
		if (!bDims[i] || !bOffsets[i]) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", RUNTIME_OBJECT_MISSING);
		}
		dSize[i] = *(int*)getArgReference(stk,pci,2+i*3+2);
	}
	/* type check the shapes, prepare iterators, and compute the min/max of the dimensions */
	if (!BAThdense(bVal)) {
		MINMAX_CLEANUP();
		throw(MAL, "array.@3", "head of value BAT must be dense");
	}
	if (bVal->ttype != TYPE_@1) {
		MINMAX_CLEANUP();
		throw(MAL, "array.@3", "tail of value BAT must be of type @1");
	}
	arrcnt = BATcount(bVal);
	arrbase = bVal->hseqbase;
	offbase = bOffsets[0]->hseqbase;
	offcnt = BATcount(bOffsets[0]);
	for (i = 0; i < ndims; i++) {
		if (!BAThdense(bDims[i])) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", "head of all dimension BATs must be dense");
		}
		if (!BAThdense(bOffsets[i])) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", "head of all offset BATs must be dense");
		}
		if (bDims[i]->hseqbase != arrbase || BATcount(bDims[i]) != arrcnt) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", "head of all dimension BATs must be aligned with head of value BAT");
		}
		if (bOffsets[i]->hseqbase != offbase || BATcount(bOffsets[i]) != offcnt) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", "heads of all offset BATs must be aligned");
		}
		if (bDims[i]->ttype != TYPE_int || bDims[i]->ttype != bOffsets[i]->ttype) {
			MINMAX_CLEANUP();
			throw(MAL, "array.@3", SEMANTIC_TYPE_MISMATCH);
		}
		BATmin(bDims[i], &(dMin[i]));
		BATmax(bDims[i], &(dMax[i]));
	}

	/* access tails as arrays */
	bValT = (@1*) Tloc(bVal, BUNfirst(bVal));
	for (i = 0; i < ndims; i++) {
		bDimsT[i] = (int*) Tloc(bDims[i], BUNfirst(bDims[i]));
		bOffsetsT[i] = (int*) Tloc(bOffsets[i], BUNfirst(bOffsets[i]));
	}

	/* For each anchor piont, compute all cells belong to this tile (bVal.head
	 * is the group nr.) and compute the SUM */
	bRes = 	BATnew(TYPE_void, TYPE_@1, BATcount(bVal));
	bResT = (@1*) Tloc(bRes, BUNfirst(bRes));
	for (p = 0 ; p < arrcnt ; p++) {
		/* loop over all sets of offsets */
		for (r = 0; r < offcnt ; r++) {
			vid = 0; /* index into bVal for the value of a qualified tile member */
			mul = 1;
			err = 0;
			/* for the index of the anchor point on dimension d_i, check if the
			 * resulting index is within the dimension range after having
			 * shifted according this set of offset on dimension d_i.
			 * If yes, update 'vid' so that we know the OID of the qualified
			 * cell at the end; otherwise, skip.
			 */
			/* TODO: we can skip more.  If the j-th value bOffsets[i]
			 * disqualifies the index on dimension d_i, we can jump to the next
			 * of bOffsets[i] which value follows the j-th value */
			for (i = ndims - 1; i >= 0; i--) {
				cidx = bDimsT[i][p] + bOffsetsT[i][r];
				if (dMin[i] <= cidx && cidx <= dMax[i]) {
					vid += mul * (cidx - dMin[i]);
				} else {
					err = 1;
					break; /* skip remaining dimensions */
				}
				mul *= dSize[i];
			}
			if (!err) {
				elm = bValT[vid];
				if (elm != @1_nil) {
					if (first) {
						minmax = elm;
						first = FALSE;
					}
					else
						minmax = @4(minmax,elm);
				}
			}
		}
		bResT[p] = minmax;
	}
	MINMAX_CLEANUP();
	BATsetcount(bRes, arrcnt);
	BATseqbase(bRes, arrbase);
	bRes->hdense = TRUE;
	BATkey(bRes, TRUE);
	bRes->hsorted = 1;
	bRes->hrevsorted = (arrcnt <= 1);
	bRes->tsorted = (arrcnt <= 1);
	bRes->trevsorted = (arrcnt <= 1);
	BATkey(BATmirror(bRes), FALSE);
	BBPkeepref(*ret = bRes->batCacheid);
	return MAL_SUCCEED;
}
@-
The compilating factor is that in general the tile enumeration is dense, while
the tile structure can go over its boundaries. For this to control, we first
embed the array into a slightly larger array, filled with nulls.

@c
@:tilesMinMax(bte,Min,min,MIN)@
@:tilesMinMax(sht,Min,min,MIN)@
@:tilesMinMax(int,Min,min,MIN)@
@:tilesMinMax(lng,Min,min,MIN)@
@:tilesMinMax(flt,Min,min,MIN)@
@:tilesMinMax(dbl,Min,min,MIN)@
@:tilesMinMax(bte,Max,max,MAX)@
@:tilesMinMax(sht,Max,max,MAX)@
@:tilesMinMax(int,Max,max,MAX)@
@:tilesMinMax(lng,Max,max,MAX)@
@:tilesMinMax(flt,Max,max,MAX)@
@:tilesMinMax(dbl,Max,max,MAX)@
str
ARRAYtilesMin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int type = getTailType(getArgType(mb,pci,1));
	switch(type){
	case TYPE_bte:
		return ARRAYtilesMin_bte(cntxt,mb,stk,pci);
	case TYPE_sht:
		return ARRAYtilesMin_sht(cntxt,mb,stk,pci);
	case TYPE_int:
		return ARRAYtilesMin_int(cntxt,mb,stk,pci);
	case TYPE_lng:
		return ARRAYtilesMin_lng(cntxt,mb,stk,pci);
	case TYPE_flt:
		return ARRAYtilesMin_flt(cntxt,mb,stk,pci);
	case TYPE_dbl:
		return ARRAYtilesMin_dbl(cntxt,mb,stk,pci);
	default:
		throw(MAL, "array.min", "illegal/unsupported type");
	}
	return MAL_SUCCEED;
}

str
ARRAYtilesMax(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int type = getTailType(getArgType(mb,pci,1));
	switch(type){
	case TYPE_bte:
		return ARRAYtilesMax_bte(cntxt,mb,stk,pci);
	case TYPE_sht:
		return ARRAYtilesMax_sht(cntxt,mb,stk,pci);
	case TYPE_int:
		return ARRAYtilesMax_int(cntxt,mb,stk,pci);
	case TYPE_lng:
		return ARRAYtilesMax_lng(cntxt,mb,stk,pci);
	case TYPE_flt:
		return ARRAYtilesMax_flt(cntxt,mb,stk,pci);
	case TYPE_dbl:
		return ARRAYtilesMax_dbl(cntxt,mb,stk,pci);
	default:
		throw(MAL, "array.max", "illegal/unsupported type");
	}
	return MAL_SUCCEED;
}

str
ARRAYembed(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT **b, *bn = NULL, *bo;
	int i,n = 0, error = FALSE;

	(void) cntxt;
	(void) mb;
	if ( (pci->argc - pci->retc) % 2 != 0)
		throw(MAL, "array.embed", "Unbalanced index arguments");

	b= (BAT**) GDKzalloc(sizeof(BAT*) * pci->argc-pci->retc);
	if( b == NULL)
		throw(MAL, "array.embed", MAL_MALLOC_FAIL);

	for ( i=pci->retc; i< pci->argc; i++){
		if ((b[n++] = BATdescriptor(*(int*)getArgReference(stk,pci,i))) == NULL) {
			for ( n--; n>= 0; n--)
				BBPreleaseref(b[n]->batCacheid);
			GDKfree(b);
			throw(MAL, "array.embed", RUNTIME_OBJECT_MISSING);
		}
	}
	/* type check the shapes and prepare iterators */
	for ( i= 0; i< n/2; i++) 
		error |= b[i]->ttype != b[i+n/2]->ttype;

	if ( error ){
		for ( n--; n>= 0; n--)
			BBPreleaseref(b[n]->batCacheid);
		GDKfree(b);
		throw(MAL, "array.embed", "Incompatible index types");
	}

	/* select the oids we need by searching all matching index vectors */
	bn = b[0];
	for ( i=0; i<n/2; i++){
		bo = BATsemijoin(b[i],bn);
		bn= BATmirror(BATsemijoin(BATmirror(bo), BATmirror(b[i+n/2])));
		BBPreleaseref(bo->batCacheid);
		bo = b[i+n/2];
	}

	if ( BATcount(bn) == BATcount(b[n/2]) ) {
		bn = BATmark(bn,0);
		BBPkeepref(bn->batCacheid);
		*(int*) getArgReference(stk,pci,0) = bn->batCacheid;
	} else {
		error = TRUE;
		BBPreleaseref(bn->batCacheid);
	}

	for ( n--; n>= 0; n--)
		BBPreleaseref(b[n]->batCacheid);
	GDKfree(b);
	if( error)
		throw(MAL,"array.embed","incomplete embedding");
	return MAL_SUCCEED;
}
@-
The printing stuff is postponed to the future. Then it also needs
a solution to the GDKout issues.
/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
	This is postpone to the future of arrays.
*/

static int
print_array(BAT *val, ...)
{
	BATiter vali = bat_iterator(val);
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	BUN j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}
	va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	if ( minvector == NULL) 
		goto exit_err_full;
	idxvector = GDKzalloc(sizeof(int) * dims);
	if ( idxvector == NULL) 
		goto exit_err_full;
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	if ( maxvector == NULL) 
		goto exit_err_full;
	lenvector = GDKmalloc(sizeof(ptr) * dims);
	if ( lenvector == NULL) 
		goto exit_err_full;

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);
	if ( arrayindex == NULL)
		goto exit_err_full;

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		BATiter b0i = bat_iterator(batptr[0]);
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(b0i, p);
			register int offset;

			offset = *((int *) BUNtail(b0i, p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == BUN_NONE) {
					GDKerror("print_array: Index %d missing for oid " OIDFMT ".\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) Tloc(batptr[i],p))) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p++;
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				mnstr_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (i < dims && idxvector[i] == 0) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			mnstr_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == BUN_NONE) {
				GDKerror("print_array: Value missing for oid " OIDFMT ".\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, OIDFMT "\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(vali, p), st);
			if (mnstr_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while (i < dims && (++idxvector[i]) == lenvector[i]) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			mnstr_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	mnstr_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

exit_err_full:
	if (arrayindex)
		GDKfree(arrayindex);
exit_err_part:
	if ( maxvector)
		GDKfree(maxvector);
	if (idxvector)
		GDKfree(idxvector);
	if (minvector)
		GDKfree(minvector);
	if (lenvector)
		GDKfree(lenvector);
exit_err_none:
	return GDK_FAIL;
}
@}
