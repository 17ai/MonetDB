@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f array
@a M.L. Kersten, Y.Zhang, M. Ivanova
@+ Basic array support

Arrays are represented by a collection of BATs.
One for each dimension and one for the non-dimension attributes. 
The structure of the dimension is captured in
a shape description, which is an ordered list of tripples
(Start,Step,Stop) where for index variable i the constraint Start<=i<Stop holds
and where the step size is Step.

In the MAL instructions the shape descriptor should be the last
of the arguments. Since every dimension can be of a different
type, we have to rely on runtime type checking. Of course,
the SciQL compiler already can ensure proper type equality
for each shape tripple.
@{

@= array_mdefs
command series(start:@1, step:@1, stop:@1, N:int, M:int) :bat[:oid,:@1] 
address ARRAYseries_@1
comment  "Generates a single series BAT based on range condition, repeating each value N times and repeat the process M times.";

function series_ (start:@1, step:@1, stop:@1, N:int, M:int) (id:bat[:oid,:lng], dimval:bat[:oid,:@1]);
	b1 := array.series(start, step, stop, N, M);
	b2 := bat.mirror(b1);
	b3 := batcalc.lng(b2);
	return (b3,b1);
end series_;

@mal
module array;
@:array_mdefs(bte)@
@:array_mdefs(sht)@
@:array_mdefs(int)@
@:array_mdefs(lng)@
@:array_mdefs(flt)@
@:array_mdefs(dbl)@

@mal
pattern filler(idx:bat[:oid,:any_1], v:any_2):bat[:oid,:any_2]
address ARRAYfiller_bat
comment "Create an array value representation described by a series column and fill it with V";

pattern filler(cnt:lng, v:any_1):bat[:oid,:any_1]
address ARRAYfiller
comment "Create an array value representation of CNT items and fill it with V";

function filler_(cnt:lng, v:any_1)(id:bat[:oid,:lng], cellval:bat[:oid,:any_1]);
	b1 := array.filler(cnt, v);
	# TODO: why is a markH necessary here, but no in array.series?
	b2 := algebra.markH(b1, 0@0);
	b3 := bat.mirror(b2);
    b4 := batcalc.lng(b3);
	return (b4,b2);
end filler_;

@= tilesAggrDecl
module array;

pattern sum(val:@1, any...):lng
address ARRAYtilesSum_@1
comment "Construct the sum over all tiles";

pattern sum(val:@1, any...):dbl
address ARRAYtilesSum_@1
comment "Construct the sum over all tiles";

pattern avg(val:@1, any...):dbl
address ARRAYtilesAvg_@1
comment "Construct the average over all tiles";

pattern min(val:@1, any...):@1
address ARRAYtilesMin_@1
comment "Construct the minimum over all tiles";

pattern max(val:@1, any...):@1
address ARRAYtilesMax_@1
comment "Construct the maximum over all tiles";

module batarray;

# The BAT version of the AGGR functions over array tiles
pattern sum(val:bat[:oid,:@1], any...):bat[:oid,:lng]
address ARRAYtilesSum_@1
comment "Construct the sum over all tiles";

pattern sum(val:bat[:oid,:@1], any...):bat[:oid,:dbl]
address ARRAYtilesSum_@1
comment "Construct the sum over all tiles";

pattern avg(val:bat[:oid,:@1], any...):bat[:oid,:dbl]
address ARRAYtilesAvg_@1
comment "Construct the average over all tiles";

pattern min(val:bat[:oid,:@1], any...):bat[:oid,:@1]
address ARRAYtilesMin_@1
comment "Construct the minimum over all tiles";

pattern max(val:bat[:oid,:@1], any...):bat[:oid,:@1]
address ARRAYtilesMax_@1
comment "Construct the maximum over all tiles";
@
@mal
@:tilesAggrDecl(bte)@
@:tilesAggrDecl(sht)@
@:tilesAggrDecl(int)@
@:tilesAggrDecl(lng)@
@:tilesAggrDecl(flt)@
@:tilesAggrDecl(dbl)@

@- Implementation
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include "gdk.h"
#include "algebra.h"		/* to include BATmin and BATmax */
#include "mtime.h"
#include <math.h>
#include <time.h>

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define array_export extern __declspec(dllimport)
#else
#define array_export extern __declspec(dllexport)
#endif
#else
#define array_export extern
#endif

array_export str ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@= array_defs
array_export str ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *grp, int *series);
array_export str ARRAYtilesSum_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesAvg_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMin_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
array_export str ARRAYtilesMax_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@h
@:array_defs(bte)@
@:array_defs(sht)@
@:array_defs(int)@
@:array_defs(lng)@
@:array_defs(flt)@
@:array_defs(dbl)@

@h
/* The maximum number of series_ that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb_config.h"
#include "mal_client.h"
#include "array.h"

/*----------------------------------------------------------------------------*/

@c
#include "mal.h"
#include "mal_interpreter.h"
@= dim_wrapper_impl
str
ARRAYseries_@1(int *ret, @1 *start, @1 *step, @1 *stop, int *group, int *series)
{
	BAT *bn;
	@1 i, *o;
	BUN cnt= 0;
	int s,g;

	if ( *group < 1 )
		throw(MAL, "array.series", "#groups must be > 0,  got (%d)", *group);
	if ( *series < 1 )
		throw(MAL, "array.series", "#series must be > 0,  got (%d)", *series);

	if ( (*start < *stop && *step > 0) || (*start > *stop && *step < 0) ) {
		cnt =  (BUN) ceil(((*stop * 1.0 - *start) / *step)) * *group * *series ;
	} else
		throw(MAL, "array.series", "Illegal dimension range, [start:step:stop] have values: [@2:@2:@2]", *start, *step, *stop);
	bn = BATnew(TYPE_void, TYPE_@1, cnt);
	if ( bn == NULL)
		throw(MAL, "array.series", MAL_MALLOC_FAIL);

	o = (@1*)Tloc(bn, BUNfirst(bn));

	if ( *start < *stop && *step > 0) {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i < *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	} else {
		for ( s = 0; s < *series; s++)
			for ( i = *start; i > *stop; i += *step)
				for( g = 0; g < *group; g++){
					*o = i;
					o++;
				}
	}
	BATsetcount(bn, cnt);
	BATseqbase(bn,0);
	bn->hdense = TRUE;
	BATkey(bn, TRUE);
	bn->hsorted = 1;
	bn->hrevsorted = (cnt <= 1);
	bn->tsorted = (cnt <= 1 || (*series == 1 && *step > 0));
	bn->trevsorted = (cnt <= 1 || (*series == 1 && *step < 0));
	bn->T->nonil = TRUE;

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

@c
@:dim_wrapper_impl(bte,%d)@
@:dim_wrapper_impl(sht,%d)@
@:dim_wrapper_impl(int,%d)@
@:dim_wrapper_impl(lng,%lld)@
@:dim_wrapper_impl(flt,%f)@
@:dim_wrapper_impl(dbl,%f)@

str
ARRAYfiller_bat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn, *b;
	BUN p, q;
	BATiter bi;
	int *ret = (int*) getArgReference(stk,pci,0);
	int bid = *(int*) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);
	int type = getArgType(mb,pci,2);

	if ((b = BATdescriptor(bid)) == NULL) 
		throw(MAL, "array.filler", RUNTIME_OBJECT_MISSING);
	
	bn = BATnew(b->htype, type, BATcount(b));

	bi = bat_iterator(b);
	BATloop(b,p,q){
		BUNfastins(bn, BUNhead(bi, p), ATOMvarsized(type)?*(str *)val:val);
	}
	BATseqbase(bn,b->hseqbase);
	bn->hdense = BAThdense(b);
	BATkey(bn, BAThkey(b));
	bn->hsorted = b->hsorted;
	bn->hrevsorted = b->hrevsorted;
	bn->tsorted = b->trevsorted = 1;
	(void) cntxt;
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bn;
	int *ret = (int*) getArgReference(stk,pci,0);
	oid i = 0;
	lng cnt = *(lng *) getArgReference(stk,pci,1);
	void *val = (void*) getArgReference(stk,pci,2);
	int type = getArgType(mb,pci,2);

	(void) cntxt;

	if (cnt > (lng)BUN_MAX)
		throw(MAL, "array.filler", "BAT too large");

	if(!(bn = BATnew(TYPE_void, type, cnt)))
		throw(MAL, "array.filler", MAL_MALLOC_FAIL);

	for (i = 0; i < (oid)cnt; i++)
		BUNfastins(bn, &i, ATOMvarsized(type)?*(str *)val:val);

	BATsetcount(bn, cnt);
	BATseqbase(bn, 0);
	bn->hdense = TRUE;
	BATkey(bn, TRUE);
	bn->hsorted = 1;
	bn->hrevsorted = (cnt <= 1);
	bn->tsorted = bn->trevsorted = 1;
	switch(type){
		case TYPE_bit:
			bn->T->nonil = *(bit*)val==bit_nil?FALSE:TRUE;
			break;
		case TYPE_bte:
			bn->T->nonil = *(bte*)val==bte_nil?FALSE:TRUE;
			break;
		case TYPE_sht:
			bn->T->nonil = *(sht*)val==sht_nil?FALSE:TRUE;
			break;
		case TYPE_int:
			bn->T->nonil = *(int*)val==int_nil?FALSE:TRUE;
			break;
		case TYPE_flt:
			bn->T->nonil = *(flt*)val==flt_nil?FALSE:TRUE;
			break;
		case TYPE_dbl:
			bn->T->nonil = *(dbl*)val==dbl_nil?FALSE:TRUE;
			break;
		case TYPE_lng:
			bn->T->nonil = *(lng*)val==lng_nil?FALSE:TRUE;
			break;
		case TYPE_str:
			bn->T->nonil = (strcmp(*(str*)val, str_nil) == 0)?FALSE:TRUE;
			break;
		default:
			throw(MAL, "array.filler", "Unsupported data type");
	}
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

# define AGGR_CLEANUP() \
{ \
	if (bVal) BBPreleaseref(bVal->batCacheid); \
	for (i = 0; i < ndims; i++) { \
		if(bDims[i]) BBPreleaseref(bDims[i]->batCacheid); \
		if(bOffsets[i]) BBPreleaseref(bOffsets[i]->batCacheid); \
	} \
	if(bDims) GDKfree(bDims); \
	if(bDimsT) GDKfree(bDimsT); \
	if(bOffsets) GDKfree(bOffsets); \
	if(bOffsetsT) GDKfree(bOffsetsT); \
	if(dMin) GDKfree(dMin); \
	if(dMax) GDKfree(dMax); \
	if(dSize) GDKfree(dSize); \
}

@= tilesAggr
/* 
 * array.[sum|avg] inputs:
 *  (cell_val:BAT,
 *   dim_1:BAT,tile_member_offset_dim_1:BAT,size_dim_1, ...,
 *   dim_n:BAT,tile_member_offset_dim_n:BAT,size_dim_n)
 */
str
ARRAYtiles@4_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bVal = NULL, *bRes = NULL, **bDims = NULL, **bOffsets = NULL;
	int *ret = (int*) getArgReference(stk,pci,0), i = 0, ndims = 0;
	bit skip = FALSE;
	@1 *bValT = NULL, elm = 0;
	@3 *bResT = NULL;
	int **bDimsT = NULL, **bOffsetsT = NULL;
	BUN p, r, arrcnt = 0, offcnt = 0, cnt = 0;
	@2 sum = 0;
	/* FIXME: this code only deal with INT dimensions */
	int cidx = 0, *dMin = NULL, *dMax = NULL, *dSize = NULL;
	oid arrbase = 0, offbase = 0, vid = 0, mul = 0;

	(void) cntxt;
	(void) mb;

	if ( (pci->argc - pci->retc - 1) % 3 != 0)
		throw(MAL, "array.@5", "Unbalanced argument sets");

	ndims = (pci->argc - pci->retc - 1) / 3;
	bDims = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bDimsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	bOffsets = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bOffsetsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	dMin = (int*) GDKzalloc(sizeof(int) * ndims);
	dMax = (int*) GDKzalloc(sizeof(int) * ndims);
	dSize = (int*) GDKzalloc(sizeof(int) * ndims);
	bVal = BATdescriptor(*(int*)getArgReference(stk,pci,1));
	if(!bDims || !bDimsT || !bOffsets || !bOffsetsT || !dMin || !dMax || !dSize || !bVal) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", RUNTIME_OBJECT_MISSING);
	}
	for (i = 0; i < ndims; i++) {
		bDims[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3));
		bOffsets[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3+1));
		if (!bDims[i] || !bOffsets[i]) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", RUNTIME_OBJECT_MISSING);
		}
		dSize[i] = *(int*)getArgReference(stk,pci,2+i*3+2);
	}
	/* type check the shapes, prepare iterators, and compute the min/max of the dimensions */
	if (!BAThdense(bVal)) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", "head of value BAT must be dense");
	}
	if (bVal->ttype != TYPE_@1) {
		AGGR_CLEANUP();
		throw(MAL, "array.@5", "tail of value BAT must be of type @1");
	}
	arrcnt = BATcount(bVal);
	arrbase = bVal->hseqbase;
	offbase = bOffsets[0]->hseqbase;
	offcnt = BATcount(bOffsets[0]);
	for (i = 0; i < ndims; i++) {
		if (!BAThdense(bDims[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all dimension BATs must be dense");
		}
		if (!BAThdense(bOffsets[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all offset BATs must be dense");
		}
		if (bDims[i]->hseqbase != arrbase || BATcount(bDims[i]) != arrcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "head of all dimension BATs must be aligned with head of value BAT");
		}
		if (bOffsets[i]->hseqbase != offbase || BATcount(bOffsets[i]) != offcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", "heads of all offset BATs must be aligned");
		}
		if (bDims[i]->ttype != TYPE_int || bDims[i]->ttype != bOffsets[i]->ttype) {
			AGGR_CLEANUP();
			throw(MAL, "array.@5", SEMANTIC_TYPE_MISMATCH);
		}
		BATmin(bDims[i], &(dMin[i]));
		BATmax(bDims[i], &(dMax[i]));
	}

	/* access tails as arrays */
	bValT = (@1*) Tloc(bVal, BUNfirst(bVal));
	for (i = 0; i < ndims; i++) {
		bDimsT[i] = (int*) Tloc(bDims[i], BUNfirst(bDims[i]));
		bOffsetsT[i] = (int*) Tloc(bOffsets[i], BUNfirst(bOffsets[i]));
	}

	/* For each anchor piont, compute all cells belong to this tile (bVal.head
	 * is the group nr.) and compute the SUM */
	bRes = 	BATnew(TYPE_void, TYPE_@3, BATcount(bVal));
	bResT = (@3*) Tloc(bRes, BUNfirst(bRes));
	for (p = 0 ; p < arrcnt ; p++) {
		sum = 0; cnt = 0;
		/* loop over all sets of offsets */
		for (r = 0; r < offcnt ; r++) {
			vid = 0; /* index into bVal for the value of a qualified tile member */
			mul = 1;
			skip = FALSE;
			/* for the index of the anchor point on dimension d_i, check if the
			 * resulting index is within the dimension range after having
			 * shifted according this set of offset on dimension d_i.
			 * If yes, update 'vid' so that we know the OID of the qualified
			 * cell at the end; otherwise, skip.
			 */
			/* TODO: we can skip more.  If the j-th value bOffsets[i]
			 * disqualifies the index on dimension d_i, we can jump to the next
			 * of bOffsets[i] which value follows the j-th value */
			for (i = ndims - 1; i >= 0; i--) {
				cidx = bDimsT[i][p] + bOffsetsT[i][r];
				if (dMin[i] <= cidx && cidx <= dMax[i]) {
					vid += mul * (cidx - dMin[i]);
				} else {
					skip = TRUE;
					break; /* skip remaining dimensions */
				}
				mul *= dSize[i];
			}
			if (!skip) {
				elm = bValT[vid];
				if (elm != @1_nil) {
					cnt++;
					sum += elm;
				}
			}
		}
		bResT[p] = (cnt ? @6 : @3_nil);
	}
	AGGR_CLEANUP();
	BATsetcount(bRes, arrcnt);
	BATseqbase(bRes, arrbase);
	bRes->hdense = TRUE;
	BATkey(bRes, TRUE);
	bRes->hsorted = 1;
	bRes->hrevsorted = (arrcnt <= 1);
	bRes->tsorted = (arrcnt <= 1);
	bRes->trevsorted = (arrcnt <= 1);
	BATkey(BATmirror(bRes), FALSE);
	BBPkeepref(*ret = bRes->batCacheid);
	return MAL_SUCCEED;
}
@c
@:tilesAggr(bte,lng,lng,Sum,sum, sum )@
@:tilesAggr(sht,lng,lng,Sum,sum, sum )@
@:tilesAggr(int,lng,lng,Sum,sum, sum )@
@:tilesAggr(lng,lng,lng,Sum,sum, sum )@
@:tilesAggr(flt,dbl,dbl,Sum,sum, sum )@
@:tilesAggr(dbl,dbl,dbl,Sum,sum, sum )@
@:tilesAggr(bte,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(sht,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(int,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(lng,lng,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(flt,dbl,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@
@:tilesAggr(dbl,dbl,dbl,Avg,avg, (dbl)sum / (dbl)cnt )@

@= tilesMinMax
/* 
 * array.[min|max] inputs:
 *  (cell_val:BAT,
 *   dim_1:BAT,tile_member_offset_dim_1:BAT,size_dim_1, ...,
 *   dim_n:BAT,tile_member_offset_dim_n:BAT,size_dim_n)
 */
str
ARRAYtiles@2_@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *bVal = NULL, *bRes = NULL, **bDims = NULL, **bOffsets = NULL;
	int *ret = (int*) getArgReference(stk,pci,0), i = 0, ndims = 0;
	bit skip = FALSE;
	@1 *bValT = NULL, elm = 0;
	@1 *bResT = NULL;
	int **bDimsT = NULL, **bOffsetsT = NULL;
	BUN p, r, arrcnt = 0, offcnt = 0;
	@1 minmax = @1_nil;
	bit first = TRUE;
	/* FIXME: this code only deal with INT dimensions */
	int cidx = 0, *dMin = NULL, *dMax = NULL, *dSize = NULL;
	oid arrbase = 0, offbase = 0, vid = 0, mul = 0;

	(void) cntxt;
	(void) mb;

	if ( (pci->argc - pci->retc - 1) % 3 != 0)
		throw(MAL, "array.@3", "Unbalanced argument sets");

	ndims = (pci->argc - pci->retc - 1) / 3;
	bDims = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bDimsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	bOffsets = (BAT**) GDKzalloc(sizeof(BAT*) * ndims);
	bOffsetsT = (int**) GDKzalloc(sizeof(int*) * ndims);
	dMin = (int*) GDKzalloc(sizeof(int) * ndims);
	dMax = (int*) GDKzalloc(sizeof(int) * ndims);
	dSize = (int*) GDKzalloc(sizeof(int) * ndims);
	bVal = BATdescriptor(*(int*)getArgReference(stk,pci,1));
	if(!bDims || !bDimsT || !bOffsets || !bOffsetsT || !dMin || !dMax || !dSize || !bVal) {
		AGGR_CLEANUP();
		throw(MAL, "array.@3", RUNTIME_OBJECT_MISSING);
	}
	for (i = 0; i < ndims; i++) {
		bDims[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3));
		bOffsets[i] = BATdescriptor(*(int*)getArgReference(stk,pci,2+i*3+1));
		if (!bDims[i] || !bOffsets[i]) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", RUNTIME_OBJECT_MISSING);
		}
		dSize[i] = *(int*)getArgReference(stk,pci,2+i*3+2);
	}
	/* type check the shapes, prepare iterators, and compute the min/max of the dimensions */
	if (!BAThdense(bVal)) {
		AGGR_CLEANUP();
		throw(MAL, "array.@3", "head of value BAT must be dense");
	}
	if (bVal->ttype != TYPE_@1) {
		AGGR_CLEANUP();
		throw(MAL, "array.@3", "tail of value BAT must be of type @1");
	}
	arrcnt = BATcount(bVal);
	arrbase = bVal->hseqbase;
	offbase = bOffsets[0]->hseqbase;
	offcnt = BATcount(bOffsets[0]);
	for (i = 0; i < ndims; i++) {
		if (!BAThdense(bDims[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", "head of all dimension BATs must be dense");
		}
		if (!BAThdense(bOffsets[i])) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", "head of all offset BATs must be dense");
		}
		if (bDims[i]->hseqbase != arrbase || BATcount(bDims[i]) != arrcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", "head of all dimension BATs must be aligned with head of value BAT");
		}
		if (bOffsets[i]->hseqbase != offbase || BATcount(bOffsets[i]) != offcnt) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", "heads of all offset BATs must be aligned");
		}
		if (bDims[i]->ttype != TYPE_int || bDims[i]->ttype != bOffsets[i]->ttype) {
			AGGR_CLEANUP();
			throw(MAL, "array.@3", SEMANTIC_TYPE_MISMATCH);
		}
		BATmin(bDims[i], &(dMin[i]));
		BATmax(bDims[i], &(dMax[i]));
	}

	/* access tails as arrays */
	bValT = (@1*) Tloc(bVal, BUNfirst(bVal));
	for (i = 0; i < ndims; i++) {
		bDimsT[i] = (int*) Tloc(bDims[i], BUNfirst(bDims[i]));
		bOffsetsT[i] = (int*) Tloc(bOffsets[i], BUNfirst(bOffsets[i]));
	}

	/* For each anchor piont, compute all cells belong to this tile (bVal.head
	 * is the group nr.) and compute the SUM */
	bRes = 	BATnew(TYPE_void, TYPE_@1, BATcount(bVal));
	bResT = (@1*) Tloc(bRes, BUNfirst(bRes));
	for (p = 0 ; p < arrcnt ; p++) {
		/* loop over all sets of offsets */
		for (r = 0; r < offcnt ; r++) {
			vid = 0; /* index into bVal for the value of a qualified tile member */
			mul = 1;
			skip = FALSE;
			/* for the index of the anchor point on dimension d_i, check if the
			 * resulting index is within the dimension range after having
			 * shifted according this set of offset on dimension d_i.
			 * If yes, update 'vid' so that we know the OID of the qualified
			 * cell at the end; otherwise, skip.
			 */
			/* TODO: we can skip more.  If the j-th value bOffsets[i]
			 * disqualifies the index on dimension d_i, we can jump to the next
			 * of bOffsets[i] which value follows the j-th value */
			for (i = ndims - 1; i >= 0; i--) {
				cidx = bDimsT[i][p] + bOffsetsT[i][r];
				if (dMin[i] <= cidx && cidx <= dMax[i]) {
					vid += mul * (cidx - dMin[i]);
				} else {
					skip = TRUE;
					break; /* skip remaining dimensions */
				}
				mul *= dSize[i];
			}
			if (!skip) {
				elm = bValT[vid];
				if (elm != @1_nil) {
					if (first) {
						minmax = elm;
						first = FALSE;
					}
					else
						minmax = @4(minmax,elm);
				}
			}
		}
		bResT[p] = minmax;
	}
	AGGR_CLEANUP();
	BATsetcount(bRes, arrcnt);
	BATseqbase(bRes, arrbase);
	bRes->hdense = TRUE;
	BATkey(bRes, TRUE);
	bRes->hsorted = 1;
	bRes->hrevsorted = (arrcnt <= 1);
	bRes->tsorted = (arrcnt <= 1);
	bRes->trevsorted = (arrcnt <= 1);
	BATkey(BATmirror(bRes), FALSE);
	BBPkeepref(*ret = bRes->batCacheid);
	return MAL_SUCCEED;
}
@c
@:tilesMinMax(bte,Min,min,MIN)@
@:tilesMinMax(sht,Min,min,MIN)@
@:tilesMinMax(int,Min,min,MIN)@
@:tilesMinMax(lng,Min,min,MIN)@
@:tilesMinMax(flt,Min,min,MIN)@
@:tilesMinMax(dbl,Min,min,MIN)@
@:tilesMinMax(bte,Max,max,MAX)@
@:tilesMinMax(sht,Max,max,MAX)@
@:tilesMinMax(int,Max,max,MAX)@
@:tilesMinMax(lng,Max,max,MAX)@
@:tilesMinMax(flt,Max,max,MAX)@
@:tilesMinMax(dbl,Max,max,MAX)@
@}
