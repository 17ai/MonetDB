@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f array
@a M.L. Kersten, Y.Zhang, M. Ivanova, A.R. van Ballegooij
@+ Basic array support

Arrays are represented by a series of BATs. One for each dimension
and one for the value. The structure of the dimension is captured in
a shape description, which is an ordered list of tripples
(F,L,S) where for index variable i the constraint F<=i<L holds
and where the step size is S.

In the MAL instructions the shape descriptor should be the last
of the arguments. Since every dimension can be of a different
type, we have to rely on runtime type checking. Of course,
the SciQL compiler already can ensure proper type equality
for each shape tripple.
@{

@mal
module array;
@= grid_mdefs
command grid(i:@1,j:@1,k:@1,l:@1) :bat[:oid,:@1] 
address ARRAYgrid_@1
comment  "Generates a dimension BAT, (grpcount,grpsize,clustersize,offset)";

command grid(i:@1,j:@1,k:@1,l:@1,s:@1) :bat[:oid,:@1] 
address ARRAYgridShift_@1
comment  "Generates a dimension BAT, (grpcount,grpsize,clustersize,offset)
and shift all elements with a factor s";

@mal
@:grid_mdefs(sht)@
@:grid_mdefs(int)@
@:grid_mdefs(lng)@
@:grid_mdefs(flt)@
@:grid_mdefs(dbl)@
@:grid_mdefs(date)@
@:grid_mdefs(daytime)@
@:grid_mdefs(timestamp)@

pattern filler(v:any_1, shape:any...):bat[:oid,:any_1]
address ARRAYfiller
comment "Create an array representation described by the shape vector filled with V";

pattern select(a:bat[:oid,:any_1], shape:any...):bat[:oid,:any_1]
address ARRAYselect
comment "Extract a value portion of an array representation described by two shapes,
one with the structure of A and the other with the portion required.";

pattern index(shape:any...):bat[:oid,:any]...
address ARRAYindex
comment "Extract a dimension portion of an array representation described by two shapes";

pattern getoid(a:bat[:oid, :any_1], shape:any...):bat[:oid,:oid]
address ARRAYgetoid
comment "Extract indices of array cells in their BAT storage.";

pattern replace(v1:bat[:oid, :any_1], idx:bat[:oid, :oid], v2:bat[:oid, :any_1]):bat[:oid,:any_1]
address ARRAYreplace
comment "Replace values in v1 at the positions determined by idx with values in v2, return the modified v1.";

pattern map(v:bat[:oid, :any_1], pos:bat[:oid, :int], dft:any_1):bat[:oid,:any_1]
address ARRAYmap
comment "Map values in 'v' to the positions determined by 'pos', positions in the output BAT without a value from 'v' get the default value 'dft'.";

command product(b:bat[:any_3,:any_1],c:bat[:any_4,:any_2]):bat[:any_1,:any_2]
address ARRAYproduct
comment "Produce an array product";

@- Implementation
@include ../mal/prelude.mx
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include "gdk.h"
#include "algebra.h"		/* to include BATmin and BATmax */
#include "mtime.h"

@= grid_hdefs
#define new_@1_bat(b,s) {(b)=BATnew(TYPE_void,TYPE_@1,(BUN) (s)); \
                         if (b) BATseqbase((b),0);                 }
#define add_@1s(b,n)    {(b)->T->heap.free+=(size_t)(n)*sizeof(@1);\
			                   (b)->batCount+=(BUN)n;\
                         BATkey(BATmirror((b)),0);          \
                         (b)->tsorted = 0;                  }
#define get_@1_ptr(b)   ((@1*)(Tloc(b,BUNfirst((b)))))
@h
@:grid_hdefs(sht)@
@:grid_hdefs(int)@
@:grid_hdefs(lng)@
@:grid_hdefs(flt)@
@:grid_hdefs(dbl)@
@:grid_hdefs(date)@
@:grid_hdefs(daytime)@
@:grid_hdefs(timestamp)@

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb_config.h"
#include "mal_client.h"
#include "array.h"
#include "gdk.h"
#include <math.h>
#include <time.h>

/*----------------------------------------------------------------------------*/

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define array_export extern __declspec(dllimport)
#else
#define array_export extern __declspec(dllexport)
#endif
#else
#define array_export extern
#endif

array_export str ARRAYproduct(int *ret, int *bid, int *rid);
array_export str ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYselect(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYindex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYgetoid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
array_export str ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@= grid_impl
array_export str ARRAYgrid_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset);
array_export str ARRAYgridShift_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift);

static int
fillgrid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	register @1 *ptr;
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = *shift;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	ptr = get_@1_ptr(*out);

	while (i--) {
		register @1 ni = o;

		while (ni < n) {
			register @1 ri = r;

			while (ri--)
				(*(ptr ++)) = ni * s;
			ni++;
		}
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "- done\n");
#endif

	return GDK_SUCCEED;
}

int
grid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = 1;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r));
	if (out == NULL) {
		GDKerror("grid: cannot create the bat (" @2 " BUNs)\n", (i * (n - o) * r));
		return GDK_FAIL;
	}
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, &s);
}

int
gridShift_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r));
	if (*out == 0)
		return GDK_FAIL;
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, shift);
}

@c
@:grid_impl(sht,"%d")@
@:grid_impl(int,"%d")@
@:grid_impl(lng,LLFMT)@
@:grid_impl(flt,"%f")@
@:grid_impl(dbl,"%f")@
@-
To be dealt with differently
@:grid_impl(date,"%s")@
@:grid_impl(daytime,"%s")@
@:grid_impl(timestamp,"%s")@

@c
#include "mal.h"
@= grid_wrapper_impl
str
ARRAYgrid_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	BAT *bn;

	if (grid_@1(&bn, groups, groupsize, clustersize, offset) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridShift_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	BAT *bn;

	if (gridShift_@1(&bn, groups, groupsize, clustersize, offset, shift) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

@c
@:grid_wrapper_impl(sht)@
@:grid_wrapper_impl(int)@
@:grid_wrapper_impl(lng)@
@:grid_wrapper_impl(flt)@
@:grid_wrapper_impl(dbl)@
@-
to be dealt with differently
@:grid_wrapper_impl(date)@
@:grid_wrapper_impl(daytime)@
@:grid_wrapper_impl(timestamp)@

@-
@= arraymultiply
array_export str ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid);
str
ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid){
	BAT *bn, *b, *r;
	BUN p,q, s,t;
	@2 val;
	oid o= oid_nil;
	BATiter bi, ri;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	if( (r= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(TYPE_void, TYPE_@2, BATcount(b)*BATcount(r));
	BATseqbase(bn,0);

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(b,p,q){
		BATloop(r,s,t){
			val = (*(@1*) BUNtail(bi,p)) * (*(@1*)BUNtail(ri,s));
			BUNfastins(bn,&o,&val);
		}
	}
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arraymultiply(sht,lng)@
@:arraymultiply(sht,int)@
@:arraymultiply(int,int)@
@:arraymultiply(int,lng)@
@:arraymultiply(lng,lng)@
@:arraymultiply(flt,flt)@
@:arraymultiply(dbl,dbl)@

str
ARRAYproduct(int *ret, int *bid, int *rid)
{
	BAT *bn, *b, *r;
	BUN p, q, s, t;
	BATiter bi, ri;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if (BATcount(b) > BATcount(r) || (BATcount(b) % BATcount(r)) != BATcount(b)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(r->batCacheid);
		throw(MAL, "array.product", "Illegal argument bounds");
	}
	bn = BATnew(b->ttype, r->ttype, BATcount(r));

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(r, s, t) {
		BATloop(b, p, q) {
			BUNfastins(bn, BUNtail(bi, p), BUNtail(ri, s));
			s++;
		}
		s--;
	}
	/* not sorted at best we have some fixed offset partial sorting */
	bn->hsorted = 0;
	bn->tsorted = 0;
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYfiller(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.filler", PROGRAM_NYI);
}

str
ARRAYselect(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.select", PROGRAM_NYI);
}

str
ARRAYindex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.index", PROGRAM_NYI);
}

str
ARRAYgetoid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.getoid", PROGRAM_NYI);
}

str
ARRAYreplace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.replace", PROGRAM_NYI);
}

str
ARRAYmap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	throw(MAL,"array.map", PROGRAM_NYI);
}

@-
The printing stuff is postponed to the future. Then it also needs
a solution to the GDKout issues.
/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
	This is postpone to the future of arrays.
*/

static int
print_array(BAT *val, ...)
{
	BATiter vali = bat_iterator(val);
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	BUN j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}
	va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	if ( minvector == NULL) 
		goto exit_err_full;
	idxvector = GDKzalloc(sizeof(int) * dims);
	if ( idxvector == NULL) 
		goto exit_err_full;
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	if ( maxvector == NULL) 
		goto exit_err_full;
	lenvector = GDKmalloc(sizeof(ptr) * dims);
	if ( lenvector == NULL) 
		goto exit_err_full;

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);
	if ( arrayindex == NULL)
		goto exit_err_full;

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		BATiter b0i = bat_iterator(batptr[0]);
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(b0i, p);
			register int offset;

			offset = *((int *) BUNtail(b0i, p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == BUN_NONE) {
					GDKerror("print_array: Index %d missing for oid " OIDFMT ".\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) Tloc(batptr[i],p))) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p++;
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				mnstr_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (i < dims && idxvector[i] == 0) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			mnstr_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == BUN_NONE) {
				GDKerror("print_array: Value missing for oid " OIDFMT ".\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, OIDFMT "\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(vali, p), st);
			if (mnstr_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while (i < dims && (++idxvector[i]) == lenvector[i]) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			mnstr_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	mnstr_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

exit_err_full:
	if (arrayindex)
		GDKfree(arrayindex);
exit_err_part:
	if ( maxvector)
		GDKfree(maxvector);
	if (idxvector)
		GDKfree(idxvector);
	if (minvector)
		GDKfree(minvector);
	if (lenvector)
		GDKfree(lenvector);
exit_err_none:
	return GDK_FAIL;
}
@}
