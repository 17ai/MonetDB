#It gets the candidates and projects the dimensions
#With project cells: command algebra.leftfetchjoin(cands:bat[:oid,:oid], dim:ptr, dims:ptr ) :bat[:oid,:any]
command algebra.leftfetchjoin(dimsCands:ptr, oidsCands:bat[:oid,:oid], dim:ptr, dims:ptr ) :bat[:oid,:any]
address ALGdimensionLeftfetchjoin1;
#it is called in updates. It projects all cells 
command algebra.leftfetchjoin(dimsCands:ptr, oidsCands:bat[:oid,:oid], array:ptr) :bat[:oid,:oid]
address ALGdimensionLeftfetchjoin2;
#it gets the candidates and projects a non-dimensional column
#with project cells: command algebra.leftfetchjoin(cands:bat[:oid,:oid], vals:bat[:oid,:any], dims:ptr ) :bat[:oid,:any]
command algebra.leftfetchjoin(candDims:ptr, candBAT:bat[:oid,:oid], vals:bat[:oid,:any], dims:ptr ) :bat[:oid,:any]
address ALGnonDimensionLeftfetchjoin1;
#it is called when projecting a non-dimensional column of an array
command algebra.leftfetchjoin(array:ptr,vals:bat[:oid,:any],dims:ptr) (:bat[:oid,:any], :ptr)
address ALGnonDimensionLeftfetchjoin2;

#subselection in dimensions 
#the first result is the mbr and the second is the oids that satisfy the conditiont
#it is always null but it is used to avoid having to check whether the selection
#is on a dimension or a non-dimension when creating the MAL plan
command algebra.subselect(dim:ptr, dims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
address ALGdimensionSubselect1;
command algebra.thetasubselect(dim:ptr, dims:ptr, val:any, op:str) (:ptr, :bat[:oid,:oid])
address ALGdimensionThetasubselect1;
#the candBAT will be null when the candidates come from selection over dimensional column
#and non-zero when coming from selection over non-dimensional column
command algebra.subselect(dim:ptr, dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
address ALGdimensionSubselect2;
command algebra.thetasubselect(dim:ptr, dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], val:any, op:str) (:ptr, :bat[:oid,:oid])
address ALGdimensionThetasubselect2;
#when two dimensions have been compared to each other (e.g. =, >=, etc.) the result is a ptr with the array of the dimensions
#a bat[:oid,:bit] that shows which cells satisfy the condition. This subselect returns the mbr of the cells that satisfy the 
#condition and a bat with the exact oids that satisfy the condition
command algebra.subselect(dims:ptr, vals:bat[:oid,:bit], low:bit, high:bit, li:bit, hi:bit, anti:bit) (:ptr,:bat[:oid,:oid])
address ALGdimensionSubselect3;

#subselection in non-dimensions
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
address ALGnonDimensionSubselect1;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, val:any, op:str) (:ptr, :bat[:oid,:oid])
address ALGnonDimensionThetasubselect1;
#the candBAT will be null when the candidates come from selection over dimensional column
#and non-zero when coming from selection over non-dimensional column
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
address ALGnonDimensionSubselect2;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], val:any, op:str) (:ptr, :bat[:oid,:oid])
address ALGnonDimensionThetasubselect2;

#projects a dimension
command algebra.projectArray(dim:ptr, dims:ptr) :bat[:oid,:any]
address ALGprojectDimension;
#gets a non-dimensional column of an array and the description of the array 
#and returns just the BAT of the non-dimensional column
command algebra.projectArray(vlas:bat[:oid,:any], dims:ptr) :bat[:oid,:any]
address ALGprojectNonDimension;

#Creates a BAT that contains all cells that satisfied a series of selections on dimensions
command algebra.cellsProject(candDims:ptr, candBAT:bat[:oid,:oid]) :bat[:oid,:oid]
address ALGproject;


#the dim will be ignored. only the array will be used
command aggr.count(array:ptr) :wrd 
address ALGarrayCount;
