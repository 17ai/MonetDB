#it creates the oids out of the qualifying indices of the dimensions (the mbr)
command algebra.materialise(dimsCands:ptr, dims:ptr) :bat[:oid,:oid]
address ALGmaterialise;


#It gets the candidates and projects the dimensions
#With project cells: command algebra.leftfetchjoin(cands:bat[:oid,:oid], dim:ptr, dims:ptr ) :bat[:oid,:any]
#command algebra.leftfetchjoin(dimsCands:ptr, oidsCands:bat[:oid,:oid], dim:ptr, dims:ptr ) :bat[:oid,:any]
#address ALGdimensionLeftfetchjoin1;
command algebra.leftfetchjoin(dimsCands:ptr, dim:ptr, dims:ptr ) :bat[:oid,:any]
address ALGdimensionLeftfetchjoin1;
#leftfetchjoin after selection with non-dimensions
command algebra.leftfetchjoin(oidsCands:bat[:oid,:oid], dimsCands:ptr, dim:ptr, dims:ptr ) :bat[:oid,:any]
address ALGdimensionLeftfetchjoin2;
#it is called in updates. It projects all cells 
command algebra.leftfetchjoin(dimsCands:ptr, array:ptr) :bat[:oid,:oid]
address ALGdimensionLeftfetchjoin3;

#it gets the candidates and projects a non-dimensional column
#with project cells: command algebra.leftfetchjoin(cands:bat[:oid,:oid], vals:bat[:oid,:any], dims:ptr ) :bat[:oid,:any]
#command algebra.leftfetchjoin(candDims:ptr, candBAT:bat[:oid,:oid], vals:bat[:oid,:any], dims:ptr ) :bat[:oid,:any]
command algebra.leftfetchjoin(mbrBAT:bat[:oid,:oid], vals:bat[:oid,:any], dims:ptr ) :bat[:oid,:any]
address ALGnonDimensionLeftfetchjoin1;
#it is called when joining with the array (like tids). It adds NULLs (should add the default value) to missing values
command algebra.leftfetchjoin(array:ptr,vals:bat[:oid,:any], dims:ptr) :bat[:oid,:any]
address ALGnonDimensionLeftfetchjoin2;
#it is called when after joining two arrays on the dimensions
#command algebra.leftfetchjoin(dimsCands:ptr,vals:bat[:oid,:any],dims:ptr) :bat[:oid,:any]
#address ALGnonDimensionLeftfetchjoin3;

#subselection in dimensions 
#the first result is the mbr and the second is the oids that satisfy the conditiont
#it is always null but it is used to avoid having to check whether the selection
#is on a dimension or a non-dimension when creating the MAL plan
#command algebra.subselect(dim:ptr, dims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
#address ALGdimensionSubselect1;
#command algebra.thetasubselect(dim:ptr, dims:ptr, val:any, op:str) (:ptr, :bat[:oid,:oid])
#address ALGdimensionThetasubselect1;
#
#A selection over a dimension always results in a new array with updated dimension
command algebra.subselect(dim:ptr, dims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) :ptr
address ALGdimensionSubselect1;
command algebra.thetasubselect(dim:ptr, dims:ptr, val:any, op:str) :ptr
address ALGdimensionThetasubselect1;
#the candBAT will be null when the candidates come from selection over dimensional column
#and non-zero when coming from selection over non-dimensional column
#command algebra.subselect(dim:ptr, dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], low:any, high:any, li:bit, hi:bit, anti:bit) (:ptr, :bat[:oid,:oid])
#address ALGdimensionSubselect2;
#command algebra.thetasubselect(dim:ptr, dims:ptr, candDims:ptr, candBAT:bat[:oid,:oid], val:any, op:str) (:ptr, :bat[:oid,:oid])
#address ALGdimensionThetasubselect2;
#
#The candidates is an array with some other dimension already updated
command algebra.subselect(dim:ptr, dims:ptr, candDims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) :ptr
address ALGdimensionSubselect2;
command algebra.thetasubselect(dim:ptr, dims:ptr, candDims:ptr, val:any, op:str) :ptr
address ALGdimensionThetasubselect2;
##when two dimensions have been compared to each other (e.g. =, >=, etc.) the result is a ptr with the array of the dimensions
##a bat[:oid,:bit] that shows which cells satisfy the condition. This subselect returns the mbr of the cells that satisfy the 
##condition and a bat with the exact oids that satisfy the condition
#command algebra.subselect(dims:ptr, vals:bat[:oid,:bit], low:bit, high:bit, li:bit, hi:bit, anti:bit) (:ptr,:bat[:oid,:oid])
#address ALGdimensionSubselect3;

#subselection in non-dimensions. It is like any ther selection
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) :bat[:oid,:oid]
address ALGnonDimensionSubselect1;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, val:any, op:str) :bat[:oid,:oid]
address ALGnonDimensionThetasubselect1;
#subselect when having selections only to non-dimensional columns but more than one
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, candBAT:bat[:oid,:oid], low:any, high:any, li:bit, hi:bit, anti:bit) :bat[:oid,:oid]
address ALGnonDimensionSubselect2;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, candBAT:bat[:oid,:oid], val:any, op:str) :bat[:oid,:oid]
address ALGnonDimensionThetasubselect2;
#when having selections over dimensions before the selection over the non-dimenions them candDims is the mbr of the dimensions
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, candDims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) (:bat[:oid,:oid], :ptr)
address ALGnonDimensionSubselect3;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, candDims:ptr, val:any, op:str) (:bat[:oid,:oid], :ptr)
address ALGnonDimensionThetasubselect3;
#when having selections over dimensions and multiple selections over non-dimensions the candidates are the oids qualifying in
#the selections over the non-dimensions and the mbr qualifying in the selections over the dimenisons.
command algebra.subselect(vals:bat[:oid,:any], dims:ptr, candBAT:bat[:oid,:oid], candDims:ptr, low:any, high:any, li:bit, hi:bit, anti:bit) (:bat[:oid,:oid], ptr)
address ALGnonDimensionSubselect4;
command algebra.thetasubselect(vals:bat[:oid,:any], dims:ptr, candBAT:bat[:oid,:oid], candDims:ptr, val:any, op:str) (:bat[:oid,:oid], ptr)
address ALGnonDimensionThetasubselect4;


#joining two dimensions
command algebra.subjoin(diml:ptr, dimsl:ptr, dimr:ptr, dimsr:ptr) (:ptr,:ptr)
address ALGsubjoin1;
#joining more than two dimensions
command algebra.subjoin(candDimsl:ptr, diml:ptr, dimsl:ptr, candDimsr:ptr, dimr:ptr, dimsr:ptr) (:ptr,:ptr)
address ALGsubjoin2;

command algebra.subrangejoin(diml:ptr, dimsl:ptr, dimr1:ptr, dimr2:ptr, dimsr:ptr, sl:bat[:oid,:oid],sr:bat[:oid,:oid],li:bit,hi:bit,estimate:lng) (:ptr,:ptr)
address ALGsubrangejoin1
comment "Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2";

command algebra.subrangejoin(diml:ptr, dimsl:ptr, dimr1:ptr, dimr2:ptr, dimsr:ptr, candDimsl:ptr, candDimsr:ptr,li:bit,hi:bit,estimate:lng) (:ptr,:ptr)
address ALGsubrangejoin2
comment "Range join: values in l and r1/r2 match if r1 <[=] l <[=] r2";

#projects a dimension
command algebra.projectArray(dim:ptr, dims:ptr) :bat[:oid,:any]
address ALGprojectDimension;
#gets a non-dimensional column of an array and the description of the array 
#and returns just the BAT of the non-dimensional column
command algebra.projectArray(vlas:bat[:oid,:any], dims:ptr) :bat[:oid,:any]
address ALGprojectNonDimension;

#Creates a BAT that contains all cells that satisfied a series of selections on dimensions
command algebra.cellsProject(candDims:ptr, candBAT:bat[:oid,:oid]) :bat[:oid,:oid]
address ALGproject;

command algebra.mbr(oidsCands:bat[:oid,:oid], dimsCands:ptr, dims:ptr) :ptr
address ALGmbr1;
#No selection over dimensions
command algebra.mbr(oidsCands:bat[:oid,:oid], dims:ptr) :ptr
address ALGmbr2;


command algebra.outerjoin(l:bat[:oid,:oid], r:bat[:oid,:oid]) :bat[:oid,:oid]
address ALGouterjoin;

#the dim will be ignored. only the array will be used
command aggr.count(array:ptr) :wrd 
address ALGarrayCount;

command aggr.subsum(X_7:bat[:oid,:any],X_8:ptr,Y_8:ptr) :bat[:oid,:hge]
address ARRsubsum;

module group;
command group.subgroup(dim:ptr, array:ptr, l:int, h:int) (:ptr,:ptr)
address ARRgroup;

command group.projectGroups(groups:ptr, dim:ptr, dims:ptr ) :bat[:oid,:any]
address ARRprojectGroups;


command algebra.qqr_decomposition(vals:bat[:oid,:any], dims:ptr) (:bat[:oid,:dbl], :ptr)
address ALGnonDimensionQRDecomposition
comment "QQR decomposition";

