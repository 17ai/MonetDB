@f Mrecover
@a M. L. Kersten and Peter Boncz
@v 1.0
@* The Crash Recovery Utility
@+ Manual Page
@T
After a system crash the internal administration may be inconsistent.
The {\tt Mrecover} utility performs an analysis to assess damage and 
repairs the situation.
 
@- Usage
@T
\begin{verbatim}
Mrecover -db <name> 
\end{verbatim}
@{
@+ Implementation 
@c
#include <gdk.h>
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */


#define AMODE	0755 

extern void dbargs(int argc, char **argv, char *args[4]);
extern void chkDir();
extern void chkDir_recursive(str dirname);
extern void chkTmp();
extern void chkBAT();
extern void chkBBP();
extern int chkFile(char *nme, char *extension, int i);

void usage() {
	printf("usage: Mrecover -db <dbname> \n");
}

int main(int argc, char **argv){
        char *args[5];
	char buffer[2000];
@-
Malloc options are set to avoid memory fragmentation. These options
should be copied from monet/main.c
@c
#if !(defined(WIN32) || defined(LINUX))
	mallopt(M_MXFAST, 1024);
	mallopt(M_NLBLKS, 100);
	mallopt(M_GRAIN, 128);
#ifdef IRIX
	mallopt(M_BLKSZ, 8*1024);
#endif
#endif
        dbargs(argc,argv,args);
        GDKinit(3,args);
	GDKrecovery= 1;
	printf("Recovery of database %s in progress\n",args[3]);
	sprintf(buffer,"%s/core",GDKdirStr);
	unlink(buffer);

	chkDir();
	chkBBP();
	printf("\nDATABASE RECOVERED. GOOD LUCK\n");
	BBPdir();
	GDKexit();
	return 0;
}
@-
First action is to read and check the BBP table.
@c
void chkBBP() {
	int i;
	printf("Repairing Bat Buffer Pool\n");
	BBPclear(0, TRUE);
	for(i=1;i<BBPsize;i++) {
		char *logical = BBP_logical(i);
		char *physical = BBP_physical(i);

		if(logical && physical==NULL){
			printf("Physical part missing: %s, ", logical);
			printf(" Clearing the entry\n");
			BBPclear(i, TRUE);
		} else if (physical && logical==NULL){
			printf("Logical part missing:%s, ", physical); 
			printf(" Clearing the entry\n");
			BBPclear(i, TRUE);
		} else if (physical && chkFile(physical,"desc",i)) {
			chkFile(physical,"buns",i);
		}
	} 
}

int chkFile(char *nme, char *extension, int i) {
	FILE *f,*fc;
	int r=1;
	char buf[200];
	sprintf(buf,"%s.Z",extension);
	
	f= (FILE*) GDKfilelocate(nme,"r",extension);
	fc= (FILE*) GDKfilelocate(nme,"r",buf);
	if(f && fc){
		printf("Replicate storage %s%s and %s%s\n",
			nme,extension,nme,buf);
		printf(" Remove one by hand \n");
	} else
	if(f==NULL && fc==NULL){
		printf("File missing: %s%s, ",nme,extension);
		printf(" Clear BBPentry\n");
		BBPclear(i, TRUE); 
		r=0;
	}
	if(f) fclose(f); if(fc) fclose(fc);
	return r;
}
@-
The next phase inspects the directory for files that look like a BAT, but
which are not stored in the BBP table. Repair simply means addition.
In particular, it should try to cope with old-fashioned directory structures
and role the database structure to a new version.
@c

void chkDir_recursive(str dirname) {
	char msg[200], *s, *t;
	DIR *dp;

	sprintf(msg,"%s/bat/%s", GDKdirStr, dirname);
	printf("scanning the directory %s\n",msg);

	dp= opendir(msg);
	if( dp== (DIR*) NULL){
		printf("Could not open database directory %s\n",msg);
		return;
	}
	for(;;){
		struct dirent *dirp= (struct dirent*) readdir(dp);

		if( dirp== (struct dirent *) NULL){
			closedir(dp);
			break;
		}
		s = dirp->d_name;
		if ((s[0] >= '0' && s[0] <= '7' && s[1] >= '0' && s[1] <= '7' && s[2] == 0) ||
		    (strcmp(s, "LEFTOVERS") == 0))
		{
			long_str path;
			strcpy(path, s); strcat(path,"/");
			chkDir_recursive(path);
			continue;
		} 
		t = (char*) strchr(dirp->d_name,'.');
		if(t && (strcmp(t,".desc")==0 || strcmp(t,".desc.Z")==0)){	
			*t=0;
			if(BBPindex(s)) {
				continue;
			}
			if (s[0] != 't' || s[1] != 'm' || s[2] != 'p' || s[3] != '_') {
				int i = BBPentry(dirname, s, PERSISTENT);
				BAT *b = BATload(s);
				if (b == NULL) {
					BBPclear(i, TRUE); /* failed to recuperate it */
				} else {
					BBPreclaim(b);
				} 
			}
		}
	}
}

void chkDir() {
	char buffer[2048];
	long_str msg;

	chkDir_recursive("/");
@-
Version 3.04 uses the notion of <db>/users/<usr> for collectin
specific user items
@c
	sprintf(msg, "%s/users", GDKdirStr);
	if( opendir(msg) == (DIR*) NULL){
                fprintf(stderr,"Create users directory\n");
                sprintf(buffer,"%s/users",GDKdirStr);
                if( mkdir(buffer,AMODE))
                fprintf(stderr,"failed to create %s\n",buffer);

                /* copy standard prelude en procs files to local place */
                sprintf(buffer,"cp -r %s/share/Monet/* %s/users",
			MONET_PREFIX,GDKdirStr);
                system(buffer);
                printf("%s\n", buffer);

	}
}
	
@- Common utilities
The arguments are handled by GDKinit already. So we don't have to do much.
@c
void dbargs(int argc, char **argv, char *args[4]){
 	int i; 

	args[0] = GDKstrdup("-db");
	if(argc<3) usage();
	for(i=1;i<argc;i++)
	if( strcmp(argv[i],"-db")==0)
		args[1] = argv[++i];
        
	args[2]= GDKstrdup("-recover");

        if( args[1] == 0) {
                printf("database name missing\n");
		exit(0);
        }
}
@}
