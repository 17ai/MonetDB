@t MAL object management
@a M.L. Kersten
@* MAL object management
The key objects managed by Monet are the persistent BATs, which
call for an efficient scheme to make them accessible for manipulation
in the MAL procedures taking into account a possibly hostile
parallel access.

Most kernel routines produce BATs as a result, which will be referenced 
from the runtime stack. They should be garbage collected as soon as
deemed possible to free-up space. By default, temporary results are
garbage collected before returning from a MAL function.

Furthermore, clients sessions often come with a global scope of
variable settings, which are garbage collected only at the end
of a session. Access to these global variables should be easy,
but they should also provide protection against concurrent update
when the client wishes to perform parallel processing.

Finally, databases, languages, etc. may define constants and variables
accessible to all hierarchical related clients.

The approach taken is to rely on the concept of object spaces
as pioniered in Lynda and -later- JavaSpaces.
Every module in the Monet virtual machine can act as an object space.

This space is managed by functions defined in the module.
The space can be extended with a new object using the function
'deposit(nme:str,v:any'). An exception is raised when the object
is already known.

A copy of an object can be obtain using the
pattern 'take(v:any,nme:str)', where 'nme' denotes the object
of interest and 'v' the local name where the copy is stored.
If the type associated with 'v' does not comply with the
object's type, an exception is raised.
[at a later stage we may use regular expressions for the names]

The object is given back to the space manager calling 'release(nme:str,v:any)'.
It may update the content of the repository accordingly.
However, the local copy of the variable is gone immediately.

Finally, the object manager can be requested to 'discard(nme:str)'
an object completely.

@+
Concurrency control, replication services, as well as access
to remote stores is part of an object space definition.
Depending on the intended semantics, the object space manager
(implementations of deposit(), take(), release() and discard() )
may keep track of the clients holding links to this members, 
provide a traditional 2-phase
locking scheme, optimistic control, or check-out/check-in scheme.
In all cases, these management issues are transparant to the
main thread (=client) of control, which operates on a temporary
snapshot. For the time being we realize the managers as critical
code sections, i.e. one client is permitted access to the space
at a time.

Example: consider the client function:
@T
function myfcn():void;
	b:bat := mil.take("mytable");
	sql.take(c:bat[int,str], "person","age");
	d:= intersect(b,c);
	print(d);
	take(u:str,"user");
	print(u);
	release(user);
end function;
@-
The function obtains a copy from the local persistent bat space,
much like bat-names are resolved under MIL semantics. The second
statement uses the default schema to resolve the location of a
column. The result bat 'd' is temporary and disappears upon garbage
collection or explicit 'destroy'. The variable 'u' is looked up
as the string object user.

The type parameters in the take() calls enable early type checking
Failure to find a properly typed object leads to an exception.
The type indicator for a take instruction may be ommitted, but
this defers type resolution to execution time.

Note, possible extensions for the object space technique is
to introduce e.g. xml.take() which converts an XML document to a BAT,
jpeg.take() similer for an image.

@+ Space management
Every client receives a single object space (client.take()) upon initialization.
This space is placed subordinate to any space introduced by the
system administrator. It will contain all global client data and is not
persistent (?)

This is typically part of running startup
scripts. Variables are added to the object spaces using the export()
function call, which performs the authorization and possible definition
clashes.
@
@-
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */

#ifndef _MAL_BIND_H
#define _MAL_BIND_H
#include "mal_instruction.h"
#include "mal_stack.h"

typedef struct BOX{        /* see objectspace.mx */
        MT_Lock lock;           /* provide exclusive access */
        MalBlkPtr sym;		
        MalStkPtr stk;
        struct BOX *outer;
} *Box, BoxRecord;

mal_export void initBox();
mal_export Box newBox(Box outer);
mal_export void freeBox(Box obj);
mal_export void deleteBox(Box obj);

mal_export void printSomeBox(FILE *fd, int k);
mal_export void printBox(FILE *fd, Box obj);
#endif /* _MAL_BIND_H */
@-
The hierarchy of object spaces ends at the root of the tree.
This is a dummy element and should contain system-wide objects
only.
@= newBOX
	obj= (Box) GDKmalloc(sizeof(BoxRecord));
	bzero((char*) obj, sizeof(BoxRecord));
	obj->sym= newMalBlk();
	obj->stk = newGlobalStack(MAXVARS);
@-
@c
#include "mal_box.h"

#define MAXSPACES 64	/* >MAXCLIENTS !! */
Box boxes[MAXSPACES];

void initBox()
{
	Box obj;
	@:newBOX@
	boxes[0]= obj;
}

Box newBox(Box outer){
	Box obj;
	int i;
        MT_set_lock(mal_contextLock, "deleteBox");
	@:newBOX@
	obj->outer = outer;

	for(i=0; i<MAXSPACES; i++)
	if( boxes[i]== NULL) {
		boxes[i]= obj;
		break;
	}
	if( i== MAXSPACES)
		GDKerror("too many object spaces\n");
        MT_unset_lock(mal_contextLock, "deleteBox");
	return obj;

}
void freeBox(Box obj){
	freeMalBlk(obj->sym);
	freeStack(obj->stk);
}
void deleteBox(Box obj){
	int i,j;
        MT_set_lock(mal_contextLock, "deleteBox");
	for(i=j=0;i<MAXSPACES;i++){
		if( boxes[j] == obj)
			freeBox(obj);
		else boxes[i] = boxes[j++];
	}
        MT_unset_lock(mal_contextLock, "deleteBox");

}
@- Binding 
Each time a user wishes to access a global variable, it
should call the take routine.
The default implementation is given below, we expect 
different versions to emerge.
@c
int takeObject(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	return GDK_SUCCEED;
}
int releaseObject(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	return GDK_SUCCEED;
}
@-
Utilities for the debugger permit dumping of all the object
spaces.
@c
void printBox(FILE *fd, Box obj)
{ printStack(fd,obj->sym,obj->stk); }

void printSomeBox(FILE *fd, int k)
{
	if( boxes[k]== 0){
		GDKerror("printSomeBox:illegal space id\n");
	} else printBox(fd,boxes[k]);
}
