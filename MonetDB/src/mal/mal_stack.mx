@f mal_stack
@a M. L. Kersten

@* MAL runtime stack
The runtime context of a MAL procedure is allocated on the runtime stack
of the corresponding interpreter.
Access to the elements in the stack are through index offsets,
determined during MAL procedure parsing.
This method has been proven highy efficient compared to using 
individual GDKmalloci calls.

Unlike Monet Version 4, the scope administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)

The variable names and types are kept in the stack to ease debugging.
The underlying string value need not be garbage collected.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_STACK_H_
#define _MAL_STACK_H_
#include "mal_type.h"
#include "mal_instruction.h"

typedef struct MALSTK {
	int	pc;		/* current instruction */
	int 	stksize;
	int	stktop;
	int	exception;	/* last exception encountered */
	char	cmd;		/* debugger communication */
	struct MALSTK *up;	/* stack trace list */
	struct MALSTK *down;	/* stack trace list */
	struct MALBLK *blk;	/* associated definition */
	ValRecord stk[1];
}MalStack, *MalStkPtr;

#define STACKINCR	128
#define MAXGLOBALS	4 * STACKINCR
#define stackSize(CNT) (sizeof(ValRecord)*(CNT) + sizeof(MalStack))
#define newStack(S,CNT)	S= (MalStkPtr) alloca(stackSize(CNT));\
			bzero((char *) S, stackSize(CNT));\
			(S)->stksize=CNT;
	
#define newFrame(S,Ssize,Top,Cnt) S= reallocStack(S,&(Ssize),Top,Cnt)


#define VARfreeze(X)	if(X){X->frozen=TRUE;}
#define VARfixate(X)	if(X){X->constant=TRUE;}

#endif /* _MAL_STACK_H_ */
@-
The clearStack operation throws away any space occupied by variables
Freeing the stack itself is automatic upon return from the interpreter
context. Since the stack is allocated and zeroed on the calling stack,
it may happen that entries are never set to a real value.
This can be recognized by the vtype component
@c
#include "mal_stack.h"

MalStkPtr reallocStack(MalStkPtr s, int cnt){
	int k= s->stksize;
	MalStkPtr old= s; 

	if( s->stksize - s->stktop >cnt ) return s;
	k = k+ ((cnt/STACKINCR)+1) * STACKINCR;
	newStack(s, k);
	memcpy(s, old, stackSize(s->stksize)); 
	s->stksize = k;
	GDKfree(old);
	return s;
}
void clearStack(MalStkPtr s){
	ValPtr v;
	int i = s->stktop;

	for( v= s->stk; i >=0; i--, v++)
	if (ATOMextern(v->vtype) && v->val.pval) {
		printf("freeing %s\n",v->val.sval);
                GDKfree(v->val.pval);
        }
}
