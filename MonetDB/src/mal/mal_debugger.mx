@t The MAL debugger
@a M.L. Kersten
@* Introduction
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a gdb-like text-based debugger.
A global table of breakpoints is maintained. Although a little space
consumptive, it is the easiest to maintain and much less expensive
as reserving debugger space in each instruction.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal.h"
#include "mal_stack.h"
#include "mal_function.h"
#include "mal_client.h"

#define MAXBREAKS 32

typedef struct {
	MalBlkPtr 	brkBlock[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	char		brkCmd[MAXBREAKS];
	str		brkVarName[MAXBREAKS];
	int		brkTop;
} gdbStateRecord, *gdbState;

mal_export void gdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, char cmd);
mal_export void gdbShowBreakpoints(Client cntxt);
mal_export char gdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd);
mal_export char gdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd);
mal_export void gdbHelp(FILE *f);
mal_export void printStackElm(FILE *f, VarPtr n, ValPtr v);
mal_export void printStack(FILE *f, MalBlkPtr mb, MalStkPtr s);

#define gdbPrompt() fprintf(cntxt->fdout,"mdb> ")

#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"

gdbStateRecord gdbTable[MAL_MAXCLIENTS];

char isBreakpoint(Client cntxt, InstrPtr p){
	int i;

	/* printf("test breakpoint %d\n", p->argv[0]);*/
	for(i=0;i<gdbTable[cntxt->idx].brkTop;i++)
	if( p->argv[0]== gdbTable[cntxt->idx].brkVar[i])
		return gdbTable[cntxt->idx].brkCmd[i];
	return 0;
}
void gdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd){
	int i;
	char *c=name;
	InstrPtr p;
	gdbState gdb= gdbTable + cntxt->idx;

	while(*c && (isalnum(*c) || *c=='$' || *c=='_')) c++;
	*c = 0;
	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( p->argc>0 &&  strcmp(getDestName(mb,p),name)==0){
			gdbSetBreakpoint(cntxt,mb,p,cmd);
			return;
		}
	}
}

void gdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, char cmd)
{	gdbState gdb= gdbTable + cntxt->idx;
	gdb->brkBlock[gdb->brkTop] = mb;
	gdb->brkVar[gdb->brkTop] = p->argv[0];
	gdb->brkVarName[gdb->brkTop] = mb->var[p->argv[0]].name;
			gdb->brkCmd[gdb->brkTop] =cmd;
	if( gdb->brkTop+1< MAXBREAKS) 
		gdb->brkTop++;
}
void gdbShowBreakpoints(Client cntxt)
{	int i;
	gdbState gdb= gdbTable + cntxt->idx;

	for(i=0;i<gdb->brkTop;i++)
	printf("breakpoint %s [%d]\n",gdb->brkVarName[i], gdb->brkVar[i]);
}

void gdbClrBreakpoint(Client cntxt, InstrPtr p)
{	int i,j=0;
	gdbState gdb= gdbTable + cntxt->idx;

	for(i=0;i<gdb->brkTop;i++){
		gdb->brkVar[j]= gdb->brkVar[i];
		gdb->brkVarName[j]= gdb->brkVarName[i];
		gdb->brkCmd[j]= gdb->brkCmd[i];
		gdb->brkBlock[j]= gdb->brkBlock[i];
		if( gdb->brkVar[i] != p->argv[0]) j++;
	}
	gdb->brkTop = j;
}

#define skipBlanc(X)	while(isspace(*X)) X++;
#define skipNonBlanc(X)	while(!isspace(*X)) X++;
#define skipWord(X)	skipNonBlanc(X); skipBlanc(X);

void printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk){
	InstrPtr p;
	int k;

	p= getInstrPtr(mb, stk->pc);
	if( p != NULL){
		gdbPrompt();
		promptInstruction(cntxt->fdout,mb,p);
		p= getInstrPtr(mb, 0);
		fprintf(cntxt->fdout," at #%d in %s(", stk->pc, getFcnName(mb));
		for(k=1; k<p->argc; k++){
			VALprint(cntxt->fdout, &stk->stk[p->argv[k]]);
			if( k < p->argc-1 ) fprintf(cntxt->fdout,",");
		}
		fprintf(cntxt->fdout,")\n");
	}
}

@-
The debugger structure is inherited from GDB.
The routine gdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.
@c
char gdbCommand(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd){
	char buf[1024],*b;
	FILE *out = cntxt->fdout;
	FILE *in  = cntxt->fdin;

	if( p!= NULL){
		fprintf(out,"mdb> ");
		printInstruction(out,mb,p);
	}
	do{
	gdbPrompt();
	fflush(out);
	if( fgets(buf,1024,in)== NULL || feof(in) ){
		return 'q';
	}
	b= buf;
	skipBlanc(b);
	switch(*b){
	case 0: return cmd;
	case 'c': if( strcmp("call",b)==0){
			GDKerror("call instruction not yet implemented\n");
		 }
		 return 'c';
	case 'h': gdbHelp(out); break;
	case 'q': return 'q';/* return from this procedure */
	case 'n': /* next */
	case 's': /* next */
		return buf[0];
	case 'S': /* display symbol table */
		skipWord(b);
		skipBlanc(b);
		debugScope(b);
		break;
	case 't': /* trace breakpoint */
	case 'b':
		skipWord(b);
		if(*b==0) { gdbShowBreakpoints(cntxt); continue;}
		if( !isspace(*b) && *b != 0){
			/* set breakpoints by name */
			gdbSetBreakpointName(cntxt,mb,b,*b);
		} else {
			gdbSetBreakpoint(cntxt,mb,p,*b);
		}
		continue;
	case 'd':
		/* get rid of break point */
		if( strncmp(b,"do",2)==0 && stk->down!= NULL){
			printf("go down the stack\n");
			stk= stk->down;
			mb = stk->blk;
			break;
		}
		skipWord(b);
		if(*b && !isspace(*b)){
			fprintf(out,"breakpoint (not yet) deleted\n");
		} else {
			gdbClrBreakpoint(cntxt,p);
		}
		continue;
	case 'p':
	{	 int i;
		char *t;
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			fprintf(out,"Symbol not found\n");
		} else{
			printStackElm(out,mb->var+i,stk->stk+i);
		}
		continue;
	}
	case 'u':
		if( stk->up == NULL) break;
		printf("go up the stack\n");
		stk= stk->up;
		mb = stk->blk;
		printCall(cntxt,mb,stk);
		continue;
	case 'v': /* variable bindings */
		gdbPrompt();
		if( p != NULL){
			fprintf(out,"mdb> at %s:#%d ",
				getInstrPtr(mb,0)->fcnname, p->pc);
			printInstruction(out,mb,p);
		}
		printStack(out,mb,stk);
		continue;
	case 'w':
	{	MalStkPtr w;
		MalBlkPtr mw=mb;
		for(w=stk;w!= NULL; w=w->up){
			mw = w->blk;
			printCall(cntxt,mw,w);
		}
		continue;
	}
@-
While debugging it should be possible to inspect the symbol 
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
	case 'L': 
	case 'l': /* list the current code block */
	{	str modname, fcnname;
		Symbol fsym,fs;
		int i;

		mal_xlisting= *b=='L';
		skipWord(b);
		if( *b!= 0){
			b[strlen(b)-1] =0;
			modname=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(MAL_scope,modname);
				if( fsym==0) {
					fprintf(out,"scope not found\n");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printSignature(out,fs);
						fs= fs->peer;
					}
				}
				continue;
			} else {
				*fcnname = 0;
				fcnname ++;
			}
			/* display the overloaded symbol definition */
			if( displaySymbol(out,modname,fcnname)==0){
				fprintf(out,"Symbol '%s.%s' not found\n",
					modname,fcnname);
				continue;
			} else continue; 
			printFunction(out,fsym->def);
			continue;
		}
		printFunction(out,mb);
		continue;
	}
	case 'r': /* reset program counter */
		fprintf(cntxt->fdout,"restart with current stack\n");
		return 'r';
	default:
		gdbPrompt();
		fprintf(out,"debugger command expected\n");
		gdbHelp(out);
	}
	} while(1);
	return 0;
}
char gdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p,char cmd){
	char newcmd;
	switch(cmd){
	case 'c':
		if( newcmd= isBreakpoint(cntxt,p) ){
			/* printf("stop at line %d\n",stk->pc);*/
			if( newcmd == 't') printf("show value nyi \n");
			cmd= gdbCommand(cntxt,mb,stk,p,newcmd);
		} /* else printf("skip line %d\n", stk->pc);*/
		break;
	case 's': case 'n':
		cmd= gdbCommand(cntxt,mb,stk,p,cmd);
		break;
	case 'r': cmd = 'n';
	}
	return cmd;

}
@+ Utilities
DUmping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes.
Beware that a stack frame need not be initialized with null values.
Instead, it has been zeroed upon creation.
@c
void printStack(FILE *f, MalBlkPtr mb, MalStkPtr s){
        ValPtr v= s->stk;
        int i = 0;

        fprintf(f,"Stack pc=%d size=%d top=%d\n",s->pc,s->stksize,s->stktop);
        for( ; i<s->stktop ; i++,v++){
		printStackElm(f, mb->var+i, s->stk+i);
        }
}

void printStackElm(FILE *f, VarPtr n, ValPtr v){
	str nme;
	fprintf(f,"[%d] %s\t= ",n->offset,n->name);
	if( n->isaconstant) {
		VALprint(f,&n->cstvalue);
	} else {
	 	VALprint(f, v);
	}
	nme= malTypeName(n->type);
	fprintf(f,":%s%s%s", nme, (n->accessmode?" protected":""),
			(n->isaconstant?" constant":""));
	/*fprintf(f,"type %d <-%d",getGDKtype(n->type),v->vtype);*/
	printf("\n");
	GDKfree(nme);
}
@-
Some utilities for the debugger 
@c
void gdbHelp(FILE *f){
	fprintf(f,"next	-- Advance to next statement\n");
	fprintf(f,"continue -- Continue program being debugged\n");
	fprintf(f,"break -- set breakpoint on current instruction\n");
	fprintf(f,"break <var> -- break on assignment to <var>\n");
	fprintf(f,"step -- advance to next MAL instruction\n");
	fprintf(f,"Symbols -- display the symbol table \n");
	fprintf(f,"quit -- leaver debugger\n");
	fprintf(f,"list -- list current program block\n");
	fprintf(f,"variables -- print variable bindings\n");
	fprintf(f,"where -- print stack trace\n");
	fprintf(f,"print <var> -- display value of a variable\n");
	fprintf(f,"run -- restart current procedure\n");
	fprintf(f,"help -- this message\n");
}
