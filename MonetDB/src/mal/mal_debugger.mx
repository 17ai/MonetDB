@t The MAL debugger
@a M.L. Kersten
@* Introduction
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a gdb-like text-based debugger.
A global table of breakpoints is maintained. Although a little space
consumptive, it is the easiest to maintain and much less expensive
as reserving debugger space in each instruction.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal.h"
#include "mal_stack.h"
#include "mal_function.h"
#include "mal_client.h"

#define MAXBREAKS 32

typedef struct {
	MalBlkPtr 	brkBlock[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	char		brkCmd[MAXBREAKS];
	str		brkVarName[MAXBREAKS];
	int		brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, char cmd);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export char mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd);
mal_export char mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd);
mal_export void mdbHelp(FILE *f);
mal_export void printStackElm(FILE *f, VarPtr n, ValPtr v);
mal_export void printStack(FILE *f, MalBlkPtr mb, MalStkPtr s);

mal_export void mdbToggle(Client c, int v);

#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_debugger.h"

mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char isBreakpoint(Client cntxt, InstrPtr p){
	int i;

	/* printf("test breakpoint %d\n", p->argv[0]);*/
	for(i=0;i<mdbTable[cntxt->idx].brkTop;i++)
	if( p->argv[0]== mdbTable[cntxt->idx].brkVar[i])
		return mdbTable[cntxt->idx].brkCmd[i];
	return 0;
}
void mdbSetBreakpointName(Client cntxt, MalBlkPtr mb, str name, char cmd){
	int i;
	char *c=name;
	InstrPtr p;
	mdbState mdb= mdbTable + cntxt->idx;

	while(*c && (isalnum(*c) || *c=='$' || *c=='_')) c++;
	*c = 0;
	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( p->argc>0 &&  strcmp(getDestName(mb,p),name)==0){
			mdbSetBreakpoint(cntxt,mb,p,cmd);
			return;
		}
	}
}

void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, char cmd)
{	mdbState mdb= mdbTable + cntxt->idx;
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkVar[mdb->brkTop] = p->argv[0];
	mdb->brkVarName[mdb->brkTop] = mb->var[p->argv[0]].name;
			mdb->brkCmd[mdb->brkTop] =cmd;
	if( mdb->brkTop+1< MAXBREAKS) 
		mdb->brkTop++;
}
void mdbShowBreakpoints(Client cntxt)
{	int i;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++)
	fprintf(cntxt->fdout,"breakpoint %s [%d]\n",mdb->brkVarName[i], mdb->brkVar[i]);
}

void mdbClrBreakpoint(Client cntxt, InstrPtr p)
{	int i,j=0;
	mdbState mdb= mdbTable + cntxt->idx;

	for(i=0;i<mdb->brkTop;i++){
		mdb->brkVar[j]= mdb->brkVar[i];
		mdb->brkVarName[j]= mdb->brkVarName[i];
		mdb->brkCmd[j]= mdb->brkCmd[i];
		mdb->brkBlock[j]= mdb->brkBlock[i];
		if( mdb->brkVar[i] != p->argv[0]) j++;
	}
	mdb->brkTop = j;
}

#define skipBlanc(X)	while(isspace(*X)) X++;
#define skipNonBlanc(X)	while(!isspace(*X)) X++;
#define skipWord(X)	skipNonBlanc(X); skipBlanc(X);

void printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk){
	InstrPtr p;
	int k;

	p= getInstrPtr(mb, stk->pc);
	if( p != NULL){
		promptInstruction(cntxt->fdout,mb,p);
		p= getInstrPtr(mb, 0);
		fprintf(cntxt->fdout," at #%d in %s(", stk->pc, getFcnName(mb));
		for(k=1; k<p->argc; k++){
			VALprint(cntxt->fdout, &stk->stk[p->argv[k]]);
			if( k < p->argc-1 ) fprintf(cntxt->fdout,",");
		}
		fprintf(cntxt->fdout,")\n");
	}
}

@+ MDB module implementation 
The following routines are available for inclusion also in MAL programs.
Either one set is sufficient to produce the required action.

@c
int MDBmdb(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	Client c =getClient();
	c->itrace = ( c->itrace)?0:1; 
	fprintf(c->fdout,"#Monet Debugger %s\n", (c->itrace?"on":"off"));
	mdbStep(c, mb, stk, p,'n');
	return GDK_SUCCEED;
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.
@c
char mdbCommand(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p, char cmd){
	char *b;
	FILE *out = cntxt->fdout;

	if( p != NULL){
		fprintf(out,"mdb> ");
		printInstruction(out,mb,p);
	}
	if( cntxt->itrace==1) cntxt->itrace=2;
	do{
	fprintf(out,"mdb"); 
	if( readClient(cntxt)==0){
		cntxt->itrace= 0;
		return 'q';
	}
	b= cntxt->input;
	skipBlanc(b);
	switch(*b){
	case 0: return cmd;
	case 'c': if( strncmp("call",b,4)==0){
			GDKerror("call instruction not yet implemented\n");
		 }
		 return 'c';
	case 'h': mdbHelp(out); break;
	case 'q': 
		cntxt->itrace= 0;
		fprintf(cntxt->fdout,"#Monet Debugger %s\n", 
				(cntxt->itrace?"on":"off"));
		return 'q';/* return from this debugger */
	case 'n': /* next */
	case 's': /* next */
		return *b;
	case 'S': /* display symbol table */
		skipWord(b);
		skipBlanc(b);
		debugScope(b);
		break;
	case 't': /* trace breakpoint */
		if( strncmp("timer",b,5)==0){
			if( cntxt->timer==0)
				cntxt->timer = GDKusec();
			else cntxt->timer = 0;
		}
	case 'b':
		skipWord(b);
		if(*b==0) { mdbShowBreakpoints(cntxt); continue;}
		if( !isspace(*b) && *b != 0){
			/* set breakpoints by name */
			mdbSetBreakpointName(cntxt,mb,b,*b);
		} else {
			mdbSetBreakpoint(cntxt,mb,p,*b);
		}
		continue;
	case 'd':
		/* get rid of break point */
		if( strncmp(b,"do",2)==0 && stk->down!= NULL){
			fprintf(out,"go down the stack\n");
			stk= stk->down;
			mb = stk->blk;
			break;
		}
		skipWord(b);
		if(*b && !isspace(*b)){
			fprintf(out,"breakpoint (not yet) deleted\n");
		} else {
			mdbClrBreakpoint(cntxt,p);
		}
		continue;
	case 'p':
	{	 int i;
		char *t;
		skipWord(b);
		t=b;
		skipNonBlanc(t);
		*t = 0;
		/* search the symbol */
		i = findVariable(mb,b);
		if( i<0){
			fprintf(out,"Symbol not found\n");
		} else{
			printStackElm(out,mb->var+i,stk->stk+i);
		}
		continue;
	}
	case 'u':
		if( stk->up == NULL) break;
		fprintf(out,"go up the stack\n");
		stk= stk->up;
		mb = stk->blk;
		printCall(cntxt,mb,stk);
		continue;
	case 'v': /* variable bindings */
		printStack(out,mb,stk);
		continue;
	case 'w':
	{	MalStkPtr w;
		MalBlkPtr mw=mb;
		for(w=stk;w!= NULL; w=w->up){
			mw = w->blk;
			printCall(cntxt,mw,w);
		}
		continue;
	}
@-
While debugging it should be possible to inspect the symbol 
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
	case 'L': 
	case 'l': /* list the current code block */
	{	str modname, fcnname;
		Symbol fsym,fs;
		int i;

		mal_xlisting= *b=='L';
		skipWord(b);
		if( *b!= 0){
			b[strlen(b)-1] =0;
			modname=b;
			fcnname= strchr(b,'.');
			if( fcnname == NULL){
				fsym= findScope(mal_scope,modname);
				if( fsym==0) {
					fprintf(out,"scope not found\n");
					continue;
				}
				for(i=0;i<MAXSCOPE;i++){
					fs= fsym->subscope[i];
					while(fs != NULL){
						printSignature(out,fs);
						fs= fs->peer;
					}
				}
				continue;
			} else {
				*fcnname = 0;
				fcnname ++;
			}
			/* display the overloaded symbol definition */
			if( displaySymbol(out,modname,fcnname)==0){
				fprintf(out,"Symbol '%s.%s' not found\n",
					modname,fcnname);
				continue;
			} else continue; 
			printFunction(out,fsym->def);
			continue;
		}
		printFunction(out,mb);
		continue;
	}
	case 'r': /* reset program counter */
		fprintf(out,"restart with current stack\n");
		return 'r';
	default:
		fprintf(out,"debugger command expected\n");
		mdbHelp(out);
	}
	} while(1);
	return 0;
}
char mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p,char cmd){
	char newcmd;

	switch(cmd){
	case 'c':
		if( newcmd= isBreakpoint(cntxt,p) ){
			/* printf("stop at line %d\n",stk->pc);*/
			if( newcmd == 't') fprintf(cntxt->fdout,"show value nyi \n");
			cmd= mdbCommand(cntxt,mb,stk,p,newcmd);
		} 
		break;
	case 's': case 'n':
		if( cntxt->timer){
			long n= GDKusec();
			long l= n - cntxt->timer;
			fprintf(cntxt->fdout,"[%-3d usec] ",l);
		}
		cmd= mdbCommand(cntxt,mb,stk,p,cmd);
		break;
	case 'r': cmd = 'n';
		if( cntxt->timer){
			long l= GDKusec() - cntxt->timer;
			fprintf(cntxt->fdout,"[%d usec]",l);
		}
	}
	if( cntxt->timer) cntxt->timer = GDKusec();
	fflush(cntxt->fdout);
	return cmd;

}
@+ Utilities
DUmping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes.
Beware that a stack frame need not be initialized with null values.
Instead, it has been zeroed upon creation.
@c
void printStack(FILE *f, MalBlkPtr mb, MalStkPtr s){
        int i = 0;

        fprintf(f,"Stack pc=%d size=%d top=%d\n",s->pc,s->stksize,s->stktop);
        for( ; i<mb->vtop ; i++){
		printStackElm(f, mb->var+i, s->stk+i);
        }
}

void printStackElm(FILE *f, VarPtr n, ValPtr v){
	str nme;
	fprintf(f,"[%d] %s\t= ",n->offset,n->name);
	if( n->isaconstant) {
		VALprint(f,&n->cstvalue);
	} else {
	 	VALprint(f, v);
	}
	nme= malTypeName(n->type);
	fprintf(f,":%s%s%s", nme, (n->isused?" used":""),
			(n->isaconstant?" constant":""));
	fprintf(f,"\n");
	GDKfree(nme);
}
@-
Some utilities for the debugger 
@c
void mdbHelp(FILE *f){
	fprintf(f,"next	-- Advance to next statement\n");
	fprintf(f,"continue -- Continue program being debugged\n");
	fprintf(f,"break -- set breakpoint on current instruction\n");
	fprintf(f,"break <var> -- break on assignment to <var>\n");
	fprintf(f,"step -- advance to next MAL instruction\n");
	fprintf(f,"Symbols -- display the symbol table \n");
	fprintf(f,"quit -- leaver debugger\n");
	fprintf(f,"list -- list current program block\n");
	fprintf(f,"variables -- print variable bindings\n");
	fprintf(f,"where -- print stack trace\n");
	fprintf(f,"print <var> -- display value of a variable\n");
	fprintf(f,"run -- restart current procedure\n");
	fprintf(f,"timer -- produce micro-second response time\n");
	fprintf(f,"help -- this message\n");
}
