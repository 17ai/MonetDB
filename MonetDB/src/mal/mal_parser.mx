@a M. L. Kersten
@v 1.1

@* Monet Assembler Language
As of Version 5.0 the primary interface for interaction with the Monet kernel
is based on a simple, assembler-like language called MAL. 

The language reflects the virtual machine architecture around the
gdk library and has been designed for speed of interpretation,
ease of analysis, and ease of compilation by applications.
The key research issue is to realize the first just-in-time multi-query
optimizer.

This module contains a small footprint MAL parser for Monet Version 5.
The parser (and its target language) are designed for speed of analysis.
For, parsing is a dominant cost-factor in applications interfering with
Monet. For the language design it means that look-ahead and ambiguity
should be avoided where possible. At the same time the language should
remain 'readable' to enable ease of debugging.

This parser assumes availability of a complete MAL block upfront
as a string to be parsed and executed on behalf of a client. 
Unike Monet V4, no module management operations are allowed within the
context of a procedure. They are considered global commands.

The syntax layout of a MAL program consists of a module name,
a list of import commands, a list of function/ruler/agent
definitions and concludes with the statements to be executed as
the main body of the program.  All components are optional.

The parser can also parse the MEL signature files to built a knowledge
base of externally known functions.
Futhermore, the parser produced is intended to be thread safe.[todo]

The stand-alone version of this parser (Mal) can be used 
to check any MAL procedure for syntactic errors in a front-end.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is taken from a client input buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.

Note, the separator collection deals with the ^M for Microsoft's Windows
environments. TODO
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_resolve.h"
#include "mal_import.h"
#include "mal_client.h"
#include "mal_linker.h"

mal_export int parseMal(Client cntxt);
mal_export void debugParser(int i);

#endif /* _MAL_PARSER_H */

@- lexical utilities
Before a line is parsed we check for a request to echo it.
This command should be executed at the beginning of a parse
request and each time we encounter EOL.
@c
#include "mal_parser.h"

#define MAXERRORS 100
#define FATALINPUT MAXERRORS+1
#define NL(X) ((X)=='\n' || (X)=='\r')

int echoInput(Client cntxt){
	if (cntxt->listing) { 
		char *c= cntxt->nxt;
		fputs("#",GDKout);
		while(*c && !NL(*c)){
			fputc(*c++,GDKout);
		}
		fputc('\n', GDKout);
		fflush(GDKout);
	}
}
#define nextChar(X)  (*(X)->nxt?*(X)->nxt++:0)
#define currChar(X)	*(X)->nxt

int prevChar(Client cntxt) {
	if( cntxt->nxt > cntxt->input) cntxt->nxt--;
	return *cntxt->nxt;
}
INLINE
void skipComment(Client cntxt) { 
	char c; 
	if( *cntxt->nxt != '#') return;
	cntxt->nxt++;
	while (c = *cntxt->nxt) {
		if(c== '\n') return;
		if(c== '\r') return;
		cntxt->nxt++;
	}
}
#define skipBlanc(X) {char c; while ((c = *(X)->nxt) && isblank(c))(X)->nxt++;\
	if( c == '#') skipComment(cntxt);}
INLINE
void skipBlanc2(Client cntxt){
	char c; 
	while ((c= *cntxt->nxt) && isspace(c))cntxt->nxt++;
	if( c == '#') {
		skipComment(cntxt);
		skipBlanc2(cntxt);
	}
}
INLINE
void advance(Client cntxt, int length){
	char c; 
	cntxt->nxt += length;
	while ((c = *cntxt->nxt) && isspace(c)) cntxt->nxt++;
}
@-
The most recurring situation is to recognize identifiers.
This process is split into a few steps to simplify subsequent
construction and comparison.
IdLength searches the end of an identifier without changing
the cursor into the input pool.
IdCopu subsequently prepares a GDK string for inclusion in the
instruction datastructures.

Note that keyword() favors lowercase keywords. This avoids
conversion cost and safes about 20% on lexical analysis.
@c
short opCharacter[256];
short idCharacter[256];
int initParser(){
	int i;
	for(i=0;i<256;i++)
	switch(i){
	case '-': case '!': case '\\': case '$': case '%':
	case '^': case '*': case '~': case '+': case '&':
	case '|': case '<': case '>': case '=': case '/':
	case ':': opCharacter[i]=1; break;
	default: opCharacter[i]=0;
	}
	for(i=0;i<256;i++)
	idCharacter[i]= isalpha(i);
	idCharacter['_']=1;
	idCharacter[TMPMARKER]=1;
}
int idLength(Client cntxt){
	int l;
	str s= cntxt->nxt;
	if( !idCharacter[*s] ) return 0;
	l=1; s++;
	while(idCharacter[*s] || isdigit(*s) ) { s++; l++; }
	return l;
}
str idCopy(Client cntxt, int length){
	str s= GDKmalloc(length+1);
	if( s== 0) GDKfatal("FATAL:idCopy:");
	strncpy(s,cntxt->nxt,length);
	s[length]=0;
	cntxt->nxt += length;
	skipBlanc(cntxt);
	return s;
}
int keyword(Client cntxt, str kw, int length){
	int i;
	if( currChar(cntxt) == *kw &&
		strncmp(cntxt->nxt,kw,length)==0 &&
		!isalnum(*(cntxt->nxt + length)) ){
		advance(cntxt,length);
		return 1;
	}
	/* check for captialized versions */
	for(i=0;i<length;i++)
	if( tolower(cntxt->nxt[i]) != kw[i]) return 0;
	if( !isalnum(cntxt->nxt[length]) ) {
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
@-
Keyphrase testing is limited to a few characters only
(check manually). To speed this up we use a pipelined and
inline macros.
@c
int keyphrase(Client cntxt, str kw, int length){
	if( strncmp(cntxt->nxt,kw,length)==0 ){
		advance(cntxt,length);
		skipBlanc(cntxt);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase1(Client cntxt, str kw){
	if( *cntxt->nxt == *kw){
		advance(cntxt,1);
		return 1;
	}
	return 0;
}
INLINE
int keyphrase2(Client cntxt, str kw){
	if( cntxt->nxt[0] == kw[0] &&
	    cntxt->nxt[1] == kw[1]){
		advance(cntxt,2);
		return 1;
	}
	return 0;
}
@-
A similar approach is used for string literals.
Beware, string lengths returned include the
brackets. They are eaten away in strCopy.
@c
int stringLength(Client cntxt){
	int l=0;
	str s= cntxt->nxt;
	if( *s != '"') return 0;
	s++;
	while( *s ){
		if( *s == '"' && *(s-1) != '\\') break;
		l++;
		s++;
	}
	return l+2;
}
str strCopy(Client cntxt, int length){
	str s= GDKmalloc(length-1);
	if( s== 0) GDKfatal("FATAL:strCopy:");
	strncpy(s,cntxt->nxt+1,length-2);
	s[length-2] = 0;
	cntxt->nxt += length;
	skipBlanc(cntxt);
	return s;
}
@-
And a similar approach is used for operator names.
A lookup table is considered, because it generally is
faster then a non-dense switch.
@c
int operatorLength(Client cntxt){
	int l=0;
	str s;
	for( s= cntxt->nxt ; *s; s++)
	if( opCharacter[*s]) l++; else return l;
	return l;
}
str operatorCopy(Client cntxt, int length){
	return idCopy(cntxt,length);
}
@-
For error reporting we may have to find the start of the previous line,
which, ofcourse, is easy given the client buffer.
The remaining functions are self-explanatory.
@c
str lastline(Client cntxt){ 
	str s = cntxt->nxt;
	if( NL(*s)) s++;
	while(s && s > cntxt->input && !NL(*s)) s--;
	if( NL(*s)) s++;
	return s;
}
int position(Client cntxt)
{	str s = lastline(cntxt);
	return (int)(cntxt->nxt)- (int)s;
}
void resetInput(Client cntxt) {
        *cntxt->nxt = 0;
}
@-
Upon encountering an error we skip to the nearest semicolon,
or comment terminated by a new line
@c
INLINE
void skipToEnd(Client cntxt){
	char c;
	while ((c = *cntxt->nxt) && c != ';') nextChar(cntxt); 
	if( c== ';') cntxt->nxt++;
}
@-
The lexical analyser for numeric constants is a little more complex.
Aside from getting its length, we need an indication of its type.
We could also rebuild the constant directly, but that is already
handled by newConstant. So be lazy for the time being.
@c
int cstLength(Client cntxt, int *type)
{	int i=0;
	str s= cntxt->nxt;

	if( *s=='f' && strncmp(s,"false",5)==0 && !isalnum(*(s+5)) ){
		*type = TYPE_bit;
		skipBlanc(cntxt);
		return 5;
	}
	if( *s== 't' && strncmp(s,"true",4)==0 && !isalnum(*(s+4)) ){
		*type = TYPE_bit;
		skipBlanc(cntxt);
		return 4;
	}
	if( *s== 'n' && strncmp(s,"nil",3)==0 && !isalnum(*(s+3)) ){
		*type = TYPE_void;
		skipBlanc(cntxt);
		return 3;
	}
	*type = TYPE_int;
	if( *s == '-') { i++; s++;}
	if( ! isdigit(*s)) {
		if( *s!= '.') return 0;
	} 
	while( isdigit(*s)) { i++; s++;}
	if( *s == '.'){ i++; s++; 
		while( isdigit(*s)) { i++; s++;}
		*type= TYPE_flt;
	} 
	if( *s == 'e' || *s == 'E'){ i++; s++;
		if( *s== '-' || *s== '+') s++;
		*type = TYPE_dbl;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == '@'){ i++; s++;
		*type= TYPE_oid;
		while( isdigit(*s)) { i++; s++;}
	} 
	if( *s == 'L' && *(s+1)=='L'){
		if( *type== TYPE_int) {i+=2; *type = TYPE_lng;}
		if( *type== TYPE_flt) {i+=2; *type = TYPE_dbl;}
	}
	return i;
}
str cstCopy(Client cntxt, int i){ return idCopy(cntxt,i);}

int typeMarker(Client cntxt)
{	
	if( *cntxt->nxt==':')
	switch(*(cntxt->nxt+1)){
	case 'b': if( keyphrase(cntxt,":bit",4) ) return TYPE_bit;
		if( strncmp(cntxt->nxt,":bat[",5)==0){
			/* parse bat[type,type */
			str hd = 0, tl =0;
			int i= malAnyType, ht,tt;

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) &&
			    nextChar(cntxt)==',' &&
			    (tl= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				tt = getTypeIndex(tl);
				i= newBatType(ht,tt);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			if( tl ) GDKfree(tl);
			return i;
		} 
		break;
	case 'c': if( keyphrase(cntxt,":chr",4) ) return TYPE_chr;break;
	case 'f': if( keyphrase(cntxt,":flt",4) ) return TYPE_flt;break;
	case 'd': if( keyphrase(cntxt,":dbl",4) ) return TYPE_dbl;break;
	case 'i': if( keyphrase(cntxt,":int",4) ) return TYPE_int;break;
	case 'l': if( keyphrase(cntxt,":lng",4) ) return TYPE_lng;break;
	case 'o': if( keyphrase(cntxt,":oid",4) ) return TYPE_oid;break;
	case 'p': if( keyphrase(cntxt,":ptr",4) ) return TYPE_ptr;break;
	case 's': if( keyphrase(cntxt,":sht",4) ) return TYPE_sht;
		  if( keyphrase(cntxt,":str",4) ) return TYPE_str;break;
	case 't': if( keyphrase(cntxt,":type",5) ) return TYPE_type;break;
	}
	return 0;
}
@-
Character constants may be escaped.
@c
str charCst(Client cntxt)
{	int i;
	str v;
	if( *cntxt->nxt!='\'') return 0;
	v= cntxt->nxt; v++;
	i= 1;
	if( *v == '\\') { v++; i++;
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
		if( isdigit(*v)) { i++; v++;}
	} else v++;
	if( *v != '\'') 
		return (str) parseError(cntxt,"'\'' expected\n");
	v= strCopy(cntxt,i+2);
	return v;
}
@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

The parser uses the rigid structure of the language to speedup
analysis. In particular, each input line is translated into
a MAL instruction record as quickly as possible. Its context is
manipulated during the parsing process, by keeping the  curPrg,
curBlk, and curInstr variables.

The language does not support '#include' style commands, which
means we do not need a stack to keep track of the parsing context.

The language statements of the parser are gradually introduced, with
the overall integration framework last.
The convention is to return a zero when an error has been
reported or when the structure can not be recognized.
Furthermore, we assume that blancs have been skipped before entering.
@- Module statement.
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.
@T
moduleStmt : [ATOM] MODULE modname\\
modname    : identifier | string \\
@-
@= parsePath
	if( x = idLength(cntxt)) modname= idCopy(cntxt,x); else
	if( y = stringLength(cntxt)) modname= strCopy(cntxt,y);
	if( modname==0)
		return parseError(cntxt,"<module path> expected\n");
@c
int parseModule(Client cntxt, int atomary)
{	
	str modname=0;
	int x,y,tpe;

	if( ! keyword(cntxt,"module",6) ){
		if( atomary) return parseError(cntxt,"'module' expected\n");
		return 0;
	}

	@:parsePath@

@-
Atom storage may be defined in terms of an existing type.
@c
	if( atomary ) {
		if( currChar(cntxt)==':') {
			tpe= typeMarker(cntxt);
		} else tpe= TYPE_int;
		malAtomDef(modname,tpe);
	}
	if( findScope(cntxt->nspace,modname) != NULL){
		GDKerror("duplicate module '%s'\n",modname);
		cntxt->curprg->def->errors  = FATALINPUT;
	} else	cntxt->nspace = fixateScope(cntxt->nspace, modname);
	GDKfree(modname);
	@:typeInfo@
	skipToEnd(cntxt);
	return 1;
}
@- Import statement
An import statement is immediately taken into effect. This
calls for temporary switching the input for a particular client.
The administration for this is handled by malImport.
@T
importStmt : IMPORT identifier \\
	   : IMPORT string\\
@c
int parseImport(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	str modname=0;
	int x,y;

	if( ! keyword(cntxt,"use",3)) return 0;

	@:parsePath@

	malImport(cntxt,modname, cntxt->listing);
	GDKfree(modname);
	skipToEnd(cntxt);
	return 1;
}
@- Definition
The definition statements share a lot in common, which calls for factoring
out the code in a few text macros. Upon encountering a definition, we
initialize a MAL instruction container. We should also check for
non-terminated definitions.
@T
defineStmt : FUNCTION
	: COMMAND functionHdr [COMMENT string] ';'
	: HANDLER
	: RULER functionHdr [COMMENT string] ';'

@= fcnHeader
	l = idLength(cntxt);
	if( l == 0) l = operatorLength(cntxt);
	if( l == 0) 
	return (MalBlkPtr) parseError(cntxt,"<identifier> |<operator> expected\n");

	fnme = idCopy(cntxt,l);
	if( nextChar(cntxt) != '(') {
		GDKfree(fnme);
		return (MalBlkPtr)parseError(cntxt,"'(' expected\n");
	}
	skipBlanc2(cntxt);
	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk,0);

	/* re-assign MAL block to new function */
	GDKfree(curPrg->name);
	curPrg->name = GDKstrdup(fnme);
	GDKfree(curInstr->fcnname);
	curInstr->token= FUNCTIONsymbol;
	curInstr->fcnname = fnme;
	GDKfree(getVarName(curBlk,0));
	getVarName(curBlk,0) = GDKstrdup(fnme);
	setVarType(curBlk,0,malAnyType);


	/* get parameters */
	ch= currChar(cntxt);
	while( ch !=')' && ch && !NL(ch)){
		str arg;
		@:binding@
		pushArgument(curBlk,curInstr, newVariable(curBlk,arg,type));
		skipBlanc2(cntxt);
		/* the last argument may be variable length */
		if( keyphrase2(cntxt,"[]") ){
			curInstr->varargs++;
			break;
		}
		skipBlanc2(cntxt);
		if( (ch=currChar(cntxt)) != ',') {
			if( ch==')') break;
			return (MalBlkPtr) parseError(cntxt,"',' expected\n");
		} else nextChar(cntxt);
		skipBlanc2(cntxt);
		ch = currChar(cntxt);
	}
	/* get return type */
	if( nextChar(cntxt) != ')') {
		freeInstruction(curInstr);
		return (MalBlkPtr) parseError(cntxt,"')' expected\n");
	}
	skipBlanc2(cntxt);
	if( currChar(cntxt) != ':') {
		/* default */
		setVarType(curBlk,0,malAnyType);
	} else { nextChar(cntxt); skipBlanc2(cntxt);
		@:melType@
		setVarType(curBlk,0,type);
	}
	
@-
The common theme in definitions is to parse the argument list.
@T
functionHdr: fcnName '(' [ binding \{',' binding\}] ')' ':' type\\
@
@= binding
	l = idLength(cntxt);
	arg = idCopy(cntxt,l);
	if( nextChar(cntxt) != ':')
		return (MalBlkPtr) parseError(cntxt,"':' expected\n");
	skipBlanc2(cntxt);
	@:melType@
@-
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.

The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in rules, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about the resulting type structure.
@T
melType	: melElm [propList] | bat '[' melElm ',' melElm ']' [propList]\\
melElm  : identifier | any ['::'digit]\\
propList : '\{' identifier [ ',' identifier] '\}'\\
@-
Variables will later be extended with a (boolean?) property list to enable
squeezers to make decisions. An example is :(int, key, notnull) for
a column of a BAT.

@= propList
	if( keyphrase1(cntxt,"{")) {
		do{
			l = idLength(cntxt);
			/* ignore so far */
			cntxt->nxt += l;
			skipBlanc(cntxt);
		} while( keyphrase1(cntxt,","));
		if( !keyphrase1(cntxt,"}") )
			return (MalBlkPtr) parseError(cntxt,"'}' expected\n");
		skipBlanc2(cntxt);
	}
@= melElement
	if( keyword(cntxt,"any",3)){
		type = malAnyType;
		if( keyphrase2(cntxt,"::")){
			if( !isdigit(currChar(cntxt)) )
				return (MalBlkPtr) parseError(cntxt,"[0-9] expected\n");
			else {
				int k= nextChar(cntxt) - '0';
				setAnyTailIndex(type,k);
			}
		}
		curInstr->polymorphic = TRUE;
	} else {
		char x;
		l = idLength(cntxt);
		x = cntxt->nxt[l];
		cntxt->nxt[l]= 0;
		type= getTypeIndex(cntxt->nxt);
		cntxt->nxt[l]= x;
		cntxt->nxt += l;
	}
	skipBlanc2(cntxt);
@-
@= melType
	if( keyword(cntxt,"bat",3)){
		if( keyphrase1(cntxt,"[")){
			int ht,tt;
			@:melElement@ ht = type;
			if( nextChar(cntxt) !=',')
				return (MalBlkPtr) parseError(cntxt,"',' expected\n");
			skipBlanc2(cntxt);
			@:melElement@ tt = type;
			type = malAnyBatType(ht,tt);
			if( !keyphrase1(cntxt,"]"))
				return (MalBlkPtr) parseError(cntxt,"']' expected\n");
		} else {
			type = malAnyBatType(malAnyType,malAnyType);
			curInstr->polymorphic = TRUE;
		}
	} else{
		@:melElement@
	}
	skipBlanc2(cntxt);
	@:propList@
@-
Most functions are (dynamically) linked with the kernel.

@= externalFcn
	if( keyphrase1(cntxt,"=")){
		str nme;
		int i;
		skipBlanc2(cntxt);
		i = idLength(cntxt);
		if( i==0){
			parseError(cntxt,"<identifier> expected\n");
			return 0;
		}
		nme = idCopy(cntxt,i);
		curInstr->modname = GDKstrdup(cntxt->nspace->name);
		curInstr->fcn = getAddress(nme);
		curBlk->binding = nme;
		/* defAtomCommand(curInstr);*/
	} else return (MalBlkPtr) parseError(cntxt,"'=' expected\n");
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.

The external commands and rules come with a short
help information.

@= helpInfo
	skipBlanc2(cntxt);
	if( keyphrase(cntxt,"comment",7)){
		skipBlanc2(cntxt);
		if( l= stringLength(cntxt)){
			curBlk->help = strCopy(cntxt,l);
		} else parseError(cntxt,"<string> expected\n");
	} 
	skipToEnd(cntxt);
@-
Module components may include a function reference overruling
the built-in type resolver.
@= typeInfo
	skipBlanc2(cntxt);
	if( keyphrase(cntxt,"type",4)){
		int l;
		skipBlanc2(cntxt);
		if( keyphrase(cntxt,"=",1)==0){
			parseError(cntxt,"'=' expected\n");
		} else{
		skipBlanc2(cntxt);
		if( l= idLength(cntxt)){
			str nme = idCopy(cntxt,l);
			cntxt->nspace->typeChecker = getAddress(nme);
			GDKfree(nme);
		} else parseError(cntxt,"<identifier> expected\n");
		}
	} 
@c
MalBlkPtr parseCommandPattern(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, arg=0;
	char ch;
	int type;

	@:fcnHeader@
	getInstrPtr(curBlk,0)->token= kind;
	curPrg->kind = kind;
	closeClientPrg(cntxt, FALSE);
	@:externalFcn@
	@:helpInfo@
	showErrors(cntxt);
	if(curBlk && cntxt->listing) 
		printFunction(stdout, curBlk);
	return curBlk;
}

MalBlkPtr parseFunction(Client cntxt){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0;
	char ch;
	int type, kind= FUNCTIONsymbol;

	if( ! keyword(cntxt,"function",8) ) return 0;
	@:fcnHeader@
	@:helpInfo@
	return curBlk;
}

@-
Commands, functions, rulers, barriers and catch blocks all end
with a labeled end-statement. The routine below checks for
misalignment of the closing statements.
Any instruction parsed after the function block is considered an
error.
@c
int parseEnd(Client cntxt)
{	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int i,l,showit=0;
	str v;

	if( keyword(cntxt,"end",3)){
		curPrg = cntxt->curprg;
		curBlk = curPrg->def;	
		l = idLength(cntxt);
		if ( keyword(cntxt,"function",8)){
			if( curPrg->kind != FUNCTIONsymbol) 
				parseError(cntxt,"'end function' unexpected\n");
                        pushEndInstruction(curBlk);
			closeClientPrg(cntxt,TRUE);
			showit= TRUE;
		} else
		if ( keyword(cntxt,"handler",5)){
			if( curPrg->kind != HANDLERsymbol) 
				parseError(cntxt,"'end agent' expected\n");
                        pushEndInstruction(curBlk);
			closeClientPrg(cntxt,TRUE);
		} else{
			i = findVariableLength(curBlk,cntxt->nxt,l);
			if( i<0) {
				v= idCopy(cntxt,l);
				i= newVariable(curBlk, v, TYPE_str);
			} else advance(cntxt,l);
			curInstr = newInstruction(ENDsymbol);
			curInstr->argv[0]= i;
			pushInstruction(curBlk,curInstr);
		}
		skipToEnd(cntxt);
		if(showit && cntxt->listing) printFunction(stdout, curBlk);
		return 1;
	}
	return 0;
}
@-
The control statements are :
@T
cntrl	: (CATCH | REDO | LEAVE | RAISE | RETURN) identifier\\
@= parseCntrl
int parse@3(Client cntxt)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	str arg;
	int i,l;

	if( ! keyword(cntxt,@1,@2)) return 0;
	curPrg = cntxt->curprg;
	curBlk = curPrg->def;	
	curInstr= newInstruction(@3symbol);
	l = idLength(cntxt);
	i = findVariableLength(curBlk,cntxt->nxt,l);
	if( i<0){
		arg= idCopy(cntxt,l);
		i= newVariable(curBlk, arg, @4);
	} else advance(cntxt,l); 
	curInstr->argv[0]= i;
	if(@3symbol== CATCHsymbol) curInstr->barrier= CATCHsymbol;
	pushInstruction(curBlk, curInstr);
	skipToEnd(cntxt);
	return 1;
}
@c
@:parseCntrl("catch", 5,CATCH, TYPE_str)@
@:parseCntrl("redo", 4,REDO, malAnyType)@
@:parseCntrl("raise", 5,RAISE, malAnyType)@
@:parseCntrl("return", 6,RETURN, malAnyType)@
@:parseCntrl("leave", 5,LEAVE, malAnyType)@

@-
Most instructions are simple assignments, possibly
modified with a barrier/catch tag.
@T
stmt	: tag identifier ':=' expr\\
tag	: BARRIER | CATCH\\
expr	: fcncall | [factor  operator] factor \\
factor	: constant | var | type'('constant')'\\

Factors may designate a type variable. In particular
for bat[T1,T2] this is a little tricky to parse.
@= factor
	if( i= cstLength(cntxt,&lt)){
		v= cstCopy(cntxt,i);
		i= typeMarker(cntxt);
		if(i) lt = i;
		idx= newConstant(curBlk,lt,v);
	} else
	if( (v= charCst(cntxt)) ){
		i= typeMarker(cntxt);
		if(i) lt = i; else lt= TYPE_chr;
		idx= newConstant(curBlk,lt,v);
	} else
	if( i = stringLength(cntxt) ){
		idx= newConstant(curBlk,TYPE_str,strCopy(cntxt,i));
	} else
	if( i= idLength(cntxt)){
		/* parse bat[type,type] */
		if(i==3 && strncmp(cntxt->nxt,"bat[",4)==0){
			str hd = 0, tl =0;
			int ht,tt;

			advance(cntxt,4);
			if( (hd= idCopy(cntxt,idLength(cntxt))) &&
			    nextChar(cntxt)==',' &&
			    (tl= idCopy(cntxt,idLength(cntxt))) ){
				ht = getTypeIndex(hd);
				tt = getTypeIndex(tl);
				i= newBatType(ht,tt);
				v= malTypeName(i);
				idx= newVariable(curBlk,v,i);
			}
			if( nextChar(cntxt) !=']')
				parseError(cntxt,"']' expected\n");
			if( hd ) GDKfree(hd);
			if( tl ) GDKfree(tl);
		}else
		if( (idx=findVariableLength(curBlk,cntxt->nxt,i)) == -1){
			v= idCopy(cntxt,i);
			i= typeMarker(cntxt);
			i= i?i: malAnyType;
			idx = newVariable(curBlk, v, i);
		} else advance(cntxt,i);
	} else { 
		idx= 0;
		parseError(cntxt,"<factor> expected\n");
	}
@-
The assignment expression is the most complex term recognized.
@T
assign	: [identifier ':='] expr\\
expr	: factor \{ operator factor \}\\
factor	: fcn_call | variable | constant\\

@c
void parseAssign(Client cntxt, int kind)
{	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	int i=0, k=0, lt,rt;
	str v, op, arg=0, r;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = newInstruction(ASSIGNsymbol);

	curInstr->barrier = kind==BARRIERsymbol? kind :0 ;
	i= idLength(cntxt);
	if( i==0) {
		parseError(cntxt,"<identifier> expected\n"); 
		goto part3;
	}
	arg= idCopy(cntxt,i);

	/* test destination variable or function call */
	if( keyphrase2(cntxt,":=") ){
		curInstr->argv[0]= newVariable(curBlk,arg,malAnyType);
	} else {
		if( curInstr->raise){
			parseError(cntxt,"':=' expected\n");
			goto part3;
		}
		if( curInstr->barrier) {
			curInstr->argv[0]= newVariable(curBlk,arg,malAnyType);
			curInstr->token= kind;
			goto part3;
		}
		curInstr->argv[0]= newTmpVariable(curBlk,malAnyType);
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(' ){
				GDKfree(arg);
				parseError(cntxt,"'.' or '(' expected\n");
				goto part3;
		}
		goto idseen;
	}
@-
Now parse the expression, start with an operand.
This code is used in both positions of the expression
@= term
	if( i= cstLength(cntxt,&lt)){
		v= cstCopy(cntxt,i);
		i= typeMarker(cntxt);
		if(i) lt = i;
		i= newConstant(curBlk,lt,v);
		pushArgument(curBlk,curInstr,i);
		goto @1;
	} 
	if( (v= charCst(cntxt)) ){
		i= typeMarker(cntxt);
		if(i) lt = i; else lt= TYPE_chr;
		i= newConstant(curBlk,lt,v);
		pushArgument(curBlk,curInstr,i);
		goto @1;
	} 
	if( i = stringLength(cntxt) ){
		lt = TYPE_str;
		i= newConstant(curBlk,lt,strCopy(cntxt,i));
		pushArgument(curBlk,curInstr,i);
		goto @1;
	}
@-
@= parseArguments
	/* get arguments */
	curInstr->argc=1;
	while( currChar(cntxt)!= ')'){
		int idx;
		@:factor@
		pushArgument(curBlk,curInstr,idx);
		if( currChar(cntxt)==',') keyphrase1(cntxt,",");
		else 
		if( currChar(cntxt) != ')'){
			parseError(cntxt,"',' expected\n");
			cntxt->nxt--; /* keep it */
			break;
		}
	}
@c
	@:term(part2)@
	if( idLength(cntxt)==0 && operatorLength(cntxt)==0) {
		parseError(cntxt,"<identifier> or <unary operator> expected\n");
		goto part3;
	}
	if( (i=operatorLength(cntxt))) {
		arg = idCopy(cntxt,i);
		/*skipBlanc2(cntxt);*/
		if( currChar(cntxt) == '('){
			nextChar(cntxt);
			curInstr->fcnname = arg;
			goto getarguments;
		}
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(') {
			skipBlanc2(cntxt);
			curInstr->fcnname = arg;
			goto part2b;
		}
		goto opseen;
	}
	if( (i= idLength(cntxt)) || (i=operatorLength(cntxt))) {
		arg= idCopy(cntxt,i);
idseen:
		if( currChar(cntxt) != '.' &&
		    currChar(cntxt) != '(' &&
		    (isalpha(*arg) || *arg=='_') ) {
			pushArgumentId(curBlk,curInstr,arg);
			goto part2;
		}

opseen:
		/* continue with parseing a function/operator call */
		if( currChar(cntxt) == '.'){
			nextChar(cntxt);
			skipBlanc2(cntxt);
			curInstr->modname = arg;
			i = idLength(cntxt);
			if( i==0) i= operatorLength(cntxt);
			if( i )
				curInstr->fcnname = idCopy(cntxt,i);
			else {
				parseError(cntxt,"<functionname> expected\n");
				goto part3;
			}
			if(nextChar(cntxt) != '(')
			{ parseError(cntxt,"'(' expected\n");goto part3;}
getarguments:
			skipBlanc2(cntxt);
		} else if(currChar(cntxt) != '(')
		{
			parseError(cntxt,"'(' expected\n");goto part3;
		} else { nextChar(cntxt);
			curInstr->fcnname = arg;
		}

		@:parseArguments@
		goto part3;
	}
	
part2:
	if( i= operatorLength(cntxt) ){
		/* operator expression */
		curInstr->fcnname = idCopy(cntxt,i);
part2b:
		if( i = idLength(cntxt)) {
			/* test variable */
			if( (k=findVariableLength(curBlk,cntxt->nxt,i)) == -1){
				v= idCopy(cntxt,i);
				k= newVariable(curBlk, v, malAnyType);
			} else advance(cntxt,i);
			pushArgument(curBlk,curInstr,k); 
			goto part3;
		} 
		@:term(part3)@
		parseError(cntxt,"<term> expected\n");
	} else  {
		skipBlanc2(cntxt);
		if( *cntxt->nxt != ';' && *cntxt->nxt!='#')
		parseError(cntxt,"operator expected\n");
	}
part3:
	skipToEnd(cntxt);
	pushInstruction(curBlk,curInstr);
}
int parseMal(Client cntxt){
	int kind=0, i;
	Symbol curPrg= cntxt->curprg;
	InstrPtr curInstr;

	echoInput(cntxt);
	/* here the work takes place */
	skipBlanc(cntxt);
	while( currChar(cntxt) && curPrg->def->errors<MAXERRORS){
		switch( currChar(cntxt)){
		case '\n': case '\r': case '\f': 
			nextChar(cntxt);
			echoInput(cntxt);
			continue;
		case '\t': case ' ': 
			  nextChar(cntxt);
		case  0 : continue;
		case '#': skipComment(cntxt);
			  continue;
		case 'A': case 'a':
			  if( keyword(cntxt,"atom",4) &&
			      parseModule(cntxt,TRUE)) break;
			  goto allLeft;
		case 'b': case 'B':
			  if( keyword(cntxt,"barrier",7)) 
				kind = BARRIERsymbol; 
			  goto allLeft;
		case 'C': case 'c': 
			  if( keyword(cntxt,"command",7) ) {
				parseCommandPattern(cntxt, COMMANDsymbol);
				continue;
			  }
			  if( parseCATCH(cntxt)) break;
			  goto allLeft;
		case 'E': case 'e': 
			  if( parseEnd(cntxt)) break;
			  goto allLeft;
		case 'F': case 'f': 
			  if( parseFunction(cntxt)) break;
			  goto allLeft;
		case 'H': case 'h':
			  if( keyword(cntxt,"handler",5)) 
			  { skipToEnd(cntxt); break; }
		case 'L':
		case 'l': if( parseLEAVE(cntxt)) break;
			  goto allLeft;
		case 'M': case 'm': 
			  if( parseModule(cntxt, FALSE)) break;
			  goto allLeft;
		case 'P': case 'p': 
			  if( keyword(cntxt,"pattern",7) ) {
				parseCommandPattern(cntxt, PATTERNsymbol);
				continue;
			  }
			  goto allLeft;
		case 'R': case 'r': 
			  if( parseRAISE(cntxt)) break;
			  if( parseREDO(cntxt)) break;
			  if( parseRETURN(cntxt)) break;
			  if( keyword(cntxt,"rule",4) ) {
				parseCommandPattern(cntxt, RULEsymbol);
				break;
			  }

			  goto allLeft;
		case 'u': if( parseImport(cntxt)) continue;
		default: allLeft:
			parseAssign(cntxt,kind);
			kind =0;
		}
	}
	return curPrg->def->errors;
}
@- Error display
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@c
int parseError(Client cntxt, str msg)
{	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10*1024];
	char *s=buf, *t, *l = lastline(cntxt);
	int i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if(curBlk) curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
        for(t=l; *t && *t!='\n'; t++) {
                if (*t == '%') *s++ = '%'; 
                *s++ = *t;
        }
        *s++ = '\n';
        *s++ = '!';
	/* produce the position marker*/
	i = position(cntxt) + strlen(GDKERROR)-1;
        for(; i > 0; i--) {
                *s++ = (*l++ != '\t')?' ':'\t';
        }
        *s++ = '^'; 
	*s = 0;

        if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if( strlen(msg)+strlen(buf) < 1020)
		sprintf(s, "%s", msg);
	skipToEnd(cntxt);
        GDKerror(buf);
	return 0;
}
