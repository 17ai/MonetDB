@a M. L. Kersten
@v 1.0

@* Monet Assembler Language
As of Version 5.0 the primary interface for interaction with the Monet kernel
is based on a simple, assembler-like language called MAL. 

The language reflects the virtual machine architecture around the
gdk library and has been designed for speed of interpretation,
ease of analysis, and ease of compilation by applications.
The key research issue is to realize the first just-in-time multi-query
optimizer.

This module contains a small footprint MAL parser for Monet Version 5.
This parser assumes availability of a complete MAL block upfront
as a string to be parsed and executed. 
Unike Monet V4, no module management operations are allowed within the
context of a procedure. They are considered global commands.

Futhermore, the parser produced is intended to be thread safe.[todo]

The syntax layout of a MAL program consists of a module name,
a list of import commands, a list of function/ruler/agent
definitions and, concludes with the statements to be executed as
the main body of the program.  All components are optional.
The default module is the client scope.

The parser can also parse the MEL signature files to built a knowledge
base of externally known functions.

The stand-alone version of this parser (Mal) can be used 
to check any MAL procedure for syntactic errors in a front-end.

@+ The lexical analyzer
The lexical analyzer is generated using Flex, the preferred tool in Monet.

The implementation of the lexical analyzer is straightforward:
the input is taken from a client message buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
This input buffer may be screwed up in the process, which implies
that front-ends may have to make a private copy first.

The lexical analyzer and parser are prefixed with "mal", which ensures that
other language analyzers can safely be added
(provided they run not inparallel). The lexical analyzer should
not maintain a linenumber. This aspect is made explicit in the rulers
any way.

The lexical analyser returns simple triples to the parser.
They include the token identifier, the Mal type signature, and a string
representation.

Note, the separator collection deals with the ^M for Microsoft's Windows
environments.

The code produced by Flex is tweaked to ensure thread-safe processing
of this block of C-code.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_resolve.h"
#include "mal_import.h"

@-
The information returned by the lexical analyser includes an
ascii version, because this might later be used for debugging.
@h
typedef struct LEXRECORD{
	int	token, len;
	malType tpe;
	char * 	val;
 } lextoken;

typedef union{
	InstrPtr  stmt;
	Symbol	  sym;
	lextoken  lex;
} yyunion;

#define YYSTYPE yyunion
mal_export YYSTYPE yylval;

mal_export Symbol	curPrg,curScope;
mal_export MalBlkPtr curBlk;
mal_export InstrPtr	curInstr;

/* this should be  dependent on context of parser*/

mal_export int getListing();
mal_export const char *mallexname(int Y);
mal_export void mal_parserror(str msg);
mal_export void mal_flushbuffer();
mal_export str mal_lastline();
mal_export int mal_position();
mal_export int mal_skipcomment();
mal_export int mal_getch();
mal_export int mallex();
mal_export int mal_push(str s,int listing);
mal_export int mal_pop();
mal_export int mal_print(FILE *f, char tpe, YYSTYPE v);
mal_export Symbol mal_parse(Symbol cntxt, str buf, int listing);
mal_export void freeStringStack();
mal_export void debugParser(int i);
mal_export int getTypeIndex(str nme);

#endif /* _MAL_PARSER_H */
@l
/*
%option noyylineno
%option never-interactive
%option nomain
*/

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n\r ]*
P       [-!\$%\^\*~+&|<>=/\\]
IDENT	("$"|{L})(({L}|{D})*)
OPER	{P}+
%{

#include "mal_parser.h"
@-
The Bison parser generator can be traced by calling debugparser(1)
@l
#include "mal_parser.tab.h"

#define YY_INPUT(buf,result,max_size)   { int c = mal_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#define Symbol(X)       { yylval.lex.token= X;	\
			yylval.lex.tpe  = TYPE_void;	\
			return(X); }
#define Vector(X,Y,V,L)	{ yylval.lex.token= X;	\
			yylval.lex.tpe  = Y;	\
			if( V != 0 ) \
			yylval.lex.val = GDKstrdup(V);  	\
			yylval.lex.len = L;	\
			return(X); }
%}

%%
"#"                   { return mal_skipcomment();                      }
("atom"|"ATOM")		{ Symbol(TOK_ATOM);}
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, "nil", 3);   }
("end"|"END")       { Symbol(TOK_END);                                  }
("function"|"FUNCTION")	{ Symbol(TOK_FCN);                              }
("end"|"END"){S}+("function"|"FUNCTION")	{ Symbol(TOK_END_FCN); }
("command"|"COMMAND")       { Symbol(TOK_COMMAND);                   }
("ruler"|"RULER")       { Symbol(TOK_RULER);                              }
("pattern"|"PATTERN")       { Symbol(TOK_PATTERN);                        }
("end"|"END"){S}("ruler"|"RULER")	{ Symbol(TOK_END_RULER); }
("end"|"END"){S}("pattern"|"PATTERN")	{ Symbol(TOK_END_PATTERN); }
("agent"|"AGENT")       { Symbol(TOK_AGENT);                   }
("end"|"END"){S}+("agent"|"AGENT")	{ Symbol(TOK_END_AGENT); }
("catch"|"CATCH")     { Symbol(TOK_CATCH);                             }
("raise"|"RAISE")     { Symbol(TOK_RAISE);                          }
("exception"|"EXCEPTION")	{Symbol(TOK_EXCEPTION);			}
("return"|"RETURN")   { Symbol(TOK_RETURN);                            }
("barrier"|"BARRIER")     { Symbol(TOK_BARRIER);                       }
("redo"|"REDO")     { Symbol(TOK_REDO);         }
("leave"|"LEAVE")     { Symbol(TOK_LEAVE);                             }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, "false", 1);        }
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, "true", 1);        }
("module"|"MODULE")   { Symbol(TOK_MODULE);			     }
("use"|"USE")   { Symbol(TOK_USE);			     }
":="                  { Symbol(TOK_ASSIGN);                         }
"any"{S}"::"{S}[1-9]{D}*	{ Vector(TOK_ANY_VAR,TYPE_str,yytext,yyleng);}
"ANY"{S}"::"{S}[1-9]{D}*	{ Vector(TOK_ANY_VAR,TYPE_str,yytext,yyleng);}
"`"                   { Symbol(TOK_REVERSE);                         }
"."                   { Symbol(TOK_DOT);                         }
"..."		      { Symbol(TOK_VA_LIST);			}
{IDENT}		      { Vector(TOK_IDENT, TYPE_str, yytext,yyleng);	      }
(":"{OPER}"=")	|
({OPER}"="?) 	      { Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng);	      }
("-")?{D}+(":lng") 	|
("-")?{D}+"LL"        { Vector(TOK_CONSTANT, TYPE_lng, yytext, yyleng);}
("-")?{D}+(":int")?	{ Vector(TOK_CONSTANT, TYPE_int, yytext, yyleng);}
("-")?{D}+(":sht")	{ Vector(TOK_CONSTANT, TYPE_sht, yytext, yyleng);}
{D}+"@"{D}+           { Vector(TOK_CONSTANT, TYPE_oid, yytext, yyleng);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { Vector(TOK_CONSTANT, TYPE_dbl,  yytext, yyleng);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { Vector(TOK_CONSTANT, TYPE_flt,  yytext, yyleng);         }
"'"\\0{O}({O})?({O})?"'" {Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);        }
\"[^"]*\"		{
                        if (yytext[yyleng-1] != '\\') {
				yytext[yyleng-1]=0;
                                Vector(TOK_CONSTANT, TYPE_str, yytext+1, yyleng-2);
                        } else {
				yymore(); 
			}					                     }
\'[^\n\']*\'            { 
                        if (yytext[yyleng-1] != '\\') {
                                Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng-1);
                        } else {
                                yymore(); 
                        }                                                     }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int mal_skipcomment() { 
	char c; 
	while ((c=input()) && (c != '\n') && (c != EOF)); 
	return yylex();
}
int yywrap(){ return 1;}

void mal_flushbuffer() {
        YY_FLUSH_BUFFER;
}

@
@- Input management
The parser reads its input from a string buffer space.
Unlike MIL, we assure that 'import' statements are top
level commands. They do not occur within a procedure.
Furthermore, there is no real reason to produce a listing, because
this is a property of the client interface. It would also
delay processing when run in a critical section.
For the time being we keep it as a debugging option.

@c
#include "mal_type.h"
#include "mal_parser.h"
#include "mal_function.h"
#include "mal_linker.h"
#include "mal_atom.h"

#define MAL_TRACE

typedef struct _strstack_t {
	str buf, cptr, prevline, nxtline;
#ifdef MAL_TRACE
	int listing;		/* trace line consumption */
#endif
	struct _strstack_t *up;
} strstack;

static strstack  *mal_stack = NULL;

int getListing(){ return mal_stack->listing;}

int mal_push(str s,int listing) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
#ifdef MAL_TRACE
	sp->listing = listing;
#endif
	sp->cptr = sp->nxtline= sp->prevline = sp->buf = s;  
	sp->up = mal_stack;
	mal_stack = sp;
	return 1;
}

void freeStringStack(){
	GDKfree(mal_stack);
	mal_stack = NULL;
}
int mal_pop() {
	strstack *sp = mal_stack;
	if (mal_stack) {
		mal_stack = sp->up;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

@-
The next character is retrieved from the string pool
using the routine mal_getch. The position of the last
newline is retained to gain quick access for debugging.
@c
int mal_getch() {
        char ch;
	ch = *mal_stack->cptr;
        if (ch == '\n' || mal_stack->cptr==mal_stack->buf) {
#ifdef MAL_TRACE
                if (mal_stack->listing) { 
			char *c= mal_stack->cptr;
			if( ch=='\n') c++;
			fputs("#",GDKout);
			while(*c && *c != '\n'){
				fputc(*c++,GDKout);
			}
                        fputc('\n', GDKout);
                        fflush(GDKout);
                }
#endif
		mal_stack->prevline= mal_stack->nxtline;
                mal_stack->nxtline = mal_stack->cptr + 1;
        } 
        if (ch) mal_stack->cptr++;
        return ch;
}

@-
For error reporting we have to find the start of the previous line,
which, ofcourse, is now easy.
@c
str mal_lastline(){ 
	if( mal_stack->nxtline == 0)
		return mal_stack->prevline;
	return mal_stack->nxtline; 
}
int mal_position()
{
	return (int)(mal_stack->cptr)- (int)mal_stack->nxtline;
}

@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

Each call to the parser produces a MAL procedure in the current
session module. The parser should be supplied the complete string
to be parsed, because it runs in a critical section and can not
retain information between calls for the same client.

The curScope determines the context for insertion of new
procedure and command definitions. 
It provides the anchor for traversing the scope lists.
@c

Symbol mal_parse(Symbol cntxt, str buf, int listing){
	curScope= cntxt;
	mal_push(buf,listing);
	if( yyparse()) {
		printf("ok?");
	}
	mal_pop();
	return curPrg;
}
@- The Bison Grammar
The grammar has been designed for simplicity and it is straight forward.
@y
%token_table
/* %pure_parser */

%{
#include "mal_parser.h"

#define YYDEBUG 1
#define YYERROR_VERBOSE 1

#undef yyerror
#define yyerror(X)      { mal_parserror(X);  }

#define YYPRINT(file,chr,val)	mal_print(file,chr,val)
int yydebug = 0;
void debugParser(int i){ yydebug=i; }

@-
The variables below represent the state of the parsing process.
It is a 'path' through the symbol table structure.
They should be saved and restored when parsing is interrupted
to handle import statements.
@y
Symbol	curScope,curPrg;
MalBlkPtr curBlk;
InstrPtr curInstr;
int atomModule = FALSE;
%}

%type <stmt>	stmt fcnCall 
%type <lex>	pathHdr rulerProc factor term assign modList melElement
%type <lex>	TOK_IDENT TOK_OPERATOR TOK_CONSTANT TOK_ANY_VAR 
%type <lex>	malType fcnType fcnNameId cntrl modfile importPath

%token TOK_FCN TOK_RULER TOK_PATTERN TOK_AGENT TOK_END TOK_ANY_VAR  TOK_RETURN
%token TOK_BARRIER TOK_REDO TOK_LEAVE TOK_RAISE TOK_CATCH TOK_EXCEPTION
%token TOK_CONSTANT TOK_IDENT TOK_VA_LIST
%token TOK_DOT TOK_REVERSE TOK_OPERATOR TOK_PRECEEDS TOK_ASSIGN 
%token TOK_MODULE TOK_ATOM TOK_USE TOK_COMMAND
%token TOK_END_FCN TOK_END_RULER TOK_END_PATTERN TOK_END_AGENT

%left TOK_BARRIER TOK_ASSIGN TOK_OPERATOR TOK_PRECEEDS
%left TOK_REVERSE
%left TOK_DOT
%%
MAL_program:
	module defineList
	{ curPrg= newFunction(curScope,GDKstrdup("main"));
	  curBlk = curPrg->def;
	  curInstr = getSignature(curPrg);
	  curInstr->modname= GDKstrdup(curScope->name);
	  insertSymbol(curScope,curPrg);
	}
	stmtList
	{ curInstr= newInstruction(curBlk,ENDDEFsymbol);
	  curInstr->argc =0;
	  pushInstruction(curBlk,curInstr);
	  safeFunction(curPrg);
	  if(getListing()) printFunction(stdout, curBlk);}
    |	module
	{ curPrg= newFunction(curScope,GDKstrdup("main"));
	  curBlk = curPrg->def;
	  curInstr = getSignature(curPrg);
	  curInstr->modname= GDKstrdup(curScope->name);
	  insertSymbol(curScope,curPrg);
	}
	stmtList
	{ curInstr= newInstruction(curBlk,ENDDEFsymbol);
	  curInstr->argc =0;
	  pushInstruction(curBlk,curInstr);
	  safeFunction(curPrg);
	  if(getListing()) printFunction(stdout, curBlk);}
@-
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.
@y
module:
      	moduleModifier TOK_MODULE modfile ';'
	{ 
	  if( findScope(curScope,$3.val) != NULL){
		char buf[1024];
		sprintf(buf,"ERROR: duplicate module load '%s' ignored\n",
			$3.val);
		GDKerror(buf);
		GDKfree($3.val);
		/* cleanup input */
		YYACCEPT;
	  } else {
		curScope = fixateScope(curScope, $3.val);
		GDKfree($3.val);
	  }
	}
	exceptionList
   | 	/* empty, default module */

moduleModifier: TOK_ATOM { atomModule = TRUE;}
	| /* empty */	{ atomModule = FALSE;}
modfile: TOK_IDENT 
	{
		if( atomModule) malAtomDef($1.val);
		$$= $1;
	}
   |	TOK_CONSTANT

defineList:   defineStmt
    |	defineList defineStmt

defineStmt : functionDef {if(getListing()) printFunction(stdout,curBlk);}
    |	commandDefinition 
	{if(getListing()) printFunction(stdout,curBlk);}
    |   rulerDefinition 
	{ if(getListing()) printFunction(stdout,curBlk);}
    |	importStmt

exceptionList: TOK_EXCEPTION TOK_IDENT ';'
	| /* empty */

importStmt:
    	TOK_USE importPath ';'
	{ Symbol    oldScope= curScope,oldPrg=curPrg;
	  MalBlkPtr oldBlk=curBlk;
	  InstrPtr oldInstr=curInstr;
	  (void) malImport(curScope,$2.val,$2.val,getListing());
	  yyclearin; yyerrok;
	  curScope = oldScope;
	  curPrg = oldPrg;
	  curBlk = oldBlk;
	  curInstr = oldInstr;
	  GDKfree($2.val);
	}
importPath: TOK_IDENT
   |	TOK_CONSTANT
   |	importPath TOK_OPERATOR TOK_IDENT
	{ char buf[PATHLENGTH];
	  sprintf(buf,"%s/%s",$1.val,$3.val);
	  $$.val= GDKstrdup(buf);
	  if( $2.val[0] !='/')
		GDKerror("ERROR: path separator in use-clause expected\n");
	}
@-
The statements scattered between definitions are appended and collected
in a 'main' procedure. This procedure definition should be
re-used to avoid overhead in procedure declaration for each individual
instruction obtained from the used.
@y

commandDefinition:
	TOK_COMMAND fcnHeader ';' helpInfo 
	{ getInstrPtr(curBlk,0)->token= COMMANDsymbol;
	  curPrg->kind = COMMANDsymbol;
	  resolveFunction(curPrg);
	  insertSymbol(curScope,curPrg);
	}
   |    TOK_PATTERN fcnHeader ';' helpInfo 
	{ getInstrPtr(curBlk,0)->token= PATTERNsymbol;
	  curPrg->kind = PATTERNsymbol;
	  resolveFunction(curPrg);
	  insertSymbol(curScope,curPrg);
	}

functionDef :
	TOK_FCN fcnHeader ';' helpInfo 
	{ insertSymbol(curScope,curPrg); }
	stmtList TOK_END_FCN ';' 
	{ curInstr= newInstruction(curBlk,ENDDEFsymbol);
	  pushInstruction(curBlk,curInstr);
	  safeFunction(curPrg);
	}


helpInfo: TOK_CONSTANT
	{ curPrg->help= $1.val;}
    |	/* empty */

stmtList :
	statements
	{ resolveFunction(curPrg); }
    |	/* none */

statements:
        stmt ';'
	{ pushInstruction(curBlk,curInstr);  
	  curInstr=0;
	}
    |   statements stmt ';'
	{ pushInstruction(curBlk,curInstr); 
	  curInstr=0; 
	}
    |	error TOK_IDENT  
	{ GDKfree($2.val);
	  printf("parse error\n");
	}
    |	error TOK_CONSTANT  
	{ GDKfree($2.val);
	  printf("parse error\n");
	}
    |	error TOK_OPERATOR  
	{ GDKfree($2.val);
	  printf("parse error\n");
	}
    |   error ';' { yyerrok; yyclearin; 
	 if(curInstr){
		/* printf("RECOVER:");*/
		printInstruction(stdout,curBlk,curInstr);
		freeInstruction(curInstr);
		curInstr = 0;
	} }

stmt: assign  expression
	{ int i;
	  if( (i=findVariable(curBlk,$1.val)) == -1){
		i= newVariable(curBlk, $1.val,malAnyType);
	  } else GDKfree($1.val);
	  curInstr->argv[0]= i;
	}
    |	cntrl TOK_IDENT
	{ int i;
	  curInstr= newInstruction(curBlk,$1.token);
	  i = findVariable(curBlk,$2.val);
	  if( i<0)
		i= newVariable(curBlk, $2.val,malAnyType);
	  else GDKfree($2.val);
	  curInstr->argv[0]= i;
	}
    |	TOK_CATCH TOK_IDENT
	{ int i;
	  curInstr= newInstruction(curBlk,CATCHsymbol);
	  i = findVariable(curBlk,$2.val);
	  if( i<0)
		i= newVariable(curBlk, $2.val,TYPE_str);
	  else	GDKfree($2.val);
	  curInstr->argv[0]= i;
	  curInstr->barrier= CATCHsymbol;
	}
   |	TOK_BARRIER TOK_IDENT
	{ int i;
	  curInstr= newInstruction(curBlk,BARRIERsymbol); 
	  i = findVariable(curBlk,$2.val);
	  if( i<0)
		i= newVariable(curBlk, $2.val,TYPE_bit);
	  else GDKfree($2.val);
	  curInstr->argv[0]= i;
	  curInstr->barrier= BARRIERsymbol;
	}
   |	TOK_RAISE TOK_IDENT
	{ int i;
 	  curInstr= newInstruction(curBlk,RAISEsymbol); 
	  i = findVariable(curBlk,$2.val);
	  if( i<0)
		i= newVariable(curBlk, $2.val,TYPE_str);
	  else GDKfree($2.val);
	  curInstr->argv[0]= i;
	  curInstr->barrier= RAISEsymbol;
	}

cntrl: TOK_END {$$.token= ENDsymbol;}
   |	TOK_LEAVE {$$.token= LEAVEsymbol;}
   |	TOK_REDO {$$.token= REDOsymbol;}
   |	TOK_RETURN {$$.token= RETURNsymbol;}

assign:
	TOK_IDENT  TOK_ASSIGN 
	{ curInstr = newInstruction(curBlk,ASSIGNsymbol); $$=$1; }
    |	TOK_BARRIER TOK_IDENT TOK_ASSIGN
	{ curInstr= newInstruction(curBlk,ASSIGNsymbol); $$=$2;
	  curInstr->barrier= BARRIERsymbol;
	}
    |	TOK_RAISE TOK_IDENT TOK_ASSIGN
	{ curInstr= newInstruction(curBlk,ASSIGNsymbol); $$=$2;
	  curInstr->barrier= RAISEsymbol;
	}
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.
@y
fcnHeader: 
	fcnName fcnParamList fcnType fcnDefinition

fcnParamList:
	'(' fcnParams ')' 
    |   '(' fcnParams TOK_VA_LIST ')'
	{ pushArgument(curInstr, newVariable(curBlk,GDKstrdup(malVARG), TYPE_any)); }
    |	'(' ')' 

fcnType:
	':' malType		{ getVarType(curBlk,0)= $2.tpe;}
	| ':' '{' malType properties '}' {getVarType(curBlk,0)=$3.tpe;}
    	| /* empty, default */ 	{ getVarType(curBlk,0)= malAnyType; }
@-
Variables will later be extended with a (boolean?) property list to enable
squeezers to make decisions. An example is :(int, key, notnull) for
a column of a BAT.
@y
properties: propList
   |	 /* empty */

propList: ',' TOK_IDENT
    |	propList ',' TOK_IDENT
	

fcnName:
	fcnNameId
	{ curPrg = newFunction(curScope,$1.val);
	  curBlk = curPrg->def;
	  curInstr = getInstrPtr(curBlk,0);
	}

fcnParams:
        binding
    |   fcnParams ',' binding

fcnDefinition :
	TOK_OPERATOR TOK_IDENT
	{int i;
	  if( strcmp($1.val,"=") )
		mal_parserror("'=' operator expected\n");
	  i= newVariable(curBlk,$2.val,curBlk->var[0].type);
	  curInstr->argv[0]=i;
	  curInstr->modname = GDKstrdup(curScope->name);
	  curInstr->fcn = getAddress($2.val);
	  curPrg->binding = GDKstrdup($2.val);
	  if( atomModule)
		defAtomCommand(curInstr);
	}
    | /* empty */
@- 
Rule construction follows much the same route as procedure
declarations. They are only interpreted differently.
[Rules should be dealt with differently]
@y
rulerDefinition :
	rulerHeader rulerParams ';' stmtList 
	{ safeFunction(curPrg); }
	TOK_END_RULER ';'
    |	rulerHeader rulerParams '?' term ';' stmtList 
	{ safeFunction(curPrg); }
	TOK_END_RULER ';'

rulerHeader: TOK_RULER TOK_IDENT
	{ curPrg = newFunction(curScope,$2.val); 
	  curBlk = curPrg->def;
	  curInstr = newInstruction(curBlk,RULERsymbol); 
	  curInstr->fcnname= GDKstrdup($2.val);
	  insertSymbol(curScope,curPrg);
	  pushInstruction(curBlk, curInstr); } 

rulerParams:
	pattern
    | 	rulerParams TOK_PRECEEDS pattern

pattern:
	binding
	{}
    |	rulerStart rulerProc fcnParamList fcnType
	{}

rulerStart:
	TOK_IDENT TOK_ASSIGN
	{ GDKfree($1.val);}

rulerProc: TOK_IDENT 
	{ GDKfree($1.val);}
	| TOK_OPERATOR
	{}

@-
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.
@y
binding:
	TOK_IDENT ':' malType 
	{ pushArgument(curInstr, newVariable(curBlk,$1.val, $3.tpe)); }
@-
The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in rules, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about the resulting type structure.
@y

malType:
        melElement
	{  $$=$1;
	}
    |   TOK_IDENT '[' melElement ',' melElement ']'
	{ 
	  if( strcmp($1.val,"bat")!= 0 && strcmp($1.val,"BAT")!= 0 )
		  mal_parserror("Bat expected\n");
	  $$.tpe = malAnyBatType($3.tpe,$5.tpe);
	  GDKfree($1.val);
	  $$.val =0;
	}

melElement:
        TOK_IDENT 
	{ $$.tpe = getTypeIndex($$.val);
	  GDKfree($1.val);
	  $$.val = 0; 
	}
    |   TOK_ANY_VAR
	{ int i= atoi(rindex($1.val,':')+1);
	  $$.tpe= malAnyType;
	  setAnyTailIndex($$.tpe,i);
	  GDKfree($1.val);
	  $$.val = 0; 
	}
@-
The curInstr always has to point to the last instruction generated.
All other information is passed around as a variable identifier
in the semantic part.
@y
expression: 
	term	{}
    |	fcnCall	{}

term :
	factor
	{ pushArgumentId(curInstr, $1.val); $$=$1; }
    |	factor TOK_OPERATOR factor
	{ curInstr->fcnname = $2.val;
	  pushArgumentId(curInstr, $1.val);
	  pushArgumentId(curInstr, $3.val);
	}
    |	TOK_OPERATOR factor
	{ curInstr->fcnname = $1.val;
	  pushArgumentId(curInstr, $2.val);
	}

factor:
        TOK_CONSTANT
	{ $$.val= newConstant(curBlk,$1.tpe,$1.val);
	  $$.tpe= $1.tpe;
	}
     | TOK_CONSTANT ':' malType
	{ int i,j;
	  $$.val= newConstant(curBlk,$1.tpe,$1.val);
	  /* enforce coercion if needed */
	  i= findVariable(curBlk,$$.val);
	  if( (j=coercion(getVarType(curBlk,i),$3.tpe)) == malAnyType){
		GDKerror("ERROR: illegal coercion\n");
	  } else getVarType(curBlk,i)= j;
	  $$.tpe= j;
	}
    |  	pathHdr
	{ $$.val= $1.val;
	  $$.tpe= getType(curBlk,$1.val);
	}

pathHdr :
      	TOK_IDENT 
	{$$=$1;}
    |	TOK_REVERSE TOK_IDENT
	{ $$.val = reverseOperator(curScope,curBlk,$2.val);
	  $$.tpe = getType(curBlk,$$.val); 
	}


fcnCall :
	fcnNameId fcnArg
	{ curInstr->fcnname= $1.val; 
	}
	| modList TOK_DOT fcnNameId fcnArg
	{ curInstr->fcnname= $3.val;
	  curInstr->modname= $1.val;
	}
 
modList : TOK_IDENT
    |	modList TOK_DOT TOK_IDENT
	{ char buf[2000]; strcpy(buf,$1.val); GDKfree($1.val);
	  strcat(buf,$3.val); GDKfree($3.val); $1.val= GDKstrdup(buf); 
	  $$ = $1; }
	
fcnArg : '(' ')'
	{ curInstr->argc =1 ;}
	| '(' varList ')'
	{}

fcnNameId: TOK_IDENT | TOK_OPERATOR

varList:
     	factor
	{ pushArgumentId(curInstr, $1.val);}
    |	varList ',' factor
	{ pushArgumentId(curInstr, $3.val); }
    |   TOK_IDENT '[' TOK_IDENT ',' TOK_IDENT ']'
	{ if( strcmp($1.val,"bat") != 0 && strcmp($1.val,"BAT")!=0 ){
		mal_parserror("bat[X,Y] expected\n");
	  }
	  pushArgument(curInstr, newVariable(curBlk,$1.val,
		  newBatType( getTypeIndex($3.val), getTypeIndex($5.val)) ));
	  GDKfree($3.val); GDKfree($5.val);
	}
%%

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@{
@y
void mal_parserror(str msg){
	char buf[1024];
	char *s=buf, *t, *l = mal_lastline();
	int i = strlen(GDKERROR);
	strcpy(buf,GDKERROR); s+= i; 

	if(curBlk) curBlk->errors++;
	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
        for(t=l; *t && *t!='\n'; t++) {
                if (*t == '%') *s++ = '%';
                *s++ = *t;
        }
        *s++ = '\n';

	/* produce the position marker*/
        for(*s++ = '!'; --i > 0; ) *s++ = ' ';
	i = mal_position();
        for(; i > 0; i--) {
                *s++ = (*l++ != '\t')?' ':'\t';
        }
        *s++ = '^'; *s++ = '\n'; *s = 0;

	/* include bison message*/
        if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if( strlen(msg)+strlen(buf) < 1020)
		sprintf(s, "! %s.\n", msg);
        GDKerror(buf);

	mal_flushbuffer(); /* flush the lexer's buffer */
}

int mal_print(FILE *f, char tpe, YYSTYPE v)
{
	if( v.lex.len >0) fprintf(f," %s ", v.lex.val);
	return 0;
}
const char *mallexname(int Y)           
{ 	if (Y >= TOK_FCN && Y <= TOK_AGENT) {
		return yytname[Y-TOK_FCN];
	} 
	return "char";
}
@}

