@t MAL dynamic loading and execution
@a M. Kersten
@v 0.0
@* Introduction
In line with previous versions of Monet it is possible to extend
the functionalty using user-defined modules. The corresponding code
is dynamically loaded when the MAL import command is encountered 
from a specific file-system location.
The user-defined modules recide in the library  MONETPREFIX/<dbname>/lib/, 
they are recognized  as lib_<modulename>.so names.
The corresponding signature files are maintained 
in MONETPREFIX/<dbname>/mal/<modulepath>/<modulename>.mal.

[reminder, directory structure of a database dir:
.../bat
.../bin		# database specific binaries
.../include	# all files needed for a compilation of an application
.../lib		# all libraries (or symbolic links) ,,
.../mal		# all scripts needed by the MAL interpreter
.../mil		# scripts in MIL format
.../sql
]
Mcreatedb should assess existence of a link-to/copy-of the distributed
modules (eg algebra,arithm,..). Alternatively, the library should be
reachable using the LD_LIBRARY environment or recide in /usr/lib or /lib

The rationale for this set-up is that database administrators can
extend/overload the modules loaded without affecting the distributed
software package. They are responsible for a proper administration of
the source tree of the user-defined modules.
This scheme also forces database administrators to maintain separate
databases to test out enhanced modules. They can share an existing
database using symbolic links to the database GDK  directory, but this
is not recommended for purpose of database integrity and safety.
It is better to develop and test a module on a copy/subset of a production
database first.

The scheme also isolates the functionality embedded in modules from
inadvertise use on non-compliant databases.
[access control issue, how to limit what a user can do on a database?
first solution, static decision by squeezer]

Unlike previous versions of Monet, dynamically loaded modules can not 
be unloaded. Dynamic libraries are always global and, therefore, it
is best to load them as part of the server initialization phase.
(sever_start.mal)

The MAL program should be compiled with -rdynamic and -ldl.
This enables loading the routines and finding out the address
of a particular routine

For the time being we assume that all commands are statically linked,
because we now focus on the squeezer.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_LINKER_H
/* #include "monet.h"*/
#include "mal_instruction.h"
#include "mal_symbol.h"
#include <dlfcn.h>

/*#define DEBUG_MAL_LINKER */
#define MONET64 1
mal_export void 	*getAddress(str fcnname);
mal_export void 	*loadModuleLibrary(str modname);
mal_export int 	initLibraries(str dbname);

#endif
@+ Function binding
The mapping from MAL module.function() identifier to an address is
resolved in the function getAddress. Since all modules libraries are loaded
completely with GLOBAL visibility, it suffices to provide the internal function 
name.
Note, however, that the libraries are reference counted. Although we
do;t close them until end of session it seems prudent to maintain
the consistency of this counter.
@c
#include "mal_linker.h"

void *getAddress(str fcnname){
	void *dl;
	void (*adr)();
	str msg;

#ifdef DEBUG_MAL_LINKER
        printf("addres of %s ?\n", fcnname);
#endif
        dl= dlopen(NULL, RTLD_NOW | RTLD_GLOBAL);
        if(dl==NULL){
                GDKfatal("getAddress:can;t get dl-handle\n");
                exit(0);
        }
        adr= dlsym(dl,fcnname);
	msg= dlerror();
#ifdef DEBUG_MAL_LINKER
	if( adr != NULL)
        printf("addres of %s %o %s\n", fcnname,(int) adr, (msg?msg:""));
#endif
	dlclose(dl);
	return adr;
}

@+ Module loading
The first location to search for the module is the database for which
the server has been started, i.e. look into MONETPREFIX/<dbname>/lib.

Loading further relies on the Linux policy to search for the module
location in the following order: 1) the colon-separated list of
directories in the user's LD_LIBRARY, 2) the libraries specified
in /etc/ld.so.cache, and 3) /usr/lib followed by /lib
If the module contains a routine _init, then that code is executed
before the loader returns. Likewise the routine _fini is called just
before the module is unloaded.

A module loading conflict emerges if a function is redefined.
A duplicate load is simply ignored.
@c
#define LIBPATH "lib/Monet"

void *loadModuleLibrary(str modname){
	char buf[MAXPATHLEN];
	void *handle = NULL;
	str path ="";
	str library=0;
	str msg= NULL;

	if( (library=strrchr(modname,DIR_SEP))  != NULL){
		*library=0;
		library++;
		path = modname;
	} else library= modname;

#ifdef DEBUG_MAL_LINKER
	printf("load module:path=%s, library=%s\n",library,modname);
#endif
	if( modname != NULL && modname[0]!='/') {
		sprintf(buf,"%s/lib/lib_%s.so", GDKdirStr, library);
		SLASH_2_DIR_SEP(buf);
#ifdef DEBUG_MAL_LINKER
	printf("loadModuleLibrary:%s\n",buf);
#endif
		if( access(buf,R_OK)== 0) {
			handle = dlopen(buf, RTLD_NOW | RTLD_GLOBAL);
			msg =dlerror();
			if(handle!= NULL && msg != NULL){
				sprintf(buf,"loadModuleLibrary(1):%s\n",msg);
				GDKerror(buf);
				return NULL;
			}
#ifdef DEBUG_MAL_LINKER
			printf("loadModuleLibrary:succeeded\n");
#endif
			return handle;
		}
	} 
#ifdef DEBUG_MAL_LINKER
	printf("try distribution\n");
#endif
	sprintf(buf,"%s/%s/lib_%s.so", GDKdistrStr, LIBPATH, library);
	SLASH_2_DIR_SEP(buf);
	if( access(buf,R_OK) == 0) {
		handle = dlopen(buf, RTLD_NOW | RTLD_GLOBAL);
		msg= dlerror();
		if( handle==NULL && msg != NULL){
			printf("load:%s:%s\n",buf,handle==NULL?"failed":"succeeded");
			sprintf(buf,"loadModuleLibrary(2):%s\n", msg);
			GDKerror(buf);
			return NULL;
		}
	}
#ifdef DEBUG_MAL_LINKER
	printf("load:%s:%s\n",buf,handle==NULL?"failed":"succeeded");
#endif
	return handle;
}
@+ Static loading
Upon system restart a few system libraries are loaded before
the first user-specific script is interpreted. These form the
system kernel and its functionaltiy is needed to setup
server-speciific administration tables.

@= systemLoad
	malImport(mal_scope,@1,0,1);
@c
int initLibraries(str dbname) {
	@:systemLoad("kernel/arith")@
	@:systemLoad("kernel/bat")@
	@:systemLoad("kernel/atoms")@
	@:systemLoad("kernel/algebra")@
	@:systemLoad("kernel/system")@
	return 0;
}

