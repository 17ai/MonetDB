@t Mal type utilities
@a M. Kersten
@v 0.0
@* Introduction
The MAL type module overloads the atom structure managed in the GDK
library. In particular, it encodes bat type information in a single
long to safe space. Actually, it makes sense to include the built-in
type BAT in GDK.

For the time being we assume GDK to support at most 255 different
atomic types. If this grows, then the encoding scheme presented
below permits 2^15 different bat types at most
Beware the malAnyType is a speudo type known within MAL only.
@h
#ifndef MAL_TYPE_H
#define MAL_TYPE_H
#include "gdk.h"

/*#define DEBUG_MAL_TYPE*/
#define GDKerror printf

typedef int malType;
#define malVarType -2
#define malAnyType 255

#define newBatType(H,T)  (1<<16 | (((H & 0377) <<8) | (T & 0377) ))
#define getHeadType(X)	((X>>8) & 0377 )
#define getTailType(X)	((X) & 0377 )
#define isBatType(X) 	((X)!=malAnyType && (1<<16) & (X))
@-
Procedure type parameters may be qualified by a formal type term any::I ,
where I is a small integer. 
The malType long contains the following fields:
anyHeadIndex (bit 25-22), anyTailIndex (bit 21-18),
batType (bit 17) headType (16-9) and tailType(8-0)

@h
#define setAnyHeadIndex(X,I) X |= ((I & 017)<<22);
#define setAnyTailIndex(X,I) X |= ((I & 017)<<18);
#define isAnyExpression(X) ((X) >> 17)

#define getHeadIndex(X)  (((X)>>22) & 017)
#define getTailIndex(X)  (((X)>>18) & 017)
@-
The symbol/instruction kinds are introduced here instead of reusing the defines 
derived from the parser to avoid a loop in the define-structure.
@h
#define NOOPsymbol 	20
#define ASSIGNsymbol 	21
#define RAISEsymbol 	23
#define CATCHsymbol 	24
#define RETURNsymbol 	25
#define BARRIERsymbol	26
#define REDOsymbol	27
#define LEAVEsymbol	28
#define IMPORTsymbol	30	/* dependency on outer scopes */
#define COMMANDsymbol   31
#define FUNCTIONsymbol	32
#define RULERsymbol	33
#define ENDDEFsymbol	34
#define THRDsymbol	43
#define COMMENTsymbol	35	/* propagation of comments */
#define ENDsymbol 	36
#define SCOPEsymbol	41
#define PUSHsymbol	42	/* move constant to stack */

#define FCNcall		50	/* determines interpreter action*/
#define RLRcall		51
#define CMDcall		52
#define THRDcall	53

extern str malTypeName(malType tpe);
extern malType coercion(malType t1, malType t2);
extern int getTypeIndex(str nme);
extern malType reverseBatType(malType v);
extern malType malAnyBatType(malType t1, malType t2);
#endif /* MAL_TYPE_H*/
@-
At any point we should be able to construct an ascii representation of
the type descriptor. Including the variable references.
@c
#include "mal_type.h"

str malTypeName(malType tpe)
{
#ifdef DEBUG_MAL_TYPE
	printf("maltype: %d %d %d",tpe,getHeadTypeType(tpe),getTailType(tpe));
	printf("	: %d\n",isBatType(tpe));
#endif
	if( tpe == malAnyType ) return GDKstrdup("any");
	if( tpe == malVarType ) return GDKstrdup("var");
	if( isBatType(tpe)){
		char buf[1024],*s;
		if( getHeadIndex(tpe) ){
			sprintf(buf,"bat[any::%d,", getHeadIndex(tpe));
		} else
		if( getHeadType(tpe) == malAnyType) 
			sprintf(buf,"bat[any,");
		else
			sprintf(buf,"bat[%s,", ATOMname(getHeadType(tpe)));
		s= buf+strlen(buf);
		if( getTailIndex(tpe) ){
			sprintf(s,"any::%d]", getTailIndex(tpe));
		} else
		if( getTailType(tpe) == malAnyType) 
			sprintf(s,"any]");
		else
			sprintf(s,"%s]", ATOMname(getTailType(tpe)));
#ifdef DEBUG_MAL_TYPE
		printf("%s\n",buf);
#endif
		return GDKstrdup(buf);
	} 
	if( isAnyExpression(tpe) ){
		char buf[256];
		strcpy(buf,"any");
		if( isAnyExpression(tpe)){
			sprintf(buf+3,"::%d",getTailIndex(tpe));
		}
		return GDKstrdup(buf);
	}
	return GDKstrdup(ATOMname(tpe));
}

malType malAnyBatType(malType t1, malType t2){
	int t; 
	t= newBatType(getTailType(t1),getTailType(t2));

	if( getTailIndex(t1)){ 
		setAnyHeadIndex(t, getTailIndex(t1));
	} 
	if( getTailIndex(t2)){ 
		setAnyTailIndex(t, getTailIndex(t2));
	} 
	return t;
}

malType reverseBatType(malType v){
	str d1= malTypeName(newBatType(getHeadType(v),getTailType(v))),
	d2=	malTypeName(newBatType(getTailType(v),getHeadType(v)));
	printf("reverseBatType %d %s %s",v,d1,d2);
	GDKfree(d1); GDKfree(d2);
	return newBatType(getTailType(v),getHeadType(v));
}
@+ Type coercion
The coercion scheme below should at some point be added to the GDK kernel.
@c
int  gdkCoercionTable[12][12] ={
/* 		void bit chr sht bat int 
		oid ptr flt dbl lng str */
/* void */
		{TYPE_void, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* bit */
		{TYPE_any, TYPE_bit,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* chr */
		{TYPE_any, TYPE_any,TYPE_chr,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* sht */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_sht,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* bat */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_bat,TYPE_any,
		TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* int */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* oid */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_int,
		TYPE_oid, TYPE_any,TYPE_any,TYPE_int,TYPE_any,TYPE_str},
/* ptr */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_ptr,TYPE_any,TYPE_any,TYPE_any,TYPE_str},
/* flt */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_any,TYPE_str},
/* dbl */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_any,TYPE_any,TYPE_any,
		TYPE_any, TYPE_any,TYPE_dbl,TYPE_dbl,TYPE_any,TYPE_str},
/* lng */
		{TYPE_any, TYPE_any,TYPE_any,TYPE_lng,TYPE_any,TYPE_lng,
		TYPE_any, TYPE_any,TYPE_flt,TYPE_dbl,TYPE_lng,TYPE_str},
/* str */
		{TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str,
		TYPE_str, TYPE_str,TYPE_str,TYPE_str,TYPE_str,TYPE_str}
};
@-
Coercion is defined in terms of malType structures, which means
that we have to be prepared to deal with type variables as well.
@c

malType coercion(malType t1, malType t2){
	if( t1==t2) return t1;
	if( t1 <0 || t1>=TYPE_str) return t1;
	if( t2 <0 || t2>=TYPE_str) return t2;
	return gdkCoercionTable[(int)t1][(int)t2];
}
@+ Some utilities 
In many places we need a confirmed type identifier.
GDK returns the next available index when it can not find the type.
This is not sufficient hier, an error message may have to be generated.
It is assumed that the type table does not change in the mean time.
@c
int getTypeIndex(str nme){
	int i;
	i= ATOMindex(nme);
	/* printf("getTypeIndex %s %d %d\n",nme,i, GDKatomcnt);*/
	if( strcmp("any",nme)==0) return malAnyType;
	if( i== -GDKatomcnt){
		i = malAnyType;
	}
	return i;
}
