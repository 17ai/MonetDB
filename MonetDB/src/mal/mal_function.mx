@t MAL functions
@a M. Kersten
@v 0.0
@+ MAL functions
MAL functions are represented by MAL instruction lists.
The first instruction contains the signature.

The representation of the MAL functions is rather traditional,
using C-structure to collect the necessary information.
Moreover, we assume that MAL functions are relatively small, up to
a few hundred of instructions. This assumption makes us to rely on
linear scans as it comes to locating information of interest.

The information maintained for each MAL function should both
be geared towards fast execution and to ease symbolic debugging.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_FCN_H
#define _MAL_FCN_H

#include "mal_scope.h"

/* #define DEBUG_MAL_FCN */

mal_export Symbol	newFunction(str nme);
mal_export void		clearFcn(MalBlkPtr m);
mal_export int getPC(MalBlkPtr mb, InstrPtr p);

mal_export void	chkBarrier(MalBlkPtr mb, InstrPtr pp);
mal_export void	chkRaise(MalBlkPtr mb, InstrPtr pp);
mal_export void	chkCatch(MalBlkPtr mb, InstrPtr pp);
mal_export void	chkEnd(MalBlkPtr mb, InstrPtr pp);
mal_export void chkLabel(MalBlkPtr mb, InstrPtr p);
mal_export InstrPtr newCall(MalBlkPtr m, str modname, str fcnname, int kind);
mal_export Symbol cloneFunction(Scope scope, Symbol proc, MalBlkPtr mb, InstrPtr p);

mal_export str		raiseException(MalBlkPtr mb, int pc, str name, str msg);
mal_export str		raiseException2(str name, str msg);
mal_export void		showException(MalBlkPtr mb, int pc, str name, str msg);
mal_export void	safeFunction(Symbol proc);
mal_export void	restoreFunction(Symbol proc);
mal_export malType  getCommandType(Symbol proc, MalBlkPtr mb, InstrPtr p);
mal_export void 	printFunction(FILE *fd, MalBlkPtr mb);

#define SYMBOLFRAME GDKatomcnt

#endif /*  _MAL_FCN_H*/
@-
The MAL functions are constructed incrementally while parsing the source.
The variable is used to hold the return value.
@c
#include "mal_function.h"

Symbol newFunction(str nme){
	Symbol s;
	InstrPtr p;
	MalBlkPtr mb;
	int i,j;

	s = newSymbol(nme,FUNCTIONsymbol);
	p = newInstruction(s->def, FUNCTIONsymbol);
	p->fcnname = GDKstrdup(nme);
	p->argv[0]= newVariable(s->def,GDKstrdup(nme),malAnyType);
	pushInstruction(s->def,p);
	return s;
}
InstrPtr newCall(MalBlkPtr m, str modname, str fcnname, int kind){
	InstrPtr p;
	p= newInstruction(m,kind);
	p->modname= GDKstrdup(modname);
	p->fcnname= GDKstrdup(fcnname);
	return p;
}
@+ Flow of control
The nesting of BARRIER and CATCH statements with their associated
flow of control primitives LEAVE, RETRY, and RAISE should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.

Check barrier should ensure that both end-points of a block for the
variable referenced in 'pp' exists. In addition, we should ensure
proper weaveing of the begin-end pairs. This can simply be checked by
counting the begin/end pairs. It should balance for every block.
Finally, the destination variable type should be of type 'bit'
@c
int getPC(MalBlkPtr mb, InstrPtr p)
{	int i;
	for( i=0;i<mb->stop; i++)
	if( getInstrPtr(mb,i)==p) return i;
	return -1;
}
int chkBrackets(MalBlkPtr mb, InstrPtr pp, int begBlk)
{	int i, v, endBlk= -1;

	v = pp->argv[0];
	for(i= begBlk+1; i<mb->stop; i++){
		InstrPtr p= getInstrPtr(mb,i);
		if( p->barrier==BARRIERsymbol || p->barrier==CATCHsymbol) {
			if( p->argv[0] != v){
				i= chkBrackets(mb,p,i);
				continue;
			}
			GDKerror("%d: recursive block structure %s %d\n",
					getPC(mb,pp),getVarName(mb,v),begBlk);
			return i;
		}  else if(p->barrier) printf("unexpected barrier %s\n", i);
		if( p->token == ENDsymbol){
			if( p->argv[0] == v) return i;
			mb->errors++;
			GDKerror("%d:end-label '%s' doesnot match '%s'\n",
				/*p->pc*/i,getVarName(mb,p->argv[0]),
				getVarName(mb,v)
				);
			return i;
		} 
	}
	GDKerror("%d: begin-label '%s' without end-label\n", 
		begBlk,getVarName(mb,v));
	mb->errors++;
	return i;
}
void chkCntrl(MalBlkPtr mb, InstrPtr pp)
{	int i, v;

	v = pp->argv[0];
	if( v>=0)
	for(i=0; i<mb->stop;i++){
		InstrPtr p= getInstrPtr(mb,i);
		if( pp == p  && p->barrier && p->argv[0] == v){
			i = chkBrackets(mb,pp,i);
		} 
	}
}
void chkBarrier(MalBlkPtr mb, InstrPtr pp)
{
	chkCntrl(mb,pp);
	if( getArgType(mb,pp,0) != TYPE_bit && getArgType(mb,pp,0)!= malAnyType ){
		GDKerror("%d: barrier '%s' should be of type bit\n",
			getPC(mb,pp),getVarName(mb,pp->argv[0]));
	}
}
void chkCatch(MalBlkPtr mb, InstrPtr pp)
{
	chkCntrl(mb,pp);
}
@-
Loose END-statements should also be catched.
@c
void chkEnd(MalBlkPtr mb, InstrPtr pp)
{	int i, v;

	v = pp->argv[0];
	if( v>=0)
	for(i=0; i<mb->stop;i++){
	InstrPtr p= getInstrPtr(mb,i);
	if( (p->barrier == BARRIERsymbol ||
	     p->barrier == CATCHsymbol) &&
	     p->argv[0] == v){
		return;
	} 
	}
	mb->errors++;
	GDKerror("%d: end-label '%s' without begin-label\n", 
		getPC(mb,pp),getVarName(mb,v));
}
@-
The chkLabel routine assures that REDO, LEAVEs and ENDs are
properly contained within a single guarded- or iterator- block.
@c
void chkLabel(MalBlkPtr mb, InstrPtr pp)
{	int i,k,n, begBlk = -1;

	k= pp->argv[0];
	n = getPC(mb,pp);
	for(i=0; i<mb->stop;i++){
		InstrPtr p= getInstrPtr(mb,i);
		if( p->barrier == BARRIERsymbol && p->argv[0]==k){
			begBlk = i;
		}
		if( p->token == ENDsymbol && p->argv[0]==k) {
			if( begBlk>=0 && n >=begBlk && n<=i) return;
			begBlk= -1;
		}
	}
	mb->errors++;
	GDKerror("%d:label '%s' not in guarded block\n", n,getVarName(mb,k));
}
@+ Function cloning
MAL supports functions defined with type variables.
Each time such a MAL routine is called, a complete copy of
the polymorphic routine is generated, whereafter the type
variables are replaced with concrete types.

Patterns should not be cloned, because the alternative interpretations
are handled by the underlying code fragments.

The function body should be immediately type checked and if
a correct clone can be obtained, returns success by
returning the symbol with the instantiated function.

Beware that polymorphic type variables should be propagated.
This may imply propagation of a type to a component type of
a BAT.
Replace a particular variable, indexed by v
@c
void replaceTypeVar(MalBlkPtr mb, InstrPtr p, malType v, malType t){
	int i,x;
#ifdef DEBUG_MAL_FCN
	printf("replace type variable %d by type %d\n",v,t);
#endif
	for(i=0;i<p->argc; i++)
	if( isPolymorphicArgument(mb,p,i)) {
		x = getArgType(mb,p,i);
#ifdef DEBUG_MAL_FCN
		printf(" %d x= %d\n",i,x);
#endif 
		if( isBatType(x)){
			int head,tail;
			int hx,tx;
			head = getHeadType(x);
			tail = getTailType(x);
			hx = getHeadIndex(x);
			tx = getTailIndex(x);
			if( hx == v && head == malAnyType){
				hx =0;
				head =t;
			}
			if( tx == v && tail == malAnyType){
				tx= 0;
				tail = t;
			}
			x= newBatType(head,tail);
			setAnyHeadIndex(x,hx);
			setAnyTailIndex(x,tx);
			setArgType(mb,p,i,x);
		} else
		if( getTailIndex(x) == v){
			setArgType(mb,p,i,t);
		} 
	}
}

Symbol 	cloneFunction(Scope scope, Symbol proc, MalBlkPtr mb, InstrPtr p){
	Symbol new;
	int i;
	InstrPtr pp;

	/* printf("clone the function %s to scope %s\n",
			proc->name,scope->name);*/
	new= newFunction(GDKstrdup(proc->name));
	new->def = copyMalBlk(proc->def);
	/* now change the definition of the original proc */
	pp = getSignature(new);
	for(i=0;i<pp->argc;i++)
	if( isPolymorphicArgument(new->def,pp,i) ){
		int t = getArgType(mb,p,i);
		int v = getArgType(new->def,pp,i);

		if( isBatType(t) ){
			int head,tail;
			head = getHeadType(t);
			tail = getTailType(t);
			replaceTypeVar(new->def, pp, getHeadIndex(v), head);
			replaceTypeVar(new->def, pp, getTailIndex(v), tail);
		} else
			replaceTypeVar(new->def, pp, getTailIndex(v), t);
	} /* else printf("%d is %d\n",i,getArgType(mb,pp,i));*/
	/* check for errors after fixation , TODO*/
	/* include the function at the proper place in the scope */

	insertSymbol(scope,new);
#ifdef DEBUG_MAL_FCN
	printf("newly cloned function added to %s %d \n",scope->name,i);
	printFunction(stdout,new->def);
#endif
	return new;
}
@- Exception handling
@c
str raiseException(MalBlkPtr mb, int pc, str name, str msg){
        char buf[2048];
        if( strlen(name)+strlen(msg)+2 <1024)
                sprintf(buf,"%s:%s.%s[%d]:%s", name, getModName(mb),
			getFcnName(mb),pc,msg);
        else    sprintf(buf,"%s:%s.%s[%d]",name, getModName(mb),
			getFcnName(mb),pc);
        return GDKstrdup(buf);
}
str raiseException2(str name, str msg){
        char buf[2048];
        if( strlen(name)+strlen(msg)+2 <1024)
                sprintf(buf,"%s::%s", name, msg);
        else    sprintf(buf,"%s::...",name);
        return GDKstrdup(buf);
}
void showException(MalBlkPtr mb, int pc, str name, str msg){
	str n;
	n= raiseException(mb,pc,name,msg);
	GDKerror(n);
	GDKfree(n);
}
@- utilities
During the lifetime of a MAL function, it may be subject to
manipulation by squeezer modules. They inspect the code and
are allowed to enhance it to improve interpretation. Since the
optimization schemes deployed during a session, or even between
successive calls of a function, we should forbid changes to
the symbol table and original instruction sequence.
The routines below ensure safeguarding  and restoring the state.
@c
void	safeFunction(Symbol proc){
#ifdef DEBUG_MAL_FCN
#endif
}
void	restoreFunction(Symbol proc){
#ifdef DEBUG_MAL_FCN
#endif
}
@-
For commands we do not have to clone the routine. We merely have to
assure that the type-constraints are obeyed. The resulting type
is returned.
@c
malType  getCommandType(Symbol proc, MalBlkPtr mb, InstrPtr p){
	return malAnyType;
}
void printFunction(FILE *fd, MalBlkPtr mb){
	int i;
	for(i=0;i<mb->stop;i++)
	printInstruction(fd,mb, getInstrPtr(mb,i));
}
