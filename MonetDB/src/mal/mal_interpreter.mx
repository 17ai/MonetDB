@t MAL Interpretation
@a M. Kersten
@v 0.0
@+ MAL interpretation
The MAL interpreter always works in the context of a single user session,
which provides for storage access to global variables and modules.

Runtime storage for variables are allocated on the stack of the
interpreter thread. ( physical stack is often limited in size)
This calls for safeguarding their value and garbage collection before returning.
A malicious procedure or implementation will lead to memory leakage.

A system command (linked C-routine) may be interested in extending the
stack. This is precluded, because it could interfere with the recursive
calling sequence of procedures. To accommodate the (rare) case, the routine
should issue an exception to be handled by the interpreter before retrying.
All other errors are turned into an exception, followed by continuing
at the exception handling block of the MAL procedure.

@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_INTERPRET_H
#define _MAL_INTERPRET_H

#include "mal_stack.h"
#include "mal_function.h"
#include "mal_debugger.h"
#include "mal_client.h"

/*#define DEBUG_MAL_INTERPRETER */
mal_export str runMAL(Client c,MalBlkPtr mbcaller, MalStkPtr env, MalStkPtr glb);
mal_export str setDynamicType(MalBlkPtr mb, MalStkPtr stk, VarPtr v, int tpe);
mal_export void garbageElement(ValPtr v);
mal_export void garbageCollector(MalBlkPtr mb, MalStkPtr stk);
#endif /*  _MAL_INTERPRET_H*/
@c
#include "mal_interpreter.h"

str runMAL(Client cntxt, MalBlkPtr mbcaller, MalStkPtr env, MalStkPtr glb){
	MalBlkPtr mb=mbcaller;
	MalStkPtr stk= NULL;
	int space = 0,i;
	ValPtr retval, lhs,rhs,v;
	InstrPtr pci=0, stop=0;
	str ret=0;
	char 	cmd='n';	/* debugger command */
	ptr argv[MAXARG];
	static MalStkPtr oldstk;	/* experiment */
	static int oldspace;
	long timer;
	@:performanceVariables@

	if( mbcaller->errors){
		char buf[1024];
		sprintf(buf,"'%s.%s' contains errors\n",
			getModName(mb),getFcnName(mb));
		return raiseException2("SyntaxError",buf);
	}
	if( env){
		/* locate instructions for called function */
		pci= getInstrPtr(mbcaller,env->pc);
		mb= pci->blk;
	}
@-
Prepare a new interpreter call. This involves two steps, (1) allocate
the minimum amount of stack space needed, some slack resources
are included to permit code squeezers to add a few variables at run time,
(2) copying the arguments into the new stack frame.
Notice that arguments are always the first entries on the stack.
They are followed by predefined constants.

The env stackframe is only set when a MAL function is called recursively.
The glb stackframe contains a saved stackframe with global variables. We
assume here that it aligns with the variable table of the routine.
@c
	/* allocate space for value stack */
	if( glb== 0){
		space= mb->vtop+8;
		newStack(stk,space);
		stk->stktop= mb->vtop; 
		stk->blk= mb;
		@:safeguardStack@
	} else {
		stk = glb;
		/* stk->stktop= mb->vtop;*/
		if( mb != stk->blk) GDKerror("runMAL:misalignment of symbols\n");
	}

	if( env){
		int k;
@-
Beware, the prelude of the stack frame contains type constants
and a variable to keep the return value.
@c
	 
		/* printf("recursive MAL function call %s[%d]\n",
			pci->fcnname,env->pc); */
		for(k=1; k<pci->argc; k++){
			lhs = &stk->stk[k+ SYMBOLFRAME];
			if( isVarConstant(mbcaller,pci->argv[k]))
				rhs = &getVarConstant(mbcaller,pci->argv[k]);
			else	rhs = &env->stk[pci->argv[k]];
			VALcopy(lhs,rhs);
		}
		stk->up = env;
		env->down = stk;
		cmd = env->cmd;
	} 
@-
An optimization is to copy all constant variables used in functions immediately
onto the value stack. Then we do not have to check for the location
later on any more. The effect is optimal, if at least ca. 20 constants
are referenced in a function (a gain on tst400a of 20% has been observed).
Otherwise, it is cheaper to lookup them up. 
@c
	for(i=0; i< mb->vtop; i++)
	if( isVarConstant(mb,i) && isVarUsed(mb,i) ){
		lhs = &stk->stk[i];
		rhs = &getVarConstant(mb,i);
		VALcopy(lhs,rhs);
	}

	/* run the program */
MALrestart:
	stk->pc =0;
	stk->exception = -1;
	stop = mb->stop;
	while(stk->pc < stop ){
		pci = getInstrPtr(mb,stk->pc);
		@:exceptionTest@
		if( cntxt->itrace  ) {
			cmd = mdbStep(cntxt,mb,stk,pci,cmd);
			if( cmd == 'q') goto MALevalExit;
			if( cmd == 'r') goto MALrestart;
		}

		@:beginProfile@
		@:MALinterpret@
		@:endProfile@
	}
MALevalExit:
	/* garbage collect and return */
	if( glb == 0) garbageCollector(mb,stk);
	return ret;
}
@+ Safeguarding
The physical stack for each thread is an operating system parameter.
We do not want recursive programs crashing the server, so once in
a while we check whether we are running dangerously low on available
stack space.
@= safeguardStack
/* Expensive? yes 1.5 sec for 1M calls another solution is needed.
    if (THRhighwater()) {
        GDKerror("interpret: running out of physical stack space!\n");
        goto MALevalExit;
    }
*/

@+ The interpreter loop
The interpreter is geared towards execution a MAL procedure together
with all its decendant invocations. As such, it provides the 
MAL abtract machine processor.

The value-stack frame of the surrounding scope is needed to resolve
binding values.  Getting (putting) a value from (into) a surrounding
scope should be guarded with the exclusive access lock.
This situation is encapsulated by a bind() function call, whose parameters
contain the access mode required.

The formal procedure arguments are assumed to always occupy the first
elements in the value stack.
@+ The major switch

@= MALinterpret
	ret = 0;
	switch( pci->token){
	case ASSIGNsymbol:
		@:assignStmt@ stk->pc++; break;
	case LEAVEsymbol:
		@:leaveControl@ break;
	case REDOsymbol:
		@:redoControl@ break;
	case BARRIERsymbol:
		@:barrierControl@ break;
	case RLRcall:
	case PATcall:
		@:patterncall@ 
		stk->pc++; break;
	case CMDcall:
		@:commandcall@ 
		stk->pc++; break;
	case FCNcall:
		stk->cmd= cmd;
		@:functioncall@ stk->pc++; 
		cmd = stk->cmd;
		break;
	case RULEsymbol:
	case COMMANDsymbol:
	case FUNCTIONsymbol:
	case RAISEsymbol:
	case ENDsymbol:
		stk->pc++; 
		break;
	case CATCHsymbol:
		stk->exception = pci->argv[0]; /* skip it */
		stk->pc++; break;
	case RETURNsymbol:
		if( env != NULL){
			rhs = &stk->stk[pci->argv[0]];
			@:endProfile@
			pci = getInstrPtr(mbcaller,env->pc);
			lhs = &env->stk[pci->argv[0]];
			VALcopy(lhs,rhs);
			if(glb == 0) garbageCollector(mb,stk);
			if(env) env->cmd = cmd; /* save debugger command */
			return 0;
		}
	case ENDDEFsymbol: 
		goto MALevalExit;
	default:
		GDKerror("ERROR:MALeval:unkown operation type\n");
		goto MALevalExit;
	}

@+ Assignment command
The assignment statement copies values around on the stack frame.
Pushing constants/initial values onto the stack is a separate operation.
It takes the constant value discovered at compile time and stored in the
symbol table and moves it to the stackframe location.
@= assignStmt
{	
	lhs = &stk->stk[pci->argv[0]];
	/* if( isVarConstant(mb,pci->argv[1]))
		rhs = &getVarConstant(mb,pci->argv[1]);
	else */	rhs = &stk->stk[pci->argv[1]];
	VALcopy(lhs,rhs);
	ret = 0;
}
if( pci->barrier == BARRIERsymbol){
	@:barrierControl@
} 

@+ MAL API
The linkage between MAL interpreter and compiled C-routines
is kept as simple as possible.
Basically we distinguish four kinds of calling conventions:
CMDcall, FCNcall, THRDcall, and  RLRcall.
The FCNcall indicates calling a MAL procedure, which leads
to a recursive call to the interpreter. 

CMDcall initiates calling a linked function, passing pointers 
to the parameters and result variable, i.e.  f(ptr a0,..., ptr aN)
The function returns a 1 (GDK_SUCCEED upon success and <=0 to indicate failure.
Failure leads to raiseing an exception in the interpreter loop,
by either looking up the relevant exception message in the module
administration or construction of a standard string.
Upon successfull return, we update the ValRecord with length indications.

The THRDcall initiates a separate thread of control, which 
receives requests for execution through a event-pool.
[details later]

The RLRcall initiates a call which contains the MAL context.
i.e. f(MalBlkPtr mb, MalStkPtr stk, int argc, int argv[])
The blk provides access to the code definitions. It is primarilly
used by routines intended to manipulate the code base itself, such
as the squeezers. The Mal stack frame pointer provides access
to the values maintained. The arguments passed are offsets
into the stack frame rather than pointers to the actual value.

The argument list and their location on the runtime stack frame
are determined at compile time.

@= commandcall
	@:evalParameters@
	if( pci->fcn== NULL)
		ret= raiseException(mb,stk->pc,"MALexception",
			"address of function missing\n");
	else
	switch(pci->argc){
	case 0 : ret = (str) (*pci->fcn)(); break;
	case 1 : ret = (str) (*pci->fcn)(argv[0]); break;
	case 2 : ret = (str) (*pci->fcn)(argv[0],argv[1]); break;
	case 3 : ret = (str) (*pci->fcn)(argv[0],argv[1],argv[2]); break;
	case 4 : ret = (str) (*pci->fcn)(argv[0],argv[1],argv[2],argv[3]); break;
	case 5 : ret = (str) (*pci->fcn)(argv[0],argv[1],argv[2],argv[3],
				argv[4]); break;
	case 6 : ret = (str) (*pci->fcn)(argv[0],argv[1],argv[2],argv[3],
				argv[4], argv[5]); break;
	case 7 : ret = (str) (*pci->fcn)(argv[0],argv[1],argv[2],argv[3],
				argv[4], argv[5],argv[6]); break;
	default:
		ret= raiseException(mb,stk->pc,"MALexception",
				"too many arguments\n");
		goto exceptionHdlr;
	}
	@:resultParameter@

@= patterncall
	retval=  &stk->stk[pci->argv[0]];
	retval->vtype = getGDKtype(mb->var[pci->argv[0]].type);
	ret = (str) (*pci->fcn)(mb,stk,pci);

@-
MAL function calls are relatively expensive, because they have to assemble
a new stack frame and do housekeeping, such as garbagecollection of all
non-returned values.

@= functioncall
	ret= runMAL(cntxt,mb,stk,0);
@-
All dynamically linked routines are called with references to their
parameter values. They are assembled below by inspecting the argument list.
For rules and procedures we pass the original
MIL context and it is up to c-body implementation to access the 
parameter values and leave the result in a proper place.

BAT parameters require some care. Ideally, a BAT should not be kept
around long. This would mean that each time we access a BAT it has to be
pinned in memory and upon leaving the function, it is unpinned.
This degrades performance significantly. 
After the parameters are fixed, we can safely free the destination
variable and re-initialize it to nil;

The policy implemented here is to make pin/unpin decisions part of
the bind(namespace,batname,mode) operation.[todo]

@= evalParameters
{	int k;
	retval=  &stk->stk[pci->argv[0]];
	retval->vtype = getGDKtype(mb->var[pci->argv[0]].type);
	for(k=0;k<pci->argc; k++){
		argv[k] =(ptr) getArgReference(stk,pci,k);
	} 
	garbageElement(retval);
}
@-
The type dispatching table in getArgValue can be removed if we 
determine at compile time the address offset within a ValRecord. 
We leave this optimization for the future, it leads to about 10%
improvement (100ms for 1M calls).
@-
Upon return of the function we may be interested in the result
and we have to do some housekeeping, such as string length adjustment.
@= resultParameter
	@:exceptionHndlr@
	switch(ATOMstorage(retval->vtype)){
	case TYPE_str: 
		if(retval->val.pval == NULL){
			char buf[1024];
			sprintf(buf,"%s.%s returns NULL string.\n",
				pci->modname,pci->fcnname);
			ret= raiseException(mb,stk->pc,"MALexception",buf);
			goto MALevalExit;
		} else {
			retval->len= ATOMlen(TYPE_str,retval->val.pval);
		}
	}
	if( pci->barrier==BARRIERsymbol){
		@:barrierControl@
	}

@+ Flow of control statements
Each assignment (function call) may be part of the initialization
of a barrier- block. In that case we have to test the
outcome of the operation and possibly skip the block altogether.
The latter is implemented as a linear scan for the corresponding
labeled statemtent. This might be optimized later.
The upper layers have assured that the result variable is of type boolean.

@= barrierControl
{ 
	v= &stk->stk[pci->argv[0]];
	/* skip to end of barrier */
	if( v->val.ival == FALSE ) @:leaveControl@
	stk->pc++;
	break;
}
@-
You can leave a barrier block by searching for the corresponding 'lab'
by faking an exception.

@= leaveControl
	stk->exception= pci->argv[0];
@-
Each time we enter a barrier block, we could keep its position in the
interpreter stack frame. It forms the starting point to issue a redo.
Unfortunately, this does not work in the presence of squeezers, which
may change the order/block structure. Therefore, we simple have to search
the beginning.

@= redoControl
	for( stk->pc--; stk->pc>=0; stk->pc--){
	InstrPtr p= getInstrPtr(mb,stk->pc);
	if( p->barrier == BARRIERsymbol && p->argv[0]== pci->argv[0]){
		break;
	} }
	@:endProfile@
	/* semantic validity of redo stmt has been checked already */
	/* continue re-execution of the barrier statement */
	continue;

@+ Exception handling
Calling a built-in or user-defined routine may lead to an error, 
which in Monet 4.x leads to a message on the user's console,
cached status message to be dealt with in MAL,
or as an error status in Mapi.
[there are about 55 GDKerror calls in gdk, 91 in monet, and 167 in 
the modules/plain/*.  The number of fatal errors is 26,7, 2, respectively.]

To improve error handling in MAL, we introduce an exception handling
scheme based on CATCH-END blocks. The CATCH statement identifies a
(string-valued) variable, which carries the exception message from
the originally failed routine or RAISE exception assignment.
During normal processing CATCH-END blocks are simply skipped.
Upon receiving an exception status from a function call, we set the 
exception variable and skip to the first associated CATCH-END block associated.
MAL interpretation then continues until it reaches the end of the block.
If no exception variable was defined, we should abandon the function
alltogether searching for a catch block at a higher layer.

For the time being we have ignored cascaded/stacked exceptions.
The policy is to pass the first recognized exception to a context
in which it can be handled.

@= exceptionTest
if( pci->typechk== TYPE_UNKNOWN){
	ret= raiseException(mb,stk->pc,"MALexception",
			    "Instruction type not fixed\n");
	goto exceptionHdlr;
}
if( stk->exception >=0){
	if( pci->barrier== CATCHsymbol && pci->argv[0]==stk->exception)
		stk->exception = -1; 
	if( pci->token  == ENDsymbol && pci->argv[0]==stk->exception)
		stk->exception = -1; 
	stk->pc++;
	continue;
}
@-
Exceptions raised within a linked-in function requires some care.
First, the called procedure does not know anything about the MAL
interpreter context. Thus, we need to return all relevant information
upon leaving the linked library routine.

Second, exceptional cases can be handled deeply in the recursion, where they
may also be handled, i.e. by issueing an GDKerror message.The upper layers
merely receive a negative integer value to indicate occurrence of an
error somewhere in the calling sequence.

We have to look into GDKerrbuf to see if they can be recognized.

The policy for the time being realized in the new module structure is
to require all functions to return a string-pointer. Upon successfull
call, this string function is NULL. Otherwise it contains an
encoding of the exceptional state encountered. This message
starts with the exception identifer, followed by contextual details.

@= exceptionHndlr
exceptionHdlr:
if( ret != (str) GDK_SUCCEED && ret != NULL){
	str msg, nxt;
	int symid;
	msg= strchr(ret,':');
	if( msg) {
		*msg= 0;
		symid = findVariable(mb,ret);
	} else {
		if( ret == (str) GDK_FAIL ){
			msg= GDKstrdup(GDKerrbuf);
			symid = findVariable(mb,"GDKerror");
		} else {
			GDKerror("syntax error in exception message");
			stk->pc++;
			continue;
		}
	}
	if( symid == -1){
		*msg=':';
/*		terminate this block and pass error 
		if( env == NULL) 
		fprintf(cntxt->fdout,"CATCH ERROR %s\n",ret);
*/
		goto MALevalExit;
	}
	msg++;
	/* assure correct variable type */
	if( (nxt= (str) setDynamicType(mb,stk,mb->var+symid,TYPE_str)) == 0 ){
		v=  &stk->stk[symid];
		v->vtype = TYPE_str;
		v->val.pval= GDKstrdup(msg);
		v->len= strlen(msg);
		stk->exception = symid;
		GDKfree(ret);
		ret = 0;
	} else GDKfree(nxt);
}
@-
@+ Dynamic type
During instruction interpretation we may have to be
assured that the type associated with a destination variable
is in line with the result of an operation or exceoption.
@c
str setDynamicType(MalBlkPtr mb, MalStkPtr stk, VarPtr v, int tpe){
	char buf[1024];
	if( v->type ==tpe) return 0;
	sprintf(buf,"variable '%s' has already type %s (!=%s)\n",
		v->name, malTypeName(v->type), malTypeName(tpe));
	return raiseException(mb,stk->pc, "setDynamicType",buf);
}

@+ Garbage collection
Garbage collection is relatively straightforward, because most values are
retained on the stackframe of an interpreter call. However, two storage
types and possibly user-defined type garbage collector definitions
require attention.

All string values are private to the VALrecord, which means they
have to freed explicitly before a MAL function returns. 
The first step is to always clear the destination variable
before a function call is made.

@c
void garbageElement(ValPtr v)
{	
	if( ATOMstorage(v->vtype) == TYPE_str){
		if( v->val.pval && v->val.pval != str_nil) {
		/* printf("clearing nil? %d ",v->val.pval==str_nil);
		   printf("%d ",v->val.pval);
		   printf("%s\n",v->val.pval);
		*/
			GDKfree(v->val.pval);
		}
		v->val.pval= NULL;
	}
}
@-
The second major area to be careful, is management of the BAT reference counts.

Before we return from the interpreter, we should free all
dynamically allocated objects and adjust the BAT reference counts.
Early experience shows that for small stack frames the overhead
is about 200 ms for a 1M function call loop (tst400e). This means that
for the time being we do not introduce more complex garbage
administration code.

Also note that for top-level stack frames (no environment available),
we should retain the value stack because it acts as a global variables. 
This situation is indicated by the 'global' in the stack frame. 
Upon termination of the session, the stack should be cleared.
@c
void garbageCollector(MalBlkPtr mb, MalStkPtr stk)
{ 	int k;
	ValPtr v;

	for(k=0;k<mb->vtop;k++) {
		garbageElement(&stk->stk[k]);
	}
}

@+ Performance section
This will be dealt with at a later stage.
@= performanceVariables
#ifdef MALprofiler
	long oldclk=0,newclk=0;
#endif
@= beginProfile
#ifdef MALprofiler
	oldclk= GDKusec();
#endif

@= endProfile
#ifdef MALprofiler
	newclk= GDKusec();
	pci->counter++;
	pci->ticks += newclk-oldclk;
	oldclk=newclk;
#endif
