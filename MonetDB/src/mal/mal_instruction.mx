@t MAL instruction blocks
@a M. Kersten
@v 0.0
@+ MAL instruction layout
MAL instruction sequences have a simple format.
The operation is either an assignment "variable := module.fcn(a1..a32)"
where the actual function arguments are references to variables on the
runtime variable stack, or reference to a MAL control statement, 
i.e. RAISE, CATCH, RETURN, BARRIER, LEAVE,REDO

A sequence of instructions is represented by a variable, instruction,
and program stmt block.
The variable block is the symbol table associated with the 
instruction sequence.
Each tuple contain a reference to the argument name ,
a reference to a lexical value when it denotes a constant,
its associated Mal type identifier.
Upon procedure return, the variable block is inspected to find
objects eligable for garbage collection (e.g. strings).

The instruction block is a large code byte string overlaid with the
instruction pattern InstrPattern. This method leads to a large
allocated block, which can be easily freed, and
pattern makes it possible to accommodate a variable argument list.
Each argument list starts with a reference to the destination variable. 

An array of byte-offsets into the code byt string provides for fast
access to any statement.

Variable- and stmt- block together describe the
static part of a MAL procedure. It carries carry enough information to produce
a listing and to aid symbolic debugging. Ideally, the listing
of a MAL program is identical to the non-commented source.
This costs some space, but will improve readability and permits
instruction sequences generated internally also to be kept
around as ascii text for later inclusion.

WARNING. The way we lay out the instructions means that 
you can prepare only one instruction at a time, because you don't
know how many arguments may be needed.

A variable binding may become CONSTANT for the duration of its
life time.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_INSTR_H
#define _MAL_INSTR_H

#include "mal_type.h"
#include "mal.h"

#define DEBUG_MAL_INSTR
#define MAXARG 32
#define MAXVARS 128
#define MALBLKSIZE 4096
#define MAXSTMTS 512

typedef struct SYMDEF {
        struct SYMDEF   *peer;  /* where to look next */
        str             name;
        str             help;   /* supportive commentary */
	str		binding;/* related C-function */
        int             kind;
        struct MALBLK   *def;    /* the details of the MAL fcn */
} *Symbol, SymDefinition;

typedef struct{
	str     name;	/* argname or lexical value repr */
	malType	type;	/* internal type signature */
        bit	isaconstant;	/* value cannot change */
	int	isused;	/* for stack copying scope */
	short	index;	/* offset in stack */
	str	literal;/* initial value -> ValRecord */
	ValRecord value;
} *VarPtr, VarRecord;

/* type check status is kept around to improve type checking efficiency */
#define TYPE_ERROR		-1
#define TYPE_UNKNOWN            0
#define TYPE_DYNAMIC            1
#define TYPE_POLYMORPHIC        2
#define TYPE_FIXED              4

typedef struct {
	short	token;		/* instruction type */
	short	barrier;	/* Begin-end of block */
	int	typechk;	/* type check status */
@-
For performance analysis we keep track of the number of calls
and the total time spent while executing the instruction.
(See mal_profiler.mx)
@h
#ifdef MALprofiler
	long	counter;
	long	ticks;		/* micro seconds spent */
#endif
	GDKfcn	fcn;		/* resolved function address */
	struct MALBLK *blk;	/* resolved MAL function address */
@-
The MAL instruction representation. The strings should be garbage collected
upon destruction of the definition.
@h
	struct SYMDEF  *sym;	/* pointer to enclosing proc symbol */
	str	modname;	/* module context */
	str	fcnname;	/* function name */
	int	argc;
	int	argv[1];	/* at least one entry */
} *InstrPtr, InstrRecord;

typedef struct MALBLK{
	struct SYMDEF  *sym;	/* pointer to enclosing proc symbol */
	int	  vtop;		/* next free slot */
	int	  vsize;	/* byte size of arena */
	VarRecord  **var;	/* Variable table */
	int	  ctop;		/* next free slot */
	int	  csize;	/* byte size of arena */
	char	  *code;	/* Instruction encoding */
	int	  stop;		/* next free slot */
	int	  ssize;	/* byte size of arena */
	int	  *stmt;	/* Instruction location */
	int	  errors;	/* left over errors */
} *MalBlkPtr, MalBlkRecord;
@-
Allocation of space assumes a rather exotic number of arguments.
@h
#define getInstrPtr(M,I)	((InstrPtr)((M)->code + (M)->stmt[I]))
#define getSignature(S)		getInstrPtr((S)->def,0)
#define getFcnName(M)	getInstrPtr(M,0)->fcnname
#define getFcnArgCount(M)	getInstrPtr(M,0)->argc
#define getModName(M)	getInstrPtr(M,0)->modname 
#define getPrgSize(M)	(M)->stop

#define getVar(M,I)	(M)->var[I]
#define getVarName(M,I)  (M)->var[I]->name
#define getVarType(M,I)  (M)->var[I]->type
#define getVarIndex(M,I)  (M)->var[I]->index
#define getVarLiteral(M,I)  (M)->var[I]->literal
#define isVarConstant(M,I) ((M)->var[I]->isaconstant)
#define isVarUsed(M,I) ((M)->var[I]->isused)
#define getVarConstant(M,I)  ((M)->var[I]->value)
#define copyVar(M,I,J)	GDKfree((M)->var[I]);(M)->var[I] = (M)->var[J];\
		(M)->var[J]= NULL;

#define setDestType(M,P)  getVarType((M),(P)->argv[0])
#define getDestType(M,P)  destinationType((M),(P))
#define getArgName(M,P,I)  getVarName((M),(P)->argv[I])
#define getArgType(M,P,I)  getVarType((M),(P)->argv[I])
#define getArgIndex(M,P,I)  getVarIndex((M),(P)->argv[I])
#define getArgDefault(M,P,I)  getVarLiteral((M),(P)->argv[I])

mal_export InstrPtr	newInstruction(MalBlkPtr mb, int kind);
mal_export void		freeInstruction(InstrPtr p);
mal_export Symbol	newSymbol(str nme, int kind);
mal_export void 	freeSymbol(Symbol s);
mal_export void 	freeSymbolList(Symbol s);
mal_export MalBlkPtr	newMalBlk();
mal_export void		freeMalBlk(MalBlkPtr mb);
mal_export MalBlkPtr	copyMalBlk(MalBlkPtr);

mal_export int		findVariable(MalBlkPtr mb, str name);
mal_export int		findVariableLenght(MalBlkPtr mb, str name,int len);
mal_export malType	getType(MalBlkPtr mb, str nme);
mal_export int		newVariable(MalBlkPtr mb, str name,malType type);
mal_export void		copyVariable(MalBlkPtr dst,MalBlkPtr src, VarPtr v);
mal_export int		newTmpVariable(MalBlkPtr mb, malType type);
mal_export void		freeVariable(MalBlkPtr mb, int varid);
mal_export int		newConstant(MalBlkPtr mb, malType type, str val);
mal_export int		isVARG(MalBlkPtr mb, InstrPtr p, int i);

mal_export void		pushInstruction(MalBlkPtr mb, InstrPtr p);
mal_export void		pushEndInstruction(MalBlkPtr mb);
mal_export void		pushArgument(MalBlkPtr mb, InstrPtr p, int varid);
mal_export void		setReturnArgument(InstrPtr p, int varid);
mal_export malType	destinationType(MalBlkPtr mb, InstrPtr p);
mal_export str		getDestName(MalBlkPtr mb, InstrPtr p);
mal_export void 	printInstruction(FILE *fd, MalBlkPtr mb,InstrPtr p);
mal_export void		promptInstruction(FILE *fd, MalBlkPtr mb,InstrPtr p);
mal_export str		instruction2str(MalBlkPtr mb,InstrPtr p);

#endif /*  _MAL_INSTR_H*/
@c
#include "mal_instruction.h"

Symbol newSymbol(str nme, int kind){
	Symbol cur;
	if( nme == NULL){
		GDKfatal("@1:unexpected name (=null)\n");
	}
        cur = (Symbol) GDKmalloc(sizeof(SymDefinition));
	if( cur == NULL){
		GDKfatal("@1: cannot initialize scope\n");
	}
	bzero((str)cur,sizeof(SymDefinition));
	cur->name = nme;
	cur->kind = kind;
	cur->peer = NULL;
	cur->help = NULL;
	cur->def = newMalBlk();
	return cur;
}
void freeSymbol(Symbol s){
        if(s==NULL) return;
        if( s->name) GDKfree(s->name);
        if( s->help) GDKfree(s->help);
        if( s->def) freeMalBlk(s->def);
        GDKfree(s);
}
void freeSymbolList(Symbol s){
        if(s==NULL) return;
        if(s->peer != NULL) freeScope(s->peer);
        freeScope(s);
}
 
MalBlkPtr newMalBlk(){
	MalBlkPtr mb;
	VarPtr *v;
	char *c;
	int *n;

	v = (VarPtr *)GDKmalloc(sizeof(VarPtr) * MAXVARS);
	if( v== NULL )
		GDKfatal("newMalBlk:could not get variable storage\n");
	c = (char *)GDKmalloc(MALBLKSIZE);
	if( c== NULL )
		GDKfatal("newMalBlk:could not get code storage\n");
	n = (int *)GDKmalloc(sizeof(int) * MAXSTMTS);
	if( n== NULL )
		GDKfatal("newMalBlk:could not get instruction storage\n");
	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if( mb== NULL )
		GDKfatal("newMalBlk:could not get storage\n");

	mb->var = v; mb->vtop = 0; mb->vsize = MAXVARS;
	mb->code = c; mb->ctop = 0; mb->csize= MALBLKSIZE;
	mb->stmt = n; mb->stop = 0; mb->ssize = MAXSTMTS;
	mb->errors = 0;
	return mb;
}

void freeMalBlk(MalBlkPtr mb){
	int i;
	for(i=0;i<mb->stop; i++)
		freeInstruction(getInstrPtr(mb, i));
	for(i=0;i<mb->vtop; i++)
		freeVariable(mb, i);
	GDKfree(mb->stmt); mb->stop = mb->ssize = 0; mb->stmt= 0;
	GDKfree(mb->code); mb->ctop = mb->csize = 0; mb->code= 0;
	GDKfree(mb->var); mb->vtop = mb->vsize = 0; mb->var= 0;
	mb->errors=0;
}
@-
The routine below should assure that all referenced structures
are private. The copying is memory conservative.
@c
MalBlkPtr copyMalBlk(MalBlkPtr old){
	MalBlkPtr mb;
	int i;

	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if( mb== NULL )
		GDKfatal("newMalBlk:could not get storage\n");
	mb->sym= old->sym;
	mb->var = (VarPtr *)GDKmalloc(sizeof(VarPtr) * old->vsize);
	mb->vsize = old->vsize;
	memcpy((char*) mb->var, old->var, sizeof(VarPtr) * old->vsize);
	if( mb->var== NULL )
		GDKfatal("newMalBlk:could not get variable storage\n");
	mb->vtop = 0;
	for(i=0;i<old->vtop;i++)
		copyVariable(mb,old,getVar(old,i));

	mb->code = (char *)GDKmalloc( mb->csize = old->csize);
	mb->ctop = old->ctop;
	memcpy((char*) mb->code, old->code, old->csize);
	if( mb->code== NULL )
		GDKfatal("newMalBlk:could not get code storage\n");

	mb->stmt = (int *)GDKmalloc(sizeof(int) * old->ssize);
	mb->stop = old->stop;
	mb->ssize = old->ssize;
	memcpy((char*) mb->stmt, old->stmt, old->ssize);
	if( mb->stmt== NULL )
		GDKfatal("newMalBlk:could not get instruction storage\n");

	for(i=0;i<mb->stop;i++){
		InstrPtr p= getInstrPtr(mb,i);
		if( p->modname) p->modname= GDKstrdup(p->modname);
		if( p->fcnname) p->fcnname= GDKstrdup(p->fcnname);
	}
	mb->errors= old->errors;
	return mb;
}
InstrPtr newInstruction(MalBlkPtr mb, int kind){
	InstrPtr p;
	int space;

	space = MAXARG * sizeof(int)+ sizeof(InstrRecord);
	if( mb->csize-mb->ctop <= space){
		char *newblk= GDKmalloc(mb->csize + MALBLKSIZE);
		/* printf("generate new code block\n");*/
		if( newblk== NULL){
			mb->errors++;
			GDKerror("newInstruction:no storage left\n");
			return getInstrPtr(mb,mb->stop-1);
		}
		memcpy(newblk,mb->code,mb->ctop);
		mb->code = newblk;
		mb->csize += MALBLKSIZE;
	}
	p= (InstrPtr) (mb->code+mb->ctop);
	mb->ctop += sizeof(InstrRecord);

	bzero((str)p, sizeof(InstrRecord));
	p->sym = 0;/* mb->sym;*/
	p->token = kind;
	p->barrier= 0;
	p->modname= NULL;
	p->fcnname= NULL;
	p->argc= 1;
	p->argv[0] = -1;
	p->typechk = TYPE_UNKNOWN;
	return p;
}

void freeInstruction(InstrPtr p){
	if(p->modname) GDKfree(p->modname);
	if(p->fcnname) GDKfree(p->fcnname);
	p->modname= NULL;
	p->fcnname= NULL;
}


@-
Beware that the first signature slot is reserved for the function
return type , which should be equal to the destination variable type.

VarRecords are allocated on the variable stack.
Their index is returned for future reference.
@-
Use the information that a variable is at least one character
wide and terminated by a null-byte.
This means that we can speed up search when the variables
differ in the first two characters
@c
int findVariable(MalBlkPtr mb, str name){
	register int i;
	for(i= mb->vtop-1; i>=0; i--)
	if(idcmp(name, getVarName(mb,i) )==0)
		return i;
	return -1;
}
@-
The second version of findVariable assumes you have not
yet allocated a private structure. This is particularly
usefull during parsing, because most variables are already
defined. This way we safe GDKmalloc/GDKfree.
@c
int findVariableLength(MalBlkPtr mb, str name, int len){
	register int i;
	register int j;
	for(i= mb->vtop-1; i>=0; i--) {
		str s = getVarName(mb,i);
		for(j=0;j<len;j++)
		if( name[j]!=s[j]) break;
		if(j==len && s[j]==0) return i;
	}
	return -1;
}
malType getType(MalBlkPtr mb, str nme){
	int i;
	i= findVariable(mb,nme);
	if( i< 0) return getTypeIndex(nme);
	if( i>=0) return getVarType(mb,i);
	return malVarType;
}
@-
All variables are implicitly declared upon their first
assignment. 
COMMANDS can FUNCTIONS should pass the types as strings and
convert them later on to the internal representation.

Lexical constants require some care. They typically appear as arguments
in operator/function calls. To simplify program analysis later on,
we stick to the situation that function/operator arguments are always
references to by variables. 

Beware, the symbol table structure assumes that it is relatively
cheap to perform a linear search to a variable or constant.

@c
int newVariable(MalBlkPtr mb, str name, malType type){
        int n,l;
        
	if( mb->vtop+1 >= mb->vsize){
		VarPtr *new;
		int s= mb->vtop + MAXVARS;
		new= (VarPtr *) GDKmalloc(s * sizeof(VarPtr));
		/*printf("generate new variable block\n");*/
		if( new== NULL ){
			mb->errors++;
			GDKerror("newMalBlk:no storage left\n");
			return mb->vtop;
		}
		memcpy(new,mb->var, sizeof(VarPtr) * mb->vtop);
		GDKfree(mb->var);
		mb->vsize= s;
		mb->var= new;
	}
	n= findVariable(mb,name);
	/* check for type names */
	if( n>=0){
		if( type != malAnyType){
		    if( getVarType(mb,n) != type  &&
		        getVarType(mb,n) != malAnyType)
			GDKerror("'%s' type mismatch %d vs %d\n",
				name, getVarType(mb,n),type);
		}
		/* GDKfree(name); not correct, check use!!!*/
		return n;
	}
	n = mb->vtop;
	getVar(mb,n) = (VarPtr) GDKmalloc(sizeof(VarRecord));
	bzero( (str) getVar(mb,n), sizeof(VarRecord));
	getVarName(mb,n) = name;
	getVarType(mb,n) = type;
	getVarIndex(mb,n) = n;
	getVarLiteral(mb,n)= NULL;
	isVarConstant(mb,n) = 0;
	isVarUsed(mb,n) = 0;
	mb->vtop++;
	return n;
} 
int newTmpVariable(MalBlkPtr mb, malType type){
	str name = newTmpName(mb->vtop);
	return newVariable(mb,name,type);
}
void	copyVariable(MalBlkPtr dst, MalBlkPtr src, VarPtr v){
	VarPtr w;

	w = (VarPtr) GDKmalloc(sizeof(VarRecord));
	bzero( (str) w , sizeof(VarRecord));
        w->name = GDKstrdup(v->name);
        w->type = v->type;
        w->index = v->index;
        w->literal= v->literal? GDKstrdup(v->literal):NULL;
        w->isaconstant = v->isaconstant;
        w->isused = v->isused;
	VALcopy(&w->value,&v->value);
	dst->var[dst->vtop++]= w;
}
void freeVariable(MalBlkPtr mb, int varid){
	VarPtr v;
	v= getVar(mb,varid);
	if( v->name ==0) return;
	if( v->name) GDKfree(v->name); v->name = 0;
	if( v->literal) GDKfree(v->literal); v->literal= 0;
	VALclear(&v->value);
	getVar(mb,varid) = NULL;
}
@- Constants
Constants are stored in the symbol table and referenced
by a variable identifier in the MAL sequence.
This means that per MAL instruction, we may end up with
MAXARG entries in the symbol table. This may lead to long
searches for variables.

A possible optimization strategy: look around for
a similar (constant) definition and reuse the name.

But then the question becomes how far to search?
Searching through all variables is only useful when the list remains short
or when the constant-variable-name is easily derivable from its literal
value and a hash-based index leads you quickly to it.

For the time being, we use a MAL system parameter, MAL_VAR_WINDOW,
to indicate the number of symbol table entries to consider.
Setting it to >= MAXARG will at least capture repeated use of a constant
within a single function call or repeated use within a small block
of code.

Beware that the string representation does not elicit the precise
basic type. In particular, integer constants appear in  several
kinds. The most precise one should be defined to make type
analysis work properly.

The final step is to prepare a GDK value record, from which
the internal representation can be obtained during
MAL interpretation.
@c
#define MAL_VAR_WINDOW	2*MAXARG

int newConstant(MalBlkPtr mb, malType type, str val){
	int i,k,idx;
	str s;
	ValPtr vr;

	k= mb->vtop - MAL_VAR_WINDOW;
	if( k<0) k=0;
	for(i= mb->vtop-1; i>=k;i--){
		VarPtr v= getVar(mb,i);
		if( v->literal &&
		    /* v->type == type &&*/
		    idcmp(v->literal,val)==0 
		  ) {
/* printf("reused a constant variable %s\n",v->name);*/
			GDKfree(val);
			return i;
		 }
	}
	idx= k= newVariable(mb, s=newTmpName(mb->vtop), type);
/* printf("new constant %d val %s\n",k,val);*/
	getVarLiteral(mb,k)= val;
	isVarConstant(mb,k) = 1;
	isVarUsed(mb,k) = 0;
	vr = &getVarConstant(mb,k);
@-
The current GDK layer does not perform a value range check.
Since constants are dealt with only once, it is performed here
as part of the parsing overhead.
Note that we support automatic coercion to a 
coerced type even in the case that a specific type specifier
has been given at the language level. A Warning is issued
to make the user aware of this situation.
@c
	switch( type){
	case TYPE_void: VALset(vr,TYPE_void,ATOMnilptr(TYPE_void));break;
	case TYPE_bit: { int x;
			 /* parser guarantees true/false conversion */
			 x= val[0]=='t' || val[0]=='T';
			 vr->vtype= TYPE_bit;
			 vr->val.bval= x;
			 break;
			}
	case TYPE_chr: 
			vr->vtype= TYPE_chr;
			vr->val.cval[0]= val[0];
			vr->val.cval[1]= 0;
			vr->val.cval[2]= 0;
			vr->val.cval[3]= 0;
			break;
	case TYPE_sht: {long l= strtol(val,NULL,0);
			if( l>255 || l<0) {
				if( l<2^31 && l> -2^31){
				GDKerror("WARNING:newConstant:sht coerced to int\n");
				vr->vtype= TYPE_int;
				vr->val.ival = l;
				} else{
				GDKerror("WARNING:newConstant:sht coerced to lng\n");
				vr->vtype= TYPE_lng;
				vr->val.lval = l;
				}
			} else {
				vr->vtype= TYPE_sht;
				vr->val.shval= l;
			}
			break; }
	case TYPE_int: {long l= strtol(val,NULL,0);
			if( l>= (2<<16) || l <= (-1<<16)){
			GDKerror("WARNING:newConstant:int coerced to lng\n");
				vr->vtype= TYPE_lng;
				vr->val.lval= l;
			} else {
				vr->vtype= TYPE_int;
				vr->val.ival= l;
			}
			break;}
	case TYPE_oid: {long l= strtol(val,NULL,0);
			/* parser guarantees syntax correctness */
			vr->vtype= TYPE_oid;
			vr->val.oval= l;
			break; }
	case TYPE_flt: {double d= strtod(val,NULL); 
			/* parser guarantees syntax correctness */
			vr->vtype= TYPE_flt;
			vr->val.fval= d;
			break; }
	case TYPE_dbl: {double d= strtod(val,NULL);
			/* parser guarantees syntax correctness */
			vr->vtype= TYPE_dbl;
			vr->val.dval= d;
			break;}
	case TYPE_lng: {long l= strtol(val,NULL,0);
			/* parser guarantees syntax correctness */
			vr->vtype= TYPE_lng;
			vr->val.lval= l;
			break; }
	case TYPE_str: 
			vr->vtype= TYPE_str;
			vr->val.sval= (str) val;
			vr->len= strlen((str) val);
			break;
	default:{ 
		s= malTypeName(type);
		GDKerror("newConstant:unknown constant type %s\n", s);
		GDKfree(s);
		}
	}
	return idx;
}
@+ Variable argument list
Functions and rules may contain a single variable argument list
They are recognized with the function below and can be used to control
the iterator over argument lists.
@c
int isVARG(MalBlkPtr mb, InstrPtr p, int i){
	if( idcmp(getArgName(mb,p,i),malVARG)==0) return 1;
	return 0;
}
@- Argument handling
The number of arguments for procedures is currently limited.
Furthermore, we should assure that no variable is referenced
before being assigned. Failure to obey should mark the instruction
as type-error.
@c
void pushArgument(MalBlkPtr mb, InstrPtr p, int varid){
	/* MalBlkPtr mb= p->sym->def;*/
        int n;
        
        n = p->argc;
        if( n == MAXARG-2){
		mb->errors++;
                GDKerror("too many arguments\n");
		p->argc--;
        } 
	p->argc++;
	p->argv[n] = varid;
	p->argv[p->argc] = -1;
	mb->ctop += sizeof(int);
	isVarUsed(mb,varid) = TRUE;
} 
void setReturnArgument(InstrPtr p, int varid){
	p->argv[0]= varid;
}
str getDestName(MalBlkPtr mb, InstrPtr p){
	if( p->argc>0) return getVarName(mb,p->argv[0]);
	return "";
}
malType destinationType(MalBlkPtr mb, InstrPtr p){
	if( p->argc>0) return getVarType(mb,p->argv[0]);
	return malAnyType;
}

@-
Instructions are simply appended to a MAL block, provided the
end-of-function instruction has not already been seen.
If this happens, a syntax error is reported, because all
instructions (except top-level instructions) should be
properly enclosed in block brackets.
Similarly, FUNCTION and COMMAND statements can only occur as
the first instruction in a block.
@c
void pushInstruction(MalBlkPtr mb, InstrPtr p){
	int i;
	InstrPtr prev;

	i= mb->stop;
	if( i+1 >= mb->ssize){
		int *newblk= (int *) GDKmalloc( (mb->ssize + MAXSTMTS)
						* sizeof(int));
		if( newblk== NULL){
			mb->errors++;
			GDKerror("pushInstruction:no storage left\n");
			return;
		}
		memcpy(newblk,mb->stmt,mb->stop*sizeof(int));
		mb->ssize += MAXARG;
		GDKfree(mb->stmt);
		mb->stmt = newblk;
	}
	mb->stmt[i]= ((char *) p)-((char*)mb->code);
	mb->stop++;
}
mal_export void pushEndInstruction(MalBlkPtr mb){
	InstrPtr p;
	p= newInstruction(mb,ENDDEFsymbol);
	p->argc =0;
	pushInstruction(mb,p);
}
@-
The internal representation should be such that it becomes
easy to re-produce the original textual input, possibly annotated with
system debugging information in additional commentary blocks.

The hiddenInstruction operator assumes a sufficiently large block
to leave information on the signature behind.
@c
#define advance(X)  while(*(X))(X)++;

str typechkName(int i){
	switch(i){
	default:
	case TYPE_ERROR:	return " error";
	case TYPE_UNKNOWN: 	return " unknown";
	case TYPE_DYNAMIC:	return " dynamic";
	case TYPE_POLYMORPHIC:	return " polymorphic";
	case TYPE_FIXED:	return "";
	}
}
str hiddenInstructionArgs(MalBlkPtr mb,InstrPtr p,str s){
	int i;
	
	sprintf(s,"\t#%d%s:",getPC(mb,p), typechkName(p->typechk));
	advance(s);
	for(i=0;i<p->argc;i++)
	if( p->argv[i] >=0){
		str tpe= malTypeName(getArgType(mb,p,i));
		advance(s);
		sprintf(s,"(%s:%s->%d)", 
			(getArgName(mb,p,i)?getArgName(mb,p,i):"nil"),
			tpe, getArgIndex(mb,p,i));
		GDKfree(tpe);
	}
	advance(s);
	return s;
}
@-
It receives the space to store the definition
The MAL profiler dumps some performance data at the
beginning of each line.

@= performanceData
#ifdef MALprofiler
	if( p->counter){
		double avg= p->ticks/(p->counter+0.0);
		sprintf(t,"[%7d,%5.2f]\t",p->counter,avg);
		advance(t);
	} 
#endif
@c
str fcnDefinition(MalBlkPtr mb,InstrPtr p, str s ){
	int i;
	str t,tpe;

	t=s;
	@:performanceData@
	if( p->token== FUNCTIONsymbol)
		sprintf(t,"function "); 
	else if( p->token == COMMANDsymbol)
	 	sprintf(t,"command ");
	else if( p->token == PATTERNsymbol)
		sprintf(t,"pattern ");
	else sprintf(t,"ruler ");

	advance(t);
	if( p->modname) sprintf(t,"%s.",p->modname);
	advance(t);
	sprintf(t,"%s(",p->fcnname);
	for(i=1;i<p->argc;i++){
		tpe= malTypeName(getArgType(mb,p,i));
		advance(t);
		sprintf(t,"%s:%s",getArgName(mb,p,i),tpe);
		advance(t);
		if( i<p->argc-1) sprintf(t,",");
		GDKfree(tpe);
	}
	advance(t);
	tpe= malTypeName(getArgType(mb,p,0));
	sprintf(t,"):%s",tpe);
	GDKfree(tpe);
	advance(t);
	if(mb->sym->binding)
		sprintf(t," = %s;",mb->sym->binding);
	else	sprintf(t,";");
#ifdef DEBUG_MAL_INSTR
	if( mal_xlisting){
		advance(t);
		hiddenInstructionArgs(mb,p,t);
	}
#endif
	advance(t);
	sprintf(t,"\n");
	return s;
}

str instruction2str(MalBlkPtr mb,InstrPtr p){
	int i,len=0;
	str s,t,nme;

	len = (p->modname?strlen(p->modname):0) +
	      (p->fcnname?strlen(p->fcnname):0) +
	      2*8196;
	s= GDKmalloc(len);
	s[0]=0;
	t=s;
	@:performanceData@
	if( getDestName(mb,p) ) nme= getDestName(mb,p); else nme="";
	advance(t);
	if( p->barrier){
		if( p->barrier== BARRIERsymbol)
			sprintf(t,"barrier"); 
	}
	advance(t);
	switch( p->token){
		case FCNcall:
		case RLRcall:
		case PATcall:
		case CMDcall:
		case ASSIGNsymbol:
			if( p->argc<=1 && p->fcnname==NULL)
				sprintf(t,"\t%s",nme); 
			else
			if( *nme!='$')
				sprintf(t,"\t%s := ",nme); 
			else
				sprintf(t,"\t"); 
			break;
		case REDOsymbol:
			sprintf(t,"\tredo %s ",nme); break;
		case LEAVEsymbol:
			sprintf(t,"\tleave %s",nme); break;
		case RETURNsymbol:
			sprintf(t,"\treturn %s",nme); break;
		case CATCHsymbol:
			sprintf(t,"catch\t%s",nme); break;
		case ENDDEFsymbol:
			switch(getInstrPtr(mb,0)->token){
			case FUNCTIONsymbol: nme = "function"; break;
			case COMMANDsymbol: nme = "command"; break;
			case PATTERNsymbol: nme = "pattern"; break;
			case HANDLERsymbol: nme = "handler"; break;
			case RULEsymbol: nme = "ruler"; break;
			default: nme = "unknown";
			}
			sprintf(t,"end %s",nme);
			break;
		case ENDsymbol:
			sprintf(t,"end\t%s",nme); break;
		case RULEsymbol:
		case COMMANDsymbol:
		case FUNCTIONsymbol:
		case PATTERNsymbol:
			return fcnDefinition(mb,p,s); 
		case BARRIERsymbol:
		case RAISEsymbol:
			sprintf(t,"\t%s",nme);
			break;
		default:
			sprintf(t," ?%d? ",p->token); 
	}
	advance(t);
	if( p->modname) sprintf(t,"%s.",p->modname);
	advance(t);
	if( p->fcnname) sprintf(t,"%s(",p->fcnname);
	for(i=1;i<p->argc;i++){
		advance(t);
		if( i+1<p->argc && isVARG(mb,p,i+1)) {sprintf(t,"...");break;}
		if( getArgDefault(mb,p,i) != NULL){
			if( getArgType(mb,p,i)== TYPE_str)
				sprintf(t,"\"%s\"", getArgDefault(mb,p,i));
			else
			if( getArgType(mb,p,i)== TYPE_chr)
				sprintf(t,"'%s'", getArgDefault(mb,p,i));
			else	sprintf(t,"%s", getArgDefault(mb,p,i));
		} else sprintf(t,"%s", getArgName(mb,p,i));
		advance(t);
		if( idcmp("bat",getArgName(mb,p,i))==0 ){
			str d1=malTypeName(getHeadType( getArgType(mb,p,i))),
			    d2 =malTypeName(getTailType(getArgType(mb,p,i)));
			sprintf(t,"[%s,%s]",d1,d2);
			GDKfree(d1); GDKfree(d2);
			advance(t);
		}
		if(i<p->argc-1) sprintf(t,",");
	}
	advance(t);
	if(p->fcnname) sprintf(t,")");
	advance(t);
	sprintf(t,";");
#ifdef DEBUG_MAL_INSTR
#ifndef MALprofiler
	if( mal_xlisting){
		advance(t);
		t= hiddenInstructionArgs(mb,p,t);
	}
#endif
#endif
	advance(t);
	sprintf(t,"\n");
	if(t-s >len)
		GDKfatal("instruction2str:");
	return s;
}
void promptInstruction(FILE *fd, MalBlkPtr mb, InstrPtr p){
	str ps;
	if( fd == 0) GDKfatal("printInstruction:no file\n");
	ps= instruction2str(mb,p);
	ps[strlen(ps)-1] = 0; /* remove '\n' */
	fprintf(fd,"%s",ps);
	GDKfree(ps);
}
void printInstruction(FILE *fd, MalBlkPtr mb, InstrPtr p){
	promptInstruction(fd,mb,p);
	fprintf(fd,"\n");
}

void printSignature(FILE *fd, Symbol s){
	InstrPtr p;
	str txt= GDKmalloc(8192);
	p= getSignature(s);
	(void) fcnDefinition(s->def, p,txt);
	fprintf(fd,"%s",txt);
	GDKfree(txt);
}
