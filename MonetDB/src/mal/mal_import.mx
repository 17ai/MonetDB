@t MAL import
@a M. Kersten
@v 0.0
@+ MAL import
The import statement simple switches the parser to a new input file, which
takes precedence. The context for which the file should be interpreted
is determined by the module name supplied.
Typically this involves a module, whose definitions are stored at 
a known location.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_IMPORT_H
#define _MAL_IMPORT_H

#include "mal_scope.h"

mal_export void malImport(str fname,int listing);
#endif /*  _MAL_IMPORT_H*/
@-
The import context is located. If it already exists, we should silently skip
parsing the file. This is handled at the parser level.
The files are extracted from a default location,
namely the DBHOME/modules directory.

If the string starts with '/' or '~' the context is not changed.

Every IMPORT statement denotes a possible dynamic load library.
Make sure it is loaded as well.
@c
#include "mal_client.h"
#include "mal_import.h"

void malImport(str fname,int listing){
	FILE *fd;
	long i,len;
	char *buf;
	Symbol	prg;
	char path[PATHLENGTH];
        InstrPtr curInstr;
        MalBlkPtr curBlk;

	Client c= getClient();
	str oldinput= c->input, oldnxt=c->nxt, oldlimit= c->limit;
	int oldlisting = c->listing;
	Scope oldscope = c->nspace;
	Symbol oldprg = c->curprg;
	int limit;

        SLASH_2_DIR_SEP(fname);
	if ((fd = fopen(fname, "r")) == 0) {
	    sprintf(path, "%s.mal",fname);
            if (fname[0] == DIR_SEP) {
                strcpy(path, fname);
                fd = fopen(path, "r");
            } else {
                sprintf(path, "%s/modules/%s.mal",GDKdirStr, fname);
		SLASH_2_DIR_SEP(path);
                fd = fopen(path, "r");
		if( fd==NULL){
			sprintf(path, "%s/src/modules/%s.mal",GDKdistrStr, fname);
			SLASH_2_DIR_SEP(path);
                	fd = fopen(path, "r");
		}
            }
        }
        if (fd == 0) {
                GDKerror("malImport: could not open file: %s\n", fname);
                return;
        }
        (void) fseek(fd,0L,SEEK_END);
        i = 0; len = ftell(fd)+2;
        (void) fseek(fd,0L,0);

	limit= (len/1024+1)*1024;
	c->nxt = c->input = (char *) GDKmalloc(limit);
	c->limit = c->input + limit;
	if( c->input == 0){
		GDKerror("unable to allocate buffer\n");
		return;
	}

        i=fread(c->input, 1, len, fd);
        if( i != len-2) GDKerror("not enough bytes read \n");
        fclose(fd);
        c->input[i] = 0;
@-
Load any associated module first, because this sets the context for
resolving addresses. 
@c
	loadModuleLibrary(fname);

	c->listing = listing;
	resetClientPrg(c);
	parseMal(c);
	closeClientPrg(c);
	prg = findSymbolInScope(c->nspace,"main");
	if( prg && listing) printFunction(c->fdout,prg->def);
	
	/* reset the input buffer */
	GDKfree(c->input);
	c->listing = oldlisting;
	c->input= oldinput;
	c->limit= oldlimit;
	c->nxt = oldnxt;
	c->nspace= oldscope;

	if( prg){
		str msg;
		msg= (str) runMAL(c,prg->def,0,0);
		if( msg && msg != (str) GDK_SUCCEED){
			GDKerror(msg);
			GDKfree(msg);
		}
	} 
}
