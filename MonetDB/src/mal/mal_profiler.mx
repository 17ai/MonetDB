
@t MAL dynamic profiler
@a M. Kersten
@v 0.0
@* Introduction
A key issue in the road towards a high performance Monet implementation
is to understand where resources are being spent. This information
can be obtained using different tools and at different levels of
abstraction.

A coarse grain insight for a particular application can be obtained
using the mprof module and inject the necessary performance
capturing statements in the instruction sequence of the application.

Fine-grain, platform specific information can be obtained using
existing profilers, like grprof, or even hardware counters.

The profiler described in this module is focussed on extracting
MAL related performance information. For the time being, this involves
keeping a count on the instructions being executed and the
average cpu time spent.

The profiler is activated by defining MALprofiler in mal.mx.
This leads to securing space for the counters and for code
in the interpreter to collect the information.

Upon exit of the session, the profiler information is saved
in a file MALprofilerReport for offline inspection.
This approach assumes implies that all concurrent users are
affected by the performance overhead.[estimate]
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.
html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _MAL_PROFILER_H
#include "mal_scope.h"

/*#define DEBUG_MAL_PROFILER */
mal_export void profileReport(Scope cntxt,int outer, FILE *out);

#endif
@+ Administration
Every MAL instruction record is extended with two fields: counter, timer
The counter is incremented each time the instruction is taken into
execution. Upon return, the timer is incremented with the microseconds
spent.
@c
#include "mal_profiler.h"

@+ Reporting
The performance information is collected on instruction basis.
For reporting it would be nice to aggregate the information
at command/function level. Furthermore, a gprof like analysis
is extremely helpful. It simple calls for collecting all timings
of the caller environments.

The report is dumped on a file at the end of a session.
It provides a complete list of all commands/functions/patterns
being called at least once. The information is not sorted.
@c
void  profileReport(Scope cntxt, int outer, FILE *out)
{
#ifdef MALprofiler
        int i,j;
        Scope s=cntxt;
	Symbol t;
	InstrPtr p;

        while(s!= NULL){
                if( s->subscope)
                for(j=0;j<MAXSCOPE;j++)
                if(s->subscope[j]){
                        for(t= s->subscope[j];t!=NULL;t=t->peer) {
				p= getInstrPtr(t->def,0);
				if( p->counter) printFunction(out, t->def);
                        }
                }
                s= s->peer;
        }
        if(outer && cntxt->outer) profileReport(cntxt->outer, outer,out);
#endif
}
