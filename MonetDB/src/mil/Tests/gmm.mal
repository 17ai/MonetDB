# Mil compiler Version 1.0)
# Copyright (c) 1993-2001, CWI. All rights reserved.

# Predefined code segment
##CHANGES TO ORIGINAL:
## seqbase -> setSequenceBase	(**)
## persists(FALSE) -> setTransient
## persists(TRUE) -> setPersistent
## (**) the return value is not necessarily a BAT id anymore.
##line 23 "../../../src/gmm/gmm.mx"
use "kernel/io";
use "kernel/alarm";
use "kernel/lock";
use "kernel/mmath";
use "kernel/xtables";
#  module(io,alarm,lock,mmath,xtables);
	Nthreads := 4;
#  CONST Nthreads  := 4;
	aa_a := newoid();
	ba_a := int(aa_a);
	sessionId := +("S",ba_a);
#  CONST sessionId := "S" + int(newoid());
#  VAR   randomseed;
	randomseed := 40;
#randomseed := 40;
	ca_a := mem_maxsize(1000000000LL);
#mem_maxsize(1000000000LL);
	da_a := vm_maxsize(2000000000LL);
#vm_maxsize( 2000000000LL);
function init_modgmm():void;
#  PROC init_modgmm():void := { 
	curthreads:= threadcnt(0);
#    VAR curthreads := threadcnt(0);
	ea_a := +(Nthreads,1);
barrier	fa_a:= <(curthreads,ea_a);
#    IF (curthreads < (Nthreads + 1)) 
	ga_a := -(Nthreads,curthreads);
	ha_a := +(ga_a,1);
	ia_a := threadcnt(ha_a);
#	threadcnt( (Nthreads - curthreads) + 1 );
end	fa_a;
barrier	ja_a:= isnil(randomseed);
	randomseed := time();
#    IF (isnil(randomseed)) randomseed := time();
end	ja_a;
	ka_a := srand(randomseed);
#    srand(randomseed);
end function;
#  }
	la_a := init_modgmm();
#  init_modgmm();
#
	GMMdebuglog:= fopen("/ufs/arjen/tmp/GMM.log","a");
#  VAR GMMdebuglog := fopen("/ufs/arjen/tmp/GMM.log", "a");
function debug(msg:str,msg:any[]):void;
#  PROC debug( str msg, ..any.. ):void := {
	ma_a := +(msg," @ %s\n");
	na_a := +("GMM: ",ma_a);
	oa_a := mil.getVarTempRange(2);
	pa_a := ctime();
	qa_a := trim(pa_a);
	ra_a := fprintf(GMMdebuglog,na_a,oa_a,qa_a);
#    fprintf( GMMdebuglog, "GMM: " + msg + " @ %s\n", $(2..), trim( ctime() ) );
	sa_a := fflush(GMMdebuglog);
#    fflush( GMMdebuglog );
end function;
#  }
	sessionId:= take("sessionId");
	ta_a := debug("Starting gmm.mil session %s",sessionId);
#  debug("Starting gmm.mil session %s", sessionId);
#
function _x(x:bat[any,any::1]):bat[void,any::1];
	ua_a := reverse(x);
	va_a := mark(ua_a,nil);
	wa_a := reverse(va_a);
	return wa_a;
end function;
#  PROC _x(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(nil).reverse;}
function nx(x:bat[any,any::1]):bat[void,any::1];
	xa_a := oid(0);
	ya_a := reverse(x);
	ab_a := mark(ya_a,xa_a);
	bb_a := reverse(ab_a);
	return bb_a;
end function;
#  PROC nx(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(oid(0)).reverse;}
function x_(x:bat[any::1,any]):bat[any::1,void];
	cb_a := mark(x,nil);
	return cb_a;
end function;
#  PROC x_(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(nil);}
function xn(x:bat[any::1,any]):bat[any::1,void];
	db_a := oid(0);
	eb_a := mark(x,db_a);
	return eb_a;
end function;
#  PROC xn(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(oid(0));}
function Nseq(N:int):bat[void,int];
#  PROC Nseq(int N):BAT[void,int] := {
	i:= 0;
	seq:= new(void,int);
#    VAR i := 0; VAR seq := new(void,int);
	fb_a := oid(0);
	gb_a := setSequenceBase(seq,fb_a);
#    seq.setSequenceBase(oid(0));
barrier	hb_a:= true;
	jb_a := <(i,N);
barrier	ib_a:= jb_a;
	kb_a := insert(seq,nil,i);
	lb_a := :+=(i,1);
redo	hb_a;
end	ib_a;
end	hb_a;
#    WHILE (i<N) { seq.insert(nil,i); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
function randseq(N:int):bat[void,int];
#  PROC randseq(int N):BAT[void,int] := {
	i:= 0;
	seq:= new(void,int);
#    VAR i := 0; VAR seq := new(void,int);
	mb_a := oid(0);
	nb_a := setSequenceBase(seq,mb_a);
#    seq.setSequenceBase(oid(0));
barrier	ob_a:= true;
	qb_a := <(i,N);
barrier	pb_a:= qb_a;
	rb_a := rand();
	sb_a := insert(seq,nil,rb_a);
	tb_a := :+=(i,1);
redo	ob_a;
end	pb_a;
end	ob_a;
#    WHILE (i<N) { seq.insert(nil,rand()); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
#
#  # casting bats of bats should have worked with [dbl] but doesn't -- BUG!
function conv2sht(b:bat[any::1,any]):bat[any::1,sht];
	ub_a := multiplex.sht(b);
	return ub_a;
end function;
#  PROC conv2sht(BAT[any::1,any] b):BAT[any::1,sht] := {RETURN [sht](b);}
function conv2flt(b:bat[any::1,any]):bat[any::1,flt];
	vb_a := multiplex.flt(b);
	return vb_a;
end function;
#  PROC conv2flt(BAT[any::1,any] b):BAT[any::1,flt] := {RETURN [flt](b);}
function conv2dbl(b:bat[any::1,any]):bat[any::1,dbl];
	wb_a := multiplex.dbl(b);
	return wb_a;
end function;
#  PROC conv2dbl(BAT[any::1,any] b):BAT[any::1,dbl] := {RETURN [dbl](b);}
#
function sqrt(x:flt):dbl;
	xb_a := dbl(x);
	yb_a := sqrt(xb_a);
	return yb_a;
end function;
#  PROC sqrt(flt x):dbl := {RETURN sqrt(dbl(x));}
function sqrt_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ac_a := multiplex.dbl(x);
	bc_a := multiplex.sqrt(ac_a);
	return bc_a;
end function;
#  PROC [sqrt](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [sqrt]([dbl](x));}
function log(x:flt):dbl;
	cc_a := dbl(x);
	dc_a := log(cc_a);
	return dc_a;
end function;
#  PROC log(flt x):dbl := {RETURN log(dbl(x));}
function log_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ec_a := multiplex.dbl(x);
	fc_a := multiplex.log(ec_a);
	return fc_a;
end function;
#  PROC [log](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [log]([dbl](x));}
#
#
##line 77 "../../../src/gmm/gmm.mx"
#  # circumvent parsing problems with [[op]](bat[bat],bat[bat])
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any]):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y):BAT[any::1,any] := {
	gc_a := mil.multiplex_deref(op,x,y);
	return gc_a;
#    RETURN [* op](x, y); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any], z:any):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y, any z):BAT[any::1,any] := 
#  {
	hc_a := mil.multiplex_deref(op,x,y,z);
	return hc_a;
#    RETURN [* op](x, y, z); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any::2]):bat[any::1,any::2];
#  PROC nestedop(str op, bat[any::1,any::2] x):BAT[any::1,any::2] := {
	ic_a := mil.multiplex_deref(op,x);
	return ic_a;
#    RETURN [* op](x); 
end function;
#  }
#
function square(x:bat[any::1,any::2]):bat[any::1,any::2];
	jc_a := multiplex.*(x,x);
	return jc_a;
end function;
#  PROC square(bat[any::1,any::2] x):BAT[any::1,any::2] := {RETURN [*](x, x );}
#
#  #  post@batloop{
#  #    VAR p := $t;
#  #    p.access(BAT_WRITE);
#  #    [:/=](p, s);
#  #    p.access(BAT_READ);
#  #  }
#
#
#
##line 392 "../../../src/gmm/gmm.mx"
	N := 8;
#  CONST N := 8;
	C := 8;
#  CONST C := 8;
#
	cseq:= Nseq(C);
#  VAR cseq := Nseq( C );
	nseq:= Nseq(N);
#  VAR nseq := Nseq( N );
#
#
##line 455 "../../../src/gmm/gmm.mx"
##VAR dict := new( str, str );
##dict.rename(sessionId + "dict");
#
#
##line 466 "../../../src/gmm/gmm.mx"
use "kernel/enum";
#  module(enum);
function init_clustertype():int;
#  PROC init_clustertype(): int := {
#    VAR tc;
	kc_a := view_bbp_name();
	lc_a := reverse(kc_a);
barrier	mc_a:= exist(lc_a,"TCluster");
#    IF( view_bbp_name().reverse.exist("TCluster" ) ) {
	tc := enum_load("TCluster");
#      tc := enum_load( "TCluster" );
end	mc_a;
barrier	nc_a:= not(mc_a);
#    } ELSE {
	tc := enum_create("TCluster",cseq);
#      tc := enum_create( "TCluster", cseq );
end	nc_a;
#    }
	return tc;
#    RETURN tc;
end function;
#  }
function destroy_clustertype():void;
#  PROC destroy_clustertype():void := {
	TCluster:= take("TCluster");
	oc_a := enum_drop(TCluster);
#    enum_drop( TCluster );
	pc_a := bat("TCluster");
	qc_a := setTransient(pc_a,);
#    bat("TCluster").setTransient();
end function;
#  }
	TCluster:= init_clustertype();
#  VAR TCluster := init_clustertype();
	cseq:= take("cseq");
	cseq := multiplex.encode(TCluster,cseq);
#  cseq := [encode](TCluster,cseq);
#
#
##line 499 "../../../src/gmm/gmm.mx"
function coeffName(i:int):str;
	rc_a := str(i);
	sc_a := +("Icoeff_",rc_a);
	return sc_a;
end function;
#  PROC coeffName(int i): str := { RETURN "Icoeff_" + str(i); }
function newCollection(cname:str, Nimg:int):bat[str,bat];
#  PROC newCollection( str cname, int Nimg ): BAT[str,bat] := {
	tc_a := new(str,bat);
	res:= rename(tc_a,cname);
#    VAR res := new(str,bat).rename(cname);
	I:= new(void,str,Nimg);
#    VAR I := new( void, str, Nimg );
	uc_a := oid(0);
	vc_a := +(cname,"_I");
	wc_a := setSequenceBase(I,uc_a);
	xc_a := rename(wc_a,vc_a);
#    I.setSequenceBase(oid(0)).rename( cname + "_I" );
	Ib:= new(oid,void,Nimg);
#    VAR Ib := new( oid, void, Nimg );
	Ibr:= reverse(Ib);
#    VAR Ibr:= Ib.reverse;
	yc_a := oid(0);
	ad_a := setSequenceBase(Ibr,yc_a);
#    Ibr.setSequenceBase(oid(0));
	bd_a := +(cname,"_Ib");
	cd_a := rename(Ib,bd_a);
#    Ib.rename( cname + "_Ib" );
	Ix:= new(void,int,Nimg);
#    VAR Ix := new( void, int, Nimg );
	dd_a := oid(0);
	ed_a := setSequenceBase(Ix,dd_a);
#    Ix.setSequenceBase(oid(0));
	fd_a := +(cname,"_Ix");
	gd_a := rename(Ix,fd_a);
#    Ix.rename( cname + "_Ix" );
	Iy:= new(void,int,Nimg);
#    VAR Iy := new( void, int, Nimg );
	hd_a := oid(0);
	id_a := setSequenceBase(Iy,hd_a);
#    Iy.setSequenceBase(oid(0));
	jd_a := +(cname,"_Iy");
	kd_a := rename(Iy,jd_a);
#    Iy.rename( cname + "_Iy" );
	ld_a := insert(res,"I",I);
#    res.insert( "I", I );
	md_a := insert(res,"Ib",Ib);
#    res.insert( "Ib", Ib );
	nd_a := insert(res,"Ix",Ix);
#    res.insert( "Ix", Ix );
	od_a := insert(res,"Iy",Iy);
#    res.insert( "Iy", Iy );
	N:= take("N");
	pd_a := +(cname,"_Icoeffs");
	qd_a := new(int,bat,N);
	coeffs:= rename(qd_a,pd_a);
#    VAR coeffs := new(int,bat,N).rename(cname + "_Icoeffs" );
	i:= 0;
#    VAR i := 0;
barrier	rd_a:= true;
	td_a := <(i,N);
barrier	sd_a:= td_a;
#    WHILE (i < N) {
	x_i:= new(void,sht,Nimg);
#      VAR x_i := new(void,sht,Nimg);
	ud_a := oid(0);
	vd_a := setSequenceBase(x_i,ud_a);
#      x_i.setSequenceBase(oid(0));
	wd_a := coeffName(i);
	xd_a := +("_",wd_a);
	yd_a := +(cname,xd_a);
	ae_a := rename(x_i,yd_a);
#      x_i.rename( cname + "_" + coeffName(i) );
	be_a := insert(coeffs,i,x_i);
#      coeffs.insert( i, x_i );
	x_i := nil;
#      x_i := nil;
	ce_a := :+=(i,1);
#      i :+= 1;
redo	rd_a;
end	sd_a;
end	rd_a;
#    }
	de_a := insert(res,"Coeffs",coeffs);
#    res.insert( "Coeffs", coeffs );
	BAT_READ:= take("BAT_READ");
	ee_a := access(res,BAT_READ);
#    res.access( BAT_READ );
	return res;
#    RETURN res;
end function;
#  }
function newCollection(cname:str):bat[str,bat];
#  PROC newCollection( str cname ): BAT[str,bat] :=
#  {
	fe_a := newCollection(cname,1);
	return fe_a;
#    RETURN newCollection(cname, 1);
end function;
#  }
#
#
##line 546 "../../../src/gmm/gmm.mx"
function paramName(p:str, i:int):str;
#PROC paramName(str p,int i): str := { 
	ge_a := str(i);
	he_a := +("_",ge_a);
	ie_a := +(p,he_a);
	return ie_a;
#  RETURN p + "_" + str(i); 
end function;
#}
function renameGMM(model:bat[str,bat], mname:str):void;
#PROC renameGMM( bat[str,bat] model, str mname ):void := {
	je_a := rename(model,mname);
#  model.rename(mname);
	ke_a_cursor := 0:lng;
barrier	ke_a:= batloop(ke_a_cursor,model,ke_aH,ke_aT);
#  model@batloop(){
	le_a := +("_",ke_aH);
	me_a := +(mname,le_a);
	ne_a := rename(ke_aT,me_a);
#    $t.rename(mname + "_" + $h);
redo	ke_a;
end	ke_a;
#  }
	oe_a := find(model,"Mean");
	pe_a_cursor := 0:lng;
barrier	pe_a:= batloop(pe_a_cursor,oe_a,pe_aH,pe_aT);
#  model.find("Mean")@batloop(){
	qe_a := str(pe_aH);
	re_a := +("_Mean_",qe_a);
	se_a := +(mname,re_a);
	te_a := rename(pe_aT,se_a);
#    $t.rename(mname + "_Mean_" + str($h));
redo	pe_a;
end	pe_a;
#  }
	ue_a := find(model,"Covar");
	ve_a_cursor := 0:lng;
barrier	ve_a:= batloop(ve_a_cursor,ue_a,ve_aH,ve_aT);
#  model.find("Covar")@batloop(){
	we_a := str(ve_aH);
	xe_a := +("_Covar_",we_a);
	ye_a := +(mname,xe_a);
	af_a := rename(ve_aT,ye_a);
#    $t.rename(mname + "_Covar_" + str($h));
redo	ve_a;
end	ve_a;
#  }
end function;
#}
function newGMM(Nimg:int):bat[str,bat];
#PROC newGMM( int Nimg ): BAT[str,bat] := {
	model:= new(str,bat);
#  VAR model := new(str,bat);
	C:= take("C");
	bf_a := *(Nimg,C);
	mImgIdx:= new(oid,void,bf_a);
#  VAR mImgIdx := new(oid,void,Nimg * C);
	cf_a := oid(0);
	df_a := reverse(mImgIdx);
	ef_a := setSequenceBase(df_a,cf_a);
#  mImgIdx.reverse.setSequenceBase(oid(0));
	BAT_APPEND:= take("BAT_APPEND");
	ff_a := access(mImgIdx,BAT_APPEND);
#  mImgIdx.access( BAT_APPEND );
	gf_a := insert(model,"mImgIdx",mImgIdx);
#  model.insert("mImgIdx", mImgIdx);
	TCluster:= take("TCluster");
	hf_a := *(Nimg,C);
	mCIdx:= new(TCluster,void,hf_a);
#  VAR mCIdx := new(TCluster,void,Nimg * C);
	if_a := oid(0);
	jf_a := reverse(mCIdx);
	kf_a := setSequenceBase(jf_a,if_a);
#  mCIdx.reverse.setSequenceBase(oid(0));
	lf_a := access(mCIdx,BAT_APPEND);
#  mCIdx.access( BAT_APPEND );
	mf_a := insert(model,"mCIdx",mCIdx);
#  model.insert("mCIdx", mCIdx);
	nf_a := *(Nimg,C);
	prior:= new(void,flt,nf_a);
#  VAR prior := new(void,flt,Nimg * C);
	of_a := oid(0);
	pf_a := setSequenceBase(prior,of_a);
#  prior.setSequenceBase(oid(0));
	qf_a := access(prior,BAT_APPEND);
#  prior.access( BAT_APPEND );
	rf_a := insert(model,"Prior",prior);
#  model.insert("Prior", prior);
	N:= take("N");
	mean:= new(int,bat,N);
#  VAR mean := new(int,bat,N);
	covar:= new(int,bat,N);
#  VAR covar := new(int,bat,N);
	i:= 0;
#  VAR i := 0;
barrier	sf_a:= true;
	uf_a := <(i,N);
barrier	tf_a:= uf_a;
#  WHILE (i < N) {
	vf_a := *(Nimg,C);
	mean_i:= new(void,flt,vf_a);
#    VAR mean_i := new(void,flt,Nimg*C);
	wf_a := oid(0);
	xf_a := setSequenceBase(mean_i,wf_a);
#    mean_i.setSequenceBase(oid(0));
	yf_a := *(Nimg,C);
	variance_i:= new(void,flt,yf_a);
#    VAR variance_i := new(void,flt,Nimg*C);
	ag_a := oid(0);
	bg_a := setSequenceBase(variance_i,ag_a);
#    variance_i.setSequenceBase(oid(0));
	cg_a := access(mean_i,BAT_APPEND);
#    mean_i.access( BAT_APPEND );
	dg_a := access(variance_i,BAT_APPEND);
#    variance_i.access( BAT_APPEND );
	eg_a := insert(mean,i,mean_i);
#    mean.insert( i, mean_i );
	fg_a := insert(covar,i,variance_i);
#    covar.insert( i, variance_i );
	mean_i := nil;
#    mean_i := nil;
	variance_i := nil;
#    variance_i := nil;
	gg_a := :+=(i,1);
#    i :+= 1;
redo	sf_a;
end	tf_a;
end	sf_a;
#  }
	BAT_READ:= take("BAT_READ");
	hg_a := access(mean,BAT_READ);
#  mean.access( BAT_READ );
	ig_a := access(covar,BAT_READ);
#  covar.access( BAT_READ );
	jg_a := insert(model,"Mean",mean);
#  model.insert( "Mean", mean );
	kg_a := insert(model,"Covar",covar);
#  model.insert( "Covar", covar );
	lg_a := *(Nimg,C);
	init_variances:= new(void,flt,lg_a);
#  VAR init_variances := new(void,flt,Nimg * C);
	mg_a := oid(0);
	ng_a := setSequenceBase(init_variances,mg_a);
#  init_variances.setSequenceBase(oid(0));
	og_a := access(init_variances,BAT_APPEND);
#  init_variances.access( BAT_APPEND );
	pg_a := insert(model,"init_variances",init_variances);
#  model.insert("init_variances", init_variances);
	qg_a := access(model,BAT_READ);
#  model.access( BAT_READ );
	return model;
#  RETURN model;
end function;
#}
function newGMM(mname:str, Nimg:int):bat[str,bat];
#PROC newGMM( str mname, int Nimg ): BAT[str,bat] := {
	gmm:= newGMM(Nimg);
#  VAR gmm := newGMM(Nimg);
	rg_a := renameGMM(gmm,mname);
#  renameGMM(gmm, mname);
	return gmm;
#  RETURN gmm;
end function;
#}
function newGMM(mname:str):bat[str,bat];
#PROC newGMM( str mname ): BAT[str,bat] := {
	sg_a := newGMM(mname,1);
	return sg_a;
#  RETURN newGMM( mname, 1 );
end function;
#}
#
#
##line 669 "../../../src/gmm/gmm.mx"
function newImage(dict:bat[str,str], theUrl:str):oid;
#  PROC newImage( BAT[str,str] dict, str theUrl ): oid := {
#    VAR theImgId;
	tg_a := find(dict,"I");
	ug_a := bat(tg_a);
	vg_a := insert(ug_a,nil,theUrl);
#    bat(dict.find("I")).insert( nil, theUrl );
	I:= take("I");
	wg_a := max(I);
	xg_a := reverse(I);
	theImgId := fetch(xg_a,wg_a);
#    theImgId := I.reverse.fetch( I.max );
	return theImgId;
#    RETURN theImgId;
end function;
#  }
#
#
#
##line 1264 "../../../src/gmm/gmm.mx"
	Niter := 100;
#  CONST Niter     := 100;
	MIN_COVAR := 0.005;
#  CONST MIN_COVAR := 0.005;           # 0.005LL;
	MIN_S := 1.0e-10;
#  CONST MIN_S     := 1.0e-10;	#1.0E-300LL;
	COVAR_INIT_FRACTION := 0.1;
#  CONST COVAR_INIT_FRACTION := 0.1;   # 1.0LL/10;
#
#  VAR olde;
#  VAR loglikelihood;
#  VAR EM_model;
#  VAR EM_coll;
#
#
#
##line 1330 "../../../src/gmm/gmm.mx"
#
#
##line 1431 "../../../src/gmm/gmm.mx"
#
#
##line 1494 "../../../src/gmm/gmm.mx"
#    # PROC EM(int Niter, bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel(Niter:int):bat[str,bat];
#  PROC EM_globalmodel(int Niter): bat[str,bat] := {
#    
##line 1279 "../../../src/gmm/gmm.mx"
	gmm:= EM_model;
#  VAR gmm      := EM_model;
#
	yg_a := find(EM_coll,"I");
	NImg:= count(yg_a);
#  VAR NImg     := EM_coll.find("I").count;
	Ib:= find(EM_coll,"Ib");
#  VAR Ib       := EM_coll.find("Ib");
	coeffs:= find(EM_coll,"Coeffs");
#  VAR coeffs   := EM_coll.find("Coeffs");
#
	sessionId:= take("sessionId");
	ah_a := +(sessionId,"_final");
	bh_a := +("gmm",ah_a);
	gmmfinal:= newGMM(bh_a,NImg);
#  VAR gmmfinal := newGMM("gmm" + sessionId + "_final", NImg);
#  
##line 655 "../../../src/gmm/gmm.mx"
	ch_a := find(gmmfinal,"init_variances");
	BAT_APPEND:= take("BAT_APPEND");
	dh_a := access(ch_a,BAT_APPEND);
#  access( gmmfinal.find("init_variances"), BAT_APPEND );
	eh_a := find(gmmfinal,"Prior");
	fh_a := access(eh_a,BAT_APPEND);
#  access( gmmfinal.find("Prior"), BAT_APPEND );
	gh_a := find(gmmfinal,"mImgIdx");
	hh_a := access(gh_a,BAT_APPEND);
#  access( gmmfinal.find("mImgIdx"), BAT_APPEND );
	ih_a := find(gmmfinal,"mCIdx");
	jh_a := access(ih_a,BAT_APPEND);
#  access( gmmfinal.find("mCIdx"), BAT_APPEND );
	kh_a := find(gmmfinal,"Mean");
	lh_a_cursor := 0:lng;
barrier	lh_a:= batloop(lh_a_cursor,kh_a,lh_aH,lh_aT);
	mh_a := access(lh_aT,BAT_APPEND);
redo	lh_a;
end	lh_a;
#  gmmfinal.find("Mean")@batloop{  access($t, BAT_APPEND); }
	nh_a := find(gmmfinal,"Covar");
	oh_a_cursor := 0:lng;
barrier	oh_a:= batloop(oh_a_cursor,nh_a,oh_aH,oh_aT);
	ph_a := access(oh_aT,BAT_APPEND);
redo	oh_a;
end	oh_a;
#  gmmfinal.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1286 "../../../src/gmm/gmm.mx"
#
#      # @@modelop(gmmfinal,persists,true)@
#  
##line 655 "../../../src/gmm/gmm.mx"
	qh_a := find(gmmfinal,"init_variances");
	STORE_MEM:= take("STORE_MEM");
	rh_a := mmap(qh_a,STORE_MEM);
#  mmap( gmmfinal.find("init_variances"), STORE_MEM );
	sh_a := find(gmmfinal,"Prior");
	th_a := mmap(sh_a,STORE_MEM);
#  mmap( gmmfinal.find("Prior"), STORE_MEM );
	uh_a := find(gmmfinal,"mImgIdx");
	vh_a := mmap(uh_a,STORE_MEM);
#  mmap( gmmfinal.find("mImgIdx"), STORE_MEM );
	wh_a := find(gmmfinal,"mCIdx");
	xh_a := mmap(wh_a,STORE_MEM);
#  mmap( gmmfinal.find("mCIdx"), STORE_MEM );
	yh_a := find(gmmfinal,"Mean");
	ai_a_cursor := 0:lng;
barrier	ai_a:= batloop(ai_a_cursor,yh_a,ai_aH,ai_aT);
	bi_a := mmap(ai_aT,STORE_MEM);
redo	ai_a;
end	ai_a;
#  gmmfinal.find("Mean")@batloop{  mmap($t, STORE_MEM); }
	ci_a := find(gmmfinal,"Covar");
	di_a_cursor := 0:lng;
barrier	di_a:= batloop(di_a_cursor,ci_a,di_aH,di_aT);
	ei_a := mmap(di_aT,STORE_MEM);
redo	di_a;
end	di_a;
#  gmmfinal.find("Covar")@batloop{ mmap($t, STORE_MEM); }
#
#
##line 1288 "../../../src/gmm/gmm.mx"
#
#
	mImgIdx:= find(gmm,"mImgIdx");
#  VAR mImgIdx  := gmm.find("mImgIdx");
	mCIdx:= find(gmm,"mCIdx");
#  VAR mCIdx    := gmm.find("mCIdx");
	fi_a := reverse(Ib);
	xcIdx:= join(fi_a,mImgIdx);
#  VAR xcIdx    := join(Ib.reverse, mImgIdx);
	gi_a := xn(xcIdx);
	xIdx:= reverse(gi_a);
#  VAR xIdx     := xn(xcIdx).reverse;
	cIdx:= nx(xcIdx);
#  VAR cIdx     := nx(xcIdx);
#
#
##line 1496 "../../../src/gmm/gmm.mx"
#
	iter:= 1;
#    VAR iter := 1;
barrier	hi_a:= true;
	ji_a := <(iter,Niter);
barrier	ii_a:= ji_a;
#    WHILE (iter < Niter) {
#      
##line 1349 "../../../src/gmm/gmm.mx"
#  
##line 1331 "../../../src/gmm/gmm.mx"
#  
##line 1305 "../../../src/gmm/gmm.mx"
	covar:= find(gmm,"Covar");
#  VAR covar    := gmm.find("Covar");
	covar := multiplex.nestedop("dbl",covar);
#                  covar := [nestedop]( "dbl", covar);
#  
##line 107 "../../../src/gmm/gmm.mx"
	ki_a := htype(covar);
	li_a := count(covar);
	ivariances:= new(ki_a,bat,li_a);
#  VAR ivariances := new(covar.htype,bat,covar.count);
#  {
	ivariances_lock:= lock_create();
#    VAR ivariances_lock := lock_create();
	Nthreads:= take("Nthreads");
	mi_a_cursor := 0:lng;
barrier	mi_a:= batloop(mi_a_cursor,Nthreads,mi_aH,mi_aT);
#    covar@ [Nthreads]batloop(){
#      VAR _ivariances_result := [inv]($t
	_ivariances_result:= multiplex.inv(mi_aT);
#	   );
	ni_a := lock_set(ivariances_lock);
#      lock_set(ivariances_lock);
	oi_a := insert(ivariances,mi_aH,_ivariances_result);
#      ivariances.insert($h,_ivariances_result);
	pi_a := lock_unset(ivariances_lock);
#      lock_unset(ivariances_lock);
redo	mi_a;
end	mi_a;
#    }
	qi_a := lock_destroy(ivariances_lock);
#    lock_destroy(ivariances_lock);
#  }
#
#
##line 1307 "../../../src/gmm/gmm.mx"
#
	covar := nil;
#                  covar  := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR isqrtdet;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	isqrtdet_a:= fetch(ivariances,0);
	isqrtdet_e:= fetch(ivariances,4);
#    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
	isqrtdet_b:= fetch(ivariances,1);
	isqrtdet_f:= fetch(ivariances,5);
#    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
	isqrtdet_c:= fetch(ivariances,2);
	isqrtdet_g:= fetch(ivariances,6);
#    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
	isqrtdet_d:= fetch(ivariances,3);
	isqrtdet_h:= fetch(ivariances,7);
#    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations isqrtdet_a in parallel
#    {
#      {|
barrier	ri_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_a in parallel
#      {
#	{|
barrier	si_a:= true;
	BAT_WRITE:= take("BAT_WRITE");
	ti_a := multiplex.*(isqrtdet_a,isqrtdet_b);
	isqrtdet_a := access(ti_a,BAT_WRITE);
#	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	isqrtdet_c := multiplex.*(isqrtdet_c,isqrtdet_d);
#	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
end	si_a;
#	 |}
	ui_a := multiplex.:*=(isqrtdet_a,isqrtdet_c);
#	 [:*=](isqrtdet_a,isqrtdet_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_e in parallel
#      {
#	{|
barrier	vi_a:= true;
	wi_a := multiplex.*(isqrtdet_e,isqrtdet_f);
	isqrtdet_e := access(wi_a,BAT_WRITE);
#	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	isqrtdet_g := multiplex.*(isqrtdet_g,isqrtdet_h);
#	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
end	vi_a;
#	 |}
	xi_a := multiplex.:*=(isqrtdet_e,isqrtdet_g);
#	 [:*=](isqrtdet_e,isqrtdet_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	ri_a;
#       |}
	yi_a := multiplex.:*=(isqrtdet_a,isqrtdet_e);
#       [:*=](isqrtdet_a,isqrtdet_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	isqrtdet := isqrtdet_a;
#    isqrtdet := isqrtdet_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1309 "../../../src/gmm/gmm.mx"
#
	isqrtdet := multiplex.sqrt(isqrtdet);
#  isqrtdet     := [sqrt](isqrtdet);
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR xs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	aj_a := htype(coeffs);
	bj_a := count(coeffs);
	xs := new(aj_a,bat,bj_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
	cj_a_cursor := 0:lng;
barrier	cj_a:= batloop(cj_a_cursor,Nthreads,cj_aH,cj_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,cj_aT);
#    VAR _xs_result := join( xIdx, $t );
	dj_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	ej_a := insert(xs,cj_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	fj_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	cj_a;
end	cj_a;
#  }
	gj_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1311 "../../../src/gmm/gmm.mx"
#
	hj_a := find(gmm,"Mean");
	means:= multiplex.join(cIdx,hj_a);
#  VAR means    := [join]( const cIdx, gmm.find("Mean") );
	ivars:= multiplex.join(cIdx,ivariances);
#  VAR ivars    := [join]( const cIdx, ivariances );
	diffs:= multiplex.nestedop("dmahalanobis_i_diagcov",xs,means,ivars);
#  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR dists;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	dists_a:= fetch(diffs,0);
	dists_e:= fetch(diffs,4);
#    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
	dists_b:= fetch(diffs,1);
	dists_f:= fetch(diffs,5);
#    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
	dists_c:= fetch(diffs,2);
	dists_g:= fetch(diffs,6);
#    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
	dists_d:= fetch(diffs,3);
	dists_h:= fetch(diffs,7);
#    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations dists_a in parallel
#    {
#      {|
barrier	ij_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_a in parallel
#      {
#	{|
barrier	jj_a:= true;
	kj_a := multiplex.+(dists_a,dists_b);
	dists_a := access(kj_a,BAT_WRITE);
#	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	dists_c := multiplex.+(dists_c,dists_d);
#	   dists_c := [+](dists_c,dists_d);
end	jj_a;
#	 |}
	lj_a := multiplex.:+=(dists_a,dists_c);
#	 [:+=](dists_a,dists_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_e in parallel
#      {
#	{|
barrier	mj_a:= true;
	nj_a := multiplex.+(dists_e,dists_f);
	dists_e := access(nj_a,BAT_WRITE);
#	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	dists_g := multiplex.+(dists_g,dists_h);
#	   dists_g := [+](dists_g,dists_h);
end	mj_a;
#	 |}
	oj_a := multiplex.:+=(dists_e,dists_g);
#	 [:+=](dists_e,dists_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	ij_a;
#       |}
	pj_a := multiplex.:+=(dists_a,dists_e);
#       [:+=](dists_a,dists_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	dists := dists_a;
#    dists := dists_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1315 "../../../src/gmm/gmm.mx"
#
	xs := nil;
#                  xs     := nil;
	diffs := nil;
#                  diffs  := nil;
	means := nil;
#		  means  := nil;
	ivars := nil;
#		  ivars  := nil;
	ivariances := nil;
#		  ivariances := nil;
	isdet:= join(cIdx,isqrtdet);
#  VAR isdet    := join( cIdx, isqrtdet );
	N:= take("N");
	act:= multiplex.multivariate_gaussian_pdf_diagcov(dists,isdet,N);
#  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
	dists := nil;
#                  dists  := nil;
	isdet := nil;
#                  isdet  := nil;
#
#
##line 1331 "../../../src/gmm/gmm.mx"
#
	qj_a := find(gmm,"Prior");
	rj_a := multiplex.dbl(qj_a);
	priors:= join(cIdx,rj_a);
#  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
	act := multiplex.*(act,priors);
#  act          := [*]( act, priors );
	sj_a := reverse(xIdx);
	tj_a := join(sj_a,act);
	s:= pump.sum(tj_a);
#  VAR s        := {sum}( xIdx.reverse.join(act) );
##  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
##  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
	uj_a := multiplex.>(s,MIN_S);
	vj_a := M2m.ifthen(uj_a,s,1.0LL);
	wj_a:= M2m.batconstruct1(vj_a);
	s := wj_a;
#  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
	xj_a := join(xIdx,s);
	post:= multiplex./(act,xj_a);
#  VAR post     := [/](act,xIdx.join(s));
	priors := nil;
#                  priors := nil;
	act := nil;
#                  act    := nil;
#
#
##line 1349 "../../../src/gmm/gmm.mx"
#
#  
##line 1353 "../../../src/gmm/gmm.mx"
	yj_a := multiplex.log(s);
	loglikelihood := multiplex.*(yj_a,-1);
#  loglikelihood := [*]([log](s), const -1);
	ak_a := join(Ib,loglikelihood);
	loglikelihood := pump.sum(ak_a);
#  loglikelihood := {sum}(join(Ib,loglikelihood));
	s := nil;
#                  s      := nil;
	bk_a := max(loglikelihood);
	ck_a := isnil(bk_a);
barrier	dk_a:= not(ck_a);
#  IF (not(isnil(loglikelihood.max)))
	ek_a := max(loglikelihood);
	fk_a := debug("Iter %d, maxLL %lf",iter,ek_a);
#    debug("Iter %d, maxLL %lf", iter, loglikelihood.max);
#  ELSE
end	dk_a;
barrier	gk_a:= not(dk_a);
	hk_a := debug("Iter %d",iter);
end	gk_a;
#    debug("Iter %d", iter);    
barrier	ik_a:= >(iter,1);
#  IF (iter>1) {
	jk_a := multiplex.-(loglikelihood,olde);
	deltall:= multiplex.abs(jk_a);
#    VAR deltall := [abs]([-](loglikelihood, olde));
##print( loglikelihood, olde, deltall );
	kk_a := multiplex.<(deltall,1.0LL);
	converged:= uselect(kk_a,1);
#    VAR converged := [<](deltall, const 1.0LL).uselect(true);
	lk_a_cursor := 0:lng;
barrier	lk_a:= batloop(lk_a_cursor,converged,lk_aH,lk_aT);
#    converged@batloop(){
	mk_a := "Image %3d converged to (local?) maximum of likelihood";
	nk_a := debug(mk_a,lk_aH);
#      debug("Image %3d converged to (local?) maximum of likelihood", $h);
redo	lk_a;
end	lk_a;
#    }
	ok_a := count(converged);
barrier	pk_a:= >(ok_a,0);
#    IF (converged.count > 0) {
	loglikelihood := kdiff(loglikelihood,converged);
#      loglikelihood := kdiff( loglikelihood, converged );
#      
##line 1386 "../../../src/gmm/gmm.mx"
	restgmm:= new(str,bat);
#  VAR restgmm := new(str,bat);
#
#  VAR fff;
#  {
	qk_a := find(gmmfinal,"mImgIdx");
	rk_a := count(qk_a);
	convNewId:= oid(rk_a);
#    VAR convNewId := oid(gmmfinal.find("mImgIdx").count);
	sk_a := mirror(converged);
	convIdx:= join(sk_a,mImgIdx);
#    VAR convIdx   := join(converged.mirror, mImgIdx);
#    
##line 611 "../../../src/gmm/gmm.mx"
#{
	tk_a := reverse(convIdx);
	uk_a := mark(tk_a,convNewId);
	fIdx:= reverse(uk_a);
#  VAR fIdx := convIdx.reverse.mark(convNewId).reverse;
#
	vk_a := find(gmm,"mImgIdx");
	wk_a := reverse(vk_a);
	convImgIdx:= join(fIdx,wk_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	xk_a := find(gmm,"mCIdx");
	yk_a := reverse(xk_a);
	convCIdx:= join(fIdx,yk_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	al_a := find(gmmfinal,"mImgIdx");
	bl_a := info(al_a);
	cl_a := find(bl_a,"hkey");
	dl_a := debug("<PROPCHECK1 hkey=%s />",cl_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	el_a := reverse(convImgIdx);
	fl_a := find(gmmfinal,"mImgIdx");
	gl_a := insert(fl_a,el_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	hl_a := find(gmmfinal,"mImgIdx");
	il_a := info(hl_a);
	jl_a := find(il_a,"hkey");
	kl_a := debug("<PROPCHECK2 hkey=%s />",jl_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	ll_a := reverse(convCIdx);
	ml_a := find(gmmfinal,"mCIdx");
	nl_a := insert(ml_a,ll_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	ol_a := find(gmm,"Prior");
	pl_a := join(fIdx,ol_a);
	ql_a := find(gmmfinal,"Prior");
	rl_a := insert(ql_a,pl_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	sl_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	tl_a := find(gmm,"Mean");
	ul_a := multiplex.join(fIdx,tl_a);
	vl_a := multiplex.insert(sl_a,ul_a);
#            [join](const fIdx, gmm.find("Mean")) );
	wl_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	xl_a := find(gmm,"Covar");
	yl_a := multiplex.join(fIdx,xl_a);
	am_a := multiplex.insert(wl_a,yl_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	bm_a := find(gmm,"init_variances");
	cm_a := join(fIdx,bm_a);
	dm_a := find(gmmfinal,"init_variances");
	em_a := insert(dm_a,cm_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1392 "../../../src/gmm/gmm.mx"
#
#    
##line 1376 "../../../src/gmm/gmm.mx"
	fm_a := find(gmmfinal,"mImgIdx");
	gm_a := kunique(fm_a);
	hm_a := count(gm_a);
barrier	im_a:= =(hm_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	jm_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	im_a;
#      BREAK;
#    }
#
#
##line 1393 "../../../src/gmm/gmm.mx"
#
#
end	im_a;
	nconvIdx:= diff(mImgIdx,convIdx);
#    VAR nconvIdx  := diff(mImgIdx,convIdx);
#    
##line 634 "../../../src/gmm/gmm.mx"
	km_a := oid(0);
	lm_a := reverse(nconvIdx);
	mm_a := mark(lm_a,km_a);
	fIdx:= reverse(mm_a);
#VAR fIdx           := nconvIdx.reverse.mark(oid(0)).reverse;
#{
	nm_a := find(gmm,"mImgIdx");
	om_a := reverse(nm_a);
	convImgIdx:= join(fIdx,om_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	pm_a := find(gmm,"mCIdx");
	qm_a := reverse(pm_a);
	convCIdx:= join(fIdx,qm_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	rm_a := reverse(convImgIdx);
	sm_a := insert(restgmm,"mImgIdx",rm_a);
#  restgmm.insert( "mImgIdx", convImgIdx.reverse );
	tm_a := reverse(convCIdx);
	um_a := insert(restgmm,"mCIdx",tm_a);
#  restgmm.insert( "mCIdx",   convCIdx.reverse );
#
	vm_a := find(gmm,"Prior");
	wm_a := join(fIdx,vm_a);
	xm_a := insert(restgmm,"Prior",wm_a);
#  restgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	ym_a := find(gmm,"Mean");
	an_a := multiplex.join(fIdx,ym_a);
	bn_a := insert(restgmm,"Mean",an_a);
#  restgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	cn_a := find(gmm,"Covar");
	dn_a := multiplex.join(fIdx,cn_a);
	en_a := insert(restgmm,"Covar",dn_a);
#  restgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	fn_a := find(gmm,"init_variances");
	gn_a := join(fIdx,fn_a);
	hn_a := insert(restgmm,"init_variances",gn_a);
#  restgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1396 "../../../src/gmm/gmm.mx"
#
#
	fff := fIdx;
#    fff := fIdx;
#  }
	in_a := str(iter);
	jn_a := +(in_a,"_rest");
	kn_a := +("_",jn_a);
	ln_a := +(sessionId,kn_a);
	mn_a := +("gmm",ln_a);
	nn_a := renameGMM(restgmm,mn_a);
#  renameGMM(restgmm,"gmm" + sessionId + "_" + str(iter) + "_rest");
#  
##line 655 "../../../src/gmm/gmm.mx"
	on_a := find(restgmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	pn_a := access(on_a,BAT_READ);
#  access( restgmm.find("init_variances"), BAT_READ );
	qn_a := find(restgmm,"Prior");
	rn_a := access(qn_a,BAT_READ);
#  access( restgmm.find("Prior"), BAT_READ );
	sn_a := find(restgmm,"mImgIdx");
	tn_a := access(sn_a,BAT_READ);
#  access( restgmm.find("mImgIdx"), BAT_READ );
	un_a := find(restgmm,"mCIdx");
	vn_a := access(un_a,BAT_READ);
#  access( restgmm.find("mCIdx"), BAT_READ );
	wn_a := find(restgmm,"Mean");
	xn_a_cursor := 0:lng;
barrier	xn_a:= batloop(xn_a_cursor,wn_a,xn_aH,xn_aT);
	yn_a := access(xn_aT,BAT_READ);
redo	xn_a;
end	xn_a;
#  restgmm.find("Mean")@batloop{  access($t, BAT_READ); }
	ao_a := find(restgmm,"Covar");
	bo_a_cursor := 0:lng;
barrier	bo_a:= batloop(bo_a_cursor,ao_a,bo_aH,bo_aT);
	co_a := access(bo_aT,BAT_READ);
redo	bo_a;
end	bo_a;
#  restgmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1401 "../../../src/gmm/gmm.mx"
#
	gmm := restgmm;
#  gmm         := restgmm;
	restgmm := nil;
#  restgmm     := nil;
#
	Ib := kdiff(Ib,converged);
#  Ib          := kdiff(Ib, converged);
	iIdx:= nx(Ib);
#  VAR iIdx    := nx(Ib); # <new oid, old oid>
	Ib := xn(Ib);
#  Ib          := xn(Ib);
#
	oldc:= coeffs;
#  VAR oldc    := coeffs; # UGLY: nestedjoin macro makes new variable
#  
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	do_a := htype(oldc);
	eo_a := count(oldc);
	coeffs := new(do_a,bat,eo_a);
#  coeffs := new(oldc.htype,bat,oldc.count);
	coeffs_lock:= lock_create();
#  VAR coeffs_lock := lock_create();
	fo_a_cursor := 0:lng;
barrier	fo_a:= batloop(fo_a_cursor,Nthreads,fo_aH,fo_aT);
#  oldc@ [Nthreads]batloop(){
	_coeffs_result:= join(iIdx,fo_aT);
#    VAR _coeffs_result := join( iIdx, $t );
	go_a := lock_set(coeffs_lock);
#    lock_set(coeffs_lock);
	ho_a := insert(coeffs,fo_aH,_coeffs_result);
#    coeffs.insert( $h, _coeffs_result );
	io_a := lock_unset(coeffs_lock);
#    lock_unset(coeffs_lock);
redo	fo_a;
end	fo_a;
#  }
	jo_a := lock_destroy(coeffs_lock);
#  lock_destroy(coeffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1410 "../../../src/gmm/gmm.mx"
#
	oldc := nil;
#                  oldc    := nil;
#
	ko_a := reverse(iIdx);
	xIdx := join(xIdx,ko_a);
#  xIdx        := join(xIdx, iIdx.reverse);
	lo_a := xn(xIdx);
	newxIdx:= reverse(lo_a);
#  VAR newxIdx := xn(xIdx).reverse;
	xIdx := nx(xIdx);
#  xIdx        := nx(xIdx);
	post := join(newxIdx,post);
#  post        := join(newxIdx, post);
	cIdx := join(newxIdx,cIdx);
#  cIdx        := join(newxIdx, cIdx);
	mo_a := reverse(fff);
	cIdx := join(cIdx,mo_a);
#  cIdx        := join( cIdx, fff.reverse ); # renumber for mCIdx/mImgIdx
	newxIdx := nil;
#                  newxIdx := nil;             
	fff := nil;
#                  fff     := nil;             
#
	mImgIdx := find(gmm,"mImgIdx");
#  mImgIdx     := gmm.find("mImgIdx");
	mCIdx := find(gmm,"mCIdx");
#  mCIdx       := gmm.find("mCIdx");
#
#
##line 1369 "../../../src/gmm/gmm.mx"
#
#    }
#    
##line 1376 "../../../src/gmm/gmm.mx"
end	pk_a;
	no_a := find(gmmfinal,"mImgIdx");
	oo_a := kunique(no_a);
	po_a := count(oo_a);
barrier	qo_a:= =(po_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	ro_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	qo_a;
#      BREAK;
#    }
#
#
##line 1371 "../../../src/gmm/gmm.mx"
#
end	qo_a;
#  }
end	ik_a;
	olde := loglikelihood;
#  olde := loglikelihood;
#
#
##line 1350 "../../../src/gmm/gmm.mx"
#
#
#
##line 1499 "../../../src/gmm/gmm.mx"
#
#      
##line 1432 "../../../src/gmm/gmm.mx"
	so_a := reverse(cIdx);
	to_a := join(so_a,post);
	newpr:= pump.sum(to_a);
#   VAR newpr     := {sum}( cIdx.reverse.join(post) );
	newpr := multiplex.flt(newpr);
#                  newpr := [flt]( newpr );
#   VAR newpriors := [/]( newpr,
	uo_a := reverse(Ib);
	vo_a := histogram(uo_a);
	wo_a := reverse(mImgIdx);
	xo_a := join(wo_a,vo_a);
	newpriors:= multiplex./(newpr,xo_a);
#                         mImgIdx.reverse.join( Ib.reverse.histogram ) );
#debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",
	yo_a := reverse(cIdx);
	ap_a := join(yo_a,post);
	bp_a := count(ap_a);
#  cIdx.reverse.join(post).count,
	cp_a := count(newpr);
#  newpr.count,
	dp_a := count(newpriors);
#  newpriors.count,
	ep_a := reverse(Ib);
#  Ib.reverse.histogram.count
	fp_a := histogram(ep_a);
	gp_a := count(fp_a);
	hp_a := debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",bp_a,cp_a,dp_a,gp_a);
#);
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	ip_a := htype(coeffs);
	jp_a := count(coeffs);
	xs := new(ip_a,bat,jp_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
	kp_a_cursor := 0:lng;
barrier	kp_a:= batloop(kp_a_cursor,Nthreads,kp_aH,kp_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,kp_aT);
#    VAR _xs_result := join( xIdx, $t );
	lp_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	mp_a := insert(xs,kp_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	np_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	kp_a;
end	kp_a;
#  }
	op_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1443 "../../../src/gmm/gmm.mx"
#
	xhc:= multiplex.nestedop("*",xs,post);
#   VAR xhc       := [nestedop]( "*", xs, const post );
	xhc := multiplex.nestedop("flt",xhc);
#                  xhc := [nestedop]("flt", xhc);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR gxhc;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	pp_a := htype(xhc);
	qp_a := count(xhc);
	gxhc := new(pp_a,bat,qp_a);
#  gxhc := new(xhc.htype,bat,xhc.count);
	gxhc_lock:= lock_create();
#  VAR gxhc_lock := lock_create();
	rp_a_cursor := 0:lng;
barrier	rp_a:= batloop(rp_a_cursor,Nthreads,rp_aH,rp_aT);
#  xhc@ [Nthreads]batloop(){
	sp_a := reverse(cIdx);
	_gxhc_result:= join(sp_a,rp_aT);
#    VAR _gxhc_result := join( cIdx.reverse, $t );
	tp_a := lock_set(gxhc_lock);
#    lock_set(gxhc_lock);
	up_a := insert(gxhc,rp_aH,_gxhc_result);
#    gxhc.insert( $h, _gxhc_result );
	vp_a := lock_unset(gxhc_lock);
#    lock_unset(gxhc_lock);
redo	rp_a;
end	rp_a;
#  }
	wp_a := lock_destroy(gxhc_lock);
#  lock_destroy(gxhc_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1446 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	xp_a := htype(gxhc);
	yp_a := count(gxhc);
	newc:= new(xp_a,bat,yp_a);
#  VAR newc := new(gxhc.htype,bat,gxhc.count);
#  {
	newc_lock:= lock_create();
#    VAR newc_lock := lock_create();
	aq_a_cursor := 0:lng;
barrier	aq_a:= batloop(aq_a_cursor,Nthreads,aq_aH,aq_aT);
#    gxhc@ [Nthreads]batloop(){
#      VAR _newc_result := {sum}($t
	_newc_result:= pump.sum(aq_aT);
#	   );
	bq_a := lock_set(newc_lock);
#      lock_set(newc_lock);
	cq_a := insert(newc,aq_aH,_newc_result);
#      newc.insert($h,_newc_result);
	dq_a := lock_unset(newc_lock);
#      lock_unset(newc_lock);
redo	aq_a;
end	aq_a;
#    }
	eq_a := lock_destroy(newc_lock);
#    lock_destroy(newc_lock);
#  }
#
#
##line 1447 "../../../src/gmm/gmm.mx"
#
	gxhc := nil;
#                  gxhc    := nil;
	xhc := nil;
#                  xhc     := nil;
	newmeans:= multiplex.nestedop("/",newc,newpr);
#   VAR newmeans  := [nestedop]("/", newc, const newpr);
	newc := nil;
#                  newc    := nil;
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	fq_a := htype(newmeans);
	gq_a := count(newmeans);
	means := new(fq_a,bat,gq_a);
#  means := new(newmeans.htype,bat,newmeans.count);
	means_lock:= lock_create();
#  VAR means_lock := lock_create();
	hq_a_cursor := 0:lng;
barrier	hq_a:= batloop(hq_a_cursor,Nthreads,hq_aH,hq_aT);
#  newmeans@ [Nthreads]batloop(){
	_means_result:= join(cIdx,hq_aT);
#    VAR _means_result := join( cIdx, $t );
	iq_a := lock_set(means_lock);
#    lock_set(means_lock);
	jq_a := insert(means,hq_aH,_means_result);
#    means.insert( $h, _means_result );
	kq_a := lock_unset(means_lock);
#    lock_unset(means_lock);
redo	hq_a;
end	hq_a;
#  }
	lq_a := lock_destroy(means_lock);
#  lock_destroy(means_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1453 "../../../src/gmm/gmm.mx"
#
	hdiffs:= multiplex.nestedop("-",xs,means);
#   VAR hdiffs    := [nestedop]("-",xs,means);
	xs := nil;
#                  xs      := nil;
	means := nil;
#                  means   := nil;
	hdiffs := multiplex.square(hdiffs);
#   hdiffs        := [square](hdiffs);
	hdiffs := multiplex.nestedop("*",hdiffs,post);
#   hdiffs	 := [nestedop]("*",hdiffs,const post);
	hdiffs := multiplex.nestedop("flt",hdiffs);
#                  hdiffs := [nestedop]("flt", hdiffs);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR ghdiffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	mq_a := htype(hdiffs);
	nq_a := count(hdiffs);
	ghdiffs := new(mq_a,bat,nq_a);
#  ghdiffs := new(hdiffs.htype,bat,hdiffs.count);
	ghdiffs_lock:= lock_create();
#  VAR ghdiffs_lock := lock_create();
	oq_a_cursor := 0:lng;
barrier	oq_a:= batloop(oq_a_cursor,Nthreads,oq_aH,oq_aT);
#  hdiffs@ [Nthreads]batloop(){
	pq_a := reverse(cIdx);
	_ghdiffs_result:= join(pq_a,oq_aT);
#    VAR _ghdiffs_result := join( cIdx.reverse, $t );
	qq_a := lock_set(ghdiffs_lock);
#    lock_set(ghdiffs_lock);
	rq_a := insert(ghdiffs,oq_aH,_ghdiffs_result);
#    ghdiffs.insert( $h, _ghdiffs_result );
	sq_a := lock_unset(ghdiffs_lock);
#    lock_unset(ghdiffs_lock);
redo	oq_a;
end	oq_a;
#  }
	tq_a := lock_destroy(ghdiffs_lock);
#  lock_destroy(ghdiffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1460 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	uq_a := htype(ghdiffs);
	vq_a := count(ghdiffs);
	diffs:= new(uq_a,bat,vq_a);
#  VAR diffs := new(ghdiffs.htype,bat,ghdiffs.count);
#  {
	diffs_lock:= lock_create();
#    VAR diffs_lock := lock_create();
	wq_a_cursor := 0:lng;
barrier	wq_a:= batloop(wq_a_cursor,Nthreads,wq_aH,wq_aT);
#    ghdiffs@ [Nthreads]batloop(){
#      VAR _diffs_result := {sum}($t
	_diffs_result:= pump.sum(wq_aT);
#	   );
	xq_a := lock_set(diffs_lock);
#      lock_set(diffs_lock);
	yq_a := insert(diffs,wq_aH,_diffs_result);
#      diffs.insert($h,_diffs_result);
	ar_a := lock_unset(diffs_lock);
#      lock_unset(diffs_lock);
redo	wq_a;
end	wq_a;
#    }
	br_a := lock_destroy(diffs_lock);
#    lock_destroy(diffs_lock);
#  }
#
#
##line 1461 "../../../src/gmm/gmm.mx"
#
	ghdiffs := nil;
#                  ghdiffs := nil;
	hdiffs := nil;
#                  hdiffs  := nil;
	newvars:= multiplex.nestedop("/",diffs,newpr);
#   VAR newvars   := [nestedop]("/",diffs,const newpr);
	diffs := nil;
#                  diffs   := nil;
#
#
##line 1500 "../../../src/gmm/gmm.mx"
#
#      
##line 1471 "../../../src/gmm/gmm.mx"
#   
##line 130 "../../../src/gmm/gmm.mx"
#VAR minvars;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	minvars_a:= fetch(newvars,0);
	minvars_e:= fetch(newvars,4);
#    VAR minvars_a := newvars.fetch(0);    VAR minvars_e := newvars.fetch(4);
	minvars_b:= fetch(newvars,1);
	minvars_f:= fetch(newvars,5);
#    VAR minvars_b := newvars.fetch(1);    VAR minvars_f := newvars.fetch(5);
	minvars_c:= fetch(newvars,2);
	minvars_g:= fetch(newvars,6);
#    VAR minvars_c := newvars.fetch(2);    VAR minvars_g := newvars.fetch(6);
	minvars_d:= fetch(newvars,3);
	minvars_h:= fetch(newvars,7);
#    VAR minvars_d := newvars.fetch(3);    VAR minvars_h := newvars.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations minvars_a in parallel
#    {
#      {|
barrier	cr_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_a in parallel
#      {
#	{|
barrier	dr_a:= true;
	er_a := multiplex.min(minvars_a,minvars_b);
	minvars_a := access(er_a,BAT_WRITE);
#	   minvars_a := [min](minvars_a,minvars_b).access(BAT_WRITE);
	minvars_c := multiplex.min(minvars_c,minvars_d);
#	   minvars_c := [min](minvars_c,minvars_d);
end	dr_a;
#	 |}
	fr_a := multiplex.:min=(minvars_a,minvars_c);
#	 [:min=](minvars_a,minvars_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_e in parallel
#      {
#	{|
barrier	gr_a:= true;
	hr_a := multiplex.min(minvars_e,minvars_f);
	minvars_e := access(hr_a,BAT_WRITE);
#	   minvars_e := [min](minvars_e,minvars_f).access(BAT_WRITE);
	minvars_g := multiplex.min(minvars_g,minvars_h);
#	   minvars_g := [min](minvars_g,minvars_h);
end	gr_a;
#	 |}
	ir_a := multiplex.:min=(minvars_e,minvars_g);
#	 [:min=](minvars_e,minvars_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	cr_a;
#       |}
	jr_a := multiplex.:min=(minvars_a,minvars_e);
#       [:min=](minvars_a,minvars_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	minvars := minvars_a;
#    minvars := minvars_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1471 "../../../src/gmm/gmm.mx"
#
	covarsmall:= multiplex.<(minvars,MIN_COVAR);
#   VAR covarsmall    := [<](minvars,const MIN_COVAR);
	covarnil:= multiplex.isnil(minvars);
#   VAR covarnil      := [isnil](minvars);
	kr_a := multiplex.or(covarsmall,covarnil);
	covarnotsmall:= multiplex.not(kr_a);
#   VAR covarnotsmall := [not]([or](covarsmall,covarnil));
	covarsmall := nil;
#                  covarsmall := nil;
	covarnil := nil;
#                  covarnil   := nil;
	lr_a := select(covarnotsmall,0);
	Ntoosmall:= count(lr_a);
#   VAR Ntoosmall     := select(covarnotsmall,false).count;
barrier	mr_a:= >(Ntoosmall,0);
#   IF ( Ntoosmall > 0 ) {
	nr_a := "Covariance too small in %d model(s)";
	or_a := debug(nr_a,Ntoosmall);
#     debug("Covariance too small in %d model(s)", Ntoosmall);
	init_variances:= find(gmm,"init_variances");
#     VAR init_variances := gmm.find("init_variances");
	pr_a := htype(newvars);
	qr_a := count(newvars);
	ccovars:= new(pr_a,bat,qr_a);
#     VAR ccovars   := new( newvars.htype, bat, newvars.count );
	rr_a_cursor := 0:lng;
barrier	rr_a:= batloop(rr_a_cursor,newvars,rr_aH,rr_aT);
#     newvars@batloop(){
	sr_a := M2m.ifthen(covarnotsmall,rr_aT,init_variances);
	tr_a:= M2m.batconstruct1(sr_a);
	cv:= tr_a;
#       VAR cv := [ covarnotsmall ? $t : init_variances ];
	ur_a := insert(ccovars,rr_aH,cv);
#       ccovars.insert($h, cv);
redo	rr_a;
end	rr_a;
#     }
	newvars := ccovars;
#     newvars := ccovars;
#   }
#
#
##line 1501 "../../../src/gmm/gmm.mx"
#
end	mr_a;
	vr_a := :+=(iter,1);
#      iter :+= 1;
#
	gmmnew:= new(str,bat);
#      VAR gmmnew := new(str,bat);
	wr_a := insert(gmmnew,"Prior",newpriors);
#      gmmnew.insert( "Prior",  newpriors );
	xr_a := insert(gmmnew,"Mean",newmeans);
#      gmmnew.insert( "Mean",   newmeans );
	yr_a := insert(gmmnew,"Covar",newvars);
#      gmmnew.insert( "Covar",  newvars );
#
	as_a := insert(gmmnew,"mImgIdx",mImgIdx);
#      gmmnew.insert("mImgIdx", mImgIdx );
	bs_a := insert(gmmnew,"mCIdx",mCIdx);
#      gmmnew.insert("mCIdx",   mCIdx );
	cs_a := find(gmm,"init_variances");
	ds_a := insert(gmmnew,"init_variances",cs_a);
#      gmmnew.insert("init_variances", gmm.find("init_variances") );
#      
##line 655 "../../../src/gmm/gmm.mx"
	es_a := find(gmmnew,"init_variances");
	fs_a := access(es_a,BAT_READ);
#  access( gmmnew.find("init_variances"), BAT_READ );
	gs_a := find(gmmnew,"Prior");
	hs_a := access(gs_a,BAT_READ);
#  access( gmmnew.find("Prior"), BAT_READ );
	is_a := find(gmmnew,"mImgIdx");
	js_a := access(is_a,BAT_READ);
#  access( gmmnew.find("mImgIdx"), BAT_READ );
	ks_a := find(gmmnew,"mCIdx");
	ls_a := access(ks_a,BAT_READ);
#  access( gmmnew.find("mCIdx"), BAT_READ );
	ms_a := find(gmmnew,"Mean");
	ns_a_cursor := 0:lng;
barrier	ns_a:= batloop(ns_a_cursor,ms_a,ns_aH,ns_aT);
	os_a := access(ns_aT,BAT_READ);
redo	ns_a;
end	ns_a;
#  gmmnew.find("Mean")@batloop{  access($t, BAT_READ); }
	ps_a := find(gmmnew,"Covar");
	qs_a_cursor := 0:lng;
barrier	qs_a:= batloop(qs_a_cursor,ps_a,qs_aH,qs_aT);
	rs_a := access(qs_aT,BAT_READ);
redo	qs_a;
end	qs_a;
#  gmmnew.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1512 "../../../src/gmm/gmm.mx"
#
	ss_a := str(iter);
	ts_a := +("_",ss_a);
	us_a := +(sessionId,ts_a);
	vs_a := +("gmm",us_a);
	ws_a := renameGMM(gmmnew,vs_a);
#      gmmnew.renameGMM("gmm" + sessionId + "_" + str(iter));
#
	gmm := gmmnew;
#      gmm := gmmnew;
#
barrier	xs_a:= =(iter,2);
#      IF (iter = 2) {
#        # free memory for globals
	EM_coll := nil;
#        EM_coll  := nil;
	EM_model := nil;
#        EM_model := nil;
#      }
end	xs_a;
redo	hi_a;
end	ii_a;
end	hi_a;
#    }
barrier	ys_a:= =(iter,Niter);
#    IF (iter = Niter) {
	at_a := debug("Not all images have converged");
#      debug("Not all images have converged");
	bt_a := find(gmmfinal,"mImgIdx");
	ct_a := count(bt_a);
	lastId:= oid(ct_a);
#      VAR lastId       := oid(gmmfinal.find("mImgIdx").count);
	remainingIdx:= find(gmm,"mImgIdx");
#      VAR remainingIdx := gmm.find("mImgIdx");
#      
##line 611 "../../../src/gmm/gmm.mx"
#{
	dt_a := reverse(remainingIdx);
	et_a := mark(dt_a,lastId);
	fIdx:= reverse(et_a);
#  VAR fIdx := remainingIdx.reverse.mark(lastId).reverse;
#
	ft_a := find(gmm,"mImgIdx");
	gt_a := reverse(ft_a);
	convImgIdx:= join(fIdx,gt_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	ht_a := find(gmm,"mCIdx");
	it_a := reverse(ht_a);
	convCIdx:= join(fIdx,it_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	jt_a := find(gmmfinal,"mImgIdx");
	kt_a := info(jt_a);
	lt_a := find(kt_a,"hkey");
	mt_a := debug("<PROPCHECK1 hkey=%s />",lt_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	nt_a := reverse(convImgIdx);
	ot_a := find(gmmfinal,"mImgIdx");
	pt_a := insert(ot_a,nt_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	qt_a := find(gmmfinal,"mImgIdx");
	rt_a := info(qt_a);
	st_a := find(rt_a,"hkey");
	tt_a := debug("<PROPCHECK2 hkey=%s />",st_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	ut_a := reverse(convCIdx);
	vt_a := find(gmmfinal,"mCIdx");
	wt_a := insert(vt_a,ut_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	xt_a := find(gmm,"Prior");
	yt_a := join(fIdx,xt_a);
	au_a := find(gmmfinal,"Prior");
	bu_a := insert(au_a,yt_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	cu_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	du_a := find(gmm,"Mean");
	eu_a := multiplex.join(fIdx,du_a);
	fu_a := multiplex.insert(cu_a,eu_a);
#            [join](const fIdx, gmm.find("Mean")) );
	gu_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	hu_a := find(gmm,"Covar");
	iu_a := multiplex.join(fIdx,hu_a);
	ju_a := multiplex.insert(gu_a,iu_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	ku_a := find(gmm,"init_variances");
	lu_a := join(fIdx,ku_a);
	mu_a := find(gmmfinal,"init_variances");
	nu_a := insert(mu_a,lu_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1527 "../../../src/gmm/gmm.mx"
#
#    }
#      # @@modelop(gmmfinal,persists,false)@
end	ys_a;
	return gmmfinal;
#    RETURN gmmfinal;
end function;
#  }
#
#    # PROC EM(bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel():bat[str,bat];
#  PROC EM_globalmodel():bat[str,bat] := {
	Niter:= take("Niter");
	ou_a := EM_globalmodel(Niter);
	return ou_a;
#    RETURN EM_globalmodel(Niter);
end function;
#  }
#
#
#
##line 1557 "../../../src/gmm/gmm.mx"
	Nsamples := 100;
#  CONST Nsamples := 100;
	mu_1 := 5.0LL;
	sigma_1 := 2.0LL;
#  CONST mu_1 := 5.0LL; CONST sigma_1 := 2.0LL;
	mu_2 := 7.0LL;
	sigma_2 := 3.0LL;
#  CONST mu_2 := 7.0LL; CONST sigma_2 := 3.0LL;
#
function mix2g():dbl;
#  PROC mix2g(): dbl := {
	rand:= take("rand");
	pu_a := and(rand,15);
barrier	qu_a:= >(pu_a,10);
#    IF ( (rand and 15) > 10 ) 
	ru_a := ran_gaussian(mu_1,sigma_1);
	return ru_a;
#      RETURN ran_gaussian(mu_1,sigma_1);
end	qu_a;
barrier	su_a:= not(qu_a);
	tu_a := ran_gaussian(mu_2,sigma_2);
	return tu_a;
end	su_a;
#    ELSE RETURN ran_gaussian(mu_2,sigma_2);
end function;
#  }
#
function gen2mix(Nel:int):bat[void,dbl];
#  PROC gen2mix(int Nel):BAT[void,dbl] := {
	res:= new(void,dbl);
#    VAR res := new(void,dbl);
	uu_a := oid(0);
	vu_a := setSequenceBase(res,uu_a);
#    res.setSequenceBase(oid(0));
	i:= 0;
#    VAR i := 0;
barrier	wu_a:= true;
	yu_a := <(i,Nel);
barrier	xu_a:= yu_a;
#    WHILE (i < Nel) {
	av_a := mix2g();
	bv_a := insert(res,nil,av_a);
#      res.insert(nil, mix2g());
	cv_a := :+=(i,1);
#      i :+=1; 
redo	wu_a;
end	xu_a;
end	wu_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#
##line 1591 "../../../src/gmm/gmm.mx"
function cumsum_multiplex(xs:bat[any::1,any]):bat[any::1,lng];
#  PROC [cumsum](BAT[any::1,any] xs): BAT[any::1,lng] := {
	dv_a := htype(xs);
	ev_a := count(xs);
	res:= new(dv_a,lng,ev_a);
#    VAR res := new(xs.htype,lng,xs.count);
	s:= lng(0);
#    VAR s := lng(0);
	fv_a_cursor := 0:lng;
barrier	fv_a:= batloop(fv_a_cursor,xs,fv_aH,fv_aT);
#    xs@batloop(){
	gv_a := :+=(s,fv_aT);
#      s :+= $t;
	hv_a := insert(res,fv_aH,s);
#      res.insert( $h, s );
redo	fv_a;
end	fv_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[int,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[int,flt] prior): bat[void,any::1] := {
	iv_a := htype(prior);
	res:= new(oid,iv_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	jv_a := randseq(Nsamples);
	samp:= multiplex.lng(jv_a);
#    VAR samp := [lng](randseq(Nsamples));
	kv_a := multiplex.*(prior,RAND_MAX);
	lv_a := multiplex.int(kv_a);
	mv_a := multiplex.cumsum(lv_a);
	cint:= reverse(mv_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	nv_a_cursor := 0:lng;
barrier	nv_a:= batloop(nv_a_cursor,cint,nv_aH,nv_aT);
#    cint@batloop(){
	ie:= nv_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	ov_a := multiplex.>(samp,ib);
	pv_a := multiplex.<=(samp,ie);
	qv_a := multiplex.and(ov_a,pv_a);
	rv_a := uselect(qv_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	sv_a := project(rv_a,nv_aT);
	tv_a := insert(res,sv_a);
#      );
	ib := ie;
#      ib := ie;
redo	nv_a;
end	nv_a;
#    }
	uv_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	vv_a := nx(res);
	wv_a := access(vv_a,BAT_READ);
	return wv_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1601 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[TCluster,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[TCluster,flt] prior): bat[void,any::1] := {
	xv_a := htype(prior);
	res:= new(oid,xv_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	yv_a := randseq(Nsamples);
	samp:= multiplex.lng(yv_a);
#    VAR samp := [lng](randseq(Nsamples));
	aw_a := multiplex.*(prior,RAND_MAX);
	bw_a := multiplex.int(aw_a);
	cw_a := multiplex.cumsum(bw_a);
	cint:= reverse(cw_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	dw_a_cursor := 0:lng;
barrier	dw_a:= batloop(dw_a_cursor,cint,dw_aH,dw_aT);
#    cint@batloop(){
	ie:= dw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	ew_a := multiplex.>(samp,ib);
	fw_a := multiplex.<=(samp,ie);
	gw_a := multiplex.and(ew_a,fw_a);
	hw_a := uselect(gw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	iw_a := project(hw_a,dw_aT);
	jw_a := insert(res,iw_a);
#      );
	ib := ie;
#      ib := ie;
redo	dw_a;
end	dw_a;
#    }
	kw_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	lw_a := nx(res);
	mw_a := access(lw_a,BAT_READ);
	return mw_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1602 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[void,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[void,flt] prior): bat[void,any::1] := {
	nw_a := htype(prior);
	res:= new(oid,nw_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	ow_a := randseq(Nsamples);
	samp:= multiplex.lng(ow_a);
#    VAR samp := [lng](randseq(Nsamples));
	pw_a := multiplex.*(prior,RAND_MAX);
	qw_a := multiplex.int(pw_a);
	rw_a := multiplex.cumsum(qw_a);
	cint:= reverse(rw_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	sw_a_cursor := 0:lng;
barrier	sw_a:= batloop(sw_a_cursor,cint,sw_aH,sw_aT);
#    cint@batloop(){
	ie:= sw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	tw_a := multiplex.>(samp,ib);
	uw_a := multiplex.<=(samp,ie);
	vw_a := multiplex.and(tw_a,uw_a);
	ww_a := uselect(vw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	xw_a := project(ww_a,sw_aT);
	yw_a := insert(res,xw_a);
#      );
	ib := ie;
#      ib := ie;
redo	sw_a;
end	sw_a;
#    }
	ax_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	bx_a := nx(res);
	cx_a := access(bx_a,BAT_READ);
	return cx_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1603 "../../../src/gmm/gmm.mx"
#
#
#
##line 1623 "../../../src/gmm/gmm.mx"
function gmmsamp_diag(Nsamples:int, gmm:bat[str,bat]):bat[str,bat];
#  PROC gmmsamp_diag( int Nsamples, bat[str,bat] gmm ): bat[str,bat] := {
	res:= new(str,bat,2);
#    VAR res := new(str,bat,2);
	N:= take("N");
	samples:= new(int,bat,N);
#    VAR samples := new(int,bat,N);
#    VAR XX;
	nseq:= take("nseq");
	dx_a_cursor := 0:lng;
barrier	dx_a:= batloop(dx_a_cursor,nseq,dx_aH,dx_aT);
#    nseq@batloop{ 
	XX := new(void,dbl,Nsamples);
#	XX:= new(void,dbl,Nsamples);
	ex_a := oid(0);
	fx_a := setSequenceBase(XX,ex_a);
!ERROR: "	XX.setSequenceBase(oid(0))); }"
!        																												^
! parse error.
