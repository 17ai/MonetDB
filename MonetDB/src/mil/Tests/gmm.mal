# Mil compiler Version 1.0)
# Copyright (c) 1993-2001, CWI. All rights reserved.

# Predefined code segment
##CHANGES TO ORIGINAL:
## seqbase -> setSequenceBase
## persists(FALSE) -> setTransient
## persists(TRUE) -> setPersistent
##line 23 "../../../src/gmm/gmm.mx"
use "kernel/io";
use "kernel/alarm";
use "kernel/lock";
use "kernel/mmath";
use "kernel/xtables";
use "kernel/mgsl";
use "kernel/space";
#  module(io,alarm,lock,mmath,xtables,mgsl,space);
	Nthreads := 4;
#  CONST Nthreads  := 4;
	aa_a := newoid();
	ba_a := int(aa_a);
	sessionId := +("S",ba_a);
#  CONST sessionId := "S" + int(newoid());
#  VAR   randomseed;
	randomseed := 40;
#randomseed := 40;
	ca_a := mem_maxsize(1000000000LL);
#mem_maxsize(1000000000LL);
	da_a := vm_maxsize(2000000000LL);
#vm_maxsize( 2000000000LL);
function init_modgmm():void;
#  PROC init_modgmm():void := { 
	curthreads:= threadcnt(0);
#    VAR curthreads := threadcnt(0);
	ea_a := +(Nthreads,1);
barrier	fa_a:= <(curthreads,ea_a);
#    IF (curthreads < (Nthreads + 1)) 
	ga_a := -(Nthreads,curthreads);
	ha_a := +(ga_a,1);
	ia_a := threadcnt(ha_a);
#	threadcnt( (Nthreads - curthreads) + 1 );
end	fa_a;
barrier	ja_a:= isnil(randomseed);
	randomseed := time();
#    IF (isnil(randomseed)) randomseed := time();
end	ja_a;
	ka_a := srand(randomseed);
#    srand(randomseed);
end function;
#  }
	la_a := init_modgmm();
#  init_modgmm();
#
	GMMdebuglog:= fopen("/ufs/arjen/tmp/GMM.log","a");
#  VAR GMMdebuglog := fopen("/ufs/arjen/tmp/GMM.log", "a");
function debug(msg:str,msg:any[]):void;
#  PROC debug( str msg, ..any.. ):void := {
	ma_a := +(msg," @ %s\n");
	na_a := +("GMM: ",ma_a);
	oa_a := mil.getVarTempRange(2);
	pa_a := ctime();
	qa_a := trim(pa_a);
	ra_a := fprintf(GMMdebuglog,na_a,oa_a,qa_a);
#    fprintf( GMMdebuglog, "GMM: " + msg + " @ %s\n", $(2..), trim( ctime() ) );
	sa_a := fflush(GMMdebuglog);
#    fflush( GMMdebuglog );
end function;
#  }
	sessionId:= take("sessionId");
	ta_a := debug("Starting gmm.mil session %s",sessionId);
#  debug("Starting gmm.mil session %s", sessionId);
#
function _x(x:bat[any,any::1]):bat[void,any::1];
	ua_a := reverse(x);
	va_a := mark(ua_a,nil);
	wa_a := reverse(va_a);
	return wa_a;
end function;
#  PROC _x(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(nil).reverse;}
function nx(x:bat[any,any::1]):bat[void,any::1];
	xa_a := oid(0);
	ya_a := reverse(x);
	ab_a := mark(ya_a,xa_a);
	bb_a := reverse(ab_a);
	return bb_a;
end function;
#  PROC nx(BAT[any,any::1] x):BAT[void,any::1] := {RETURN x.reverse.mark(oid(0)).reverse;}
function x_(x:bat[any::1,any]):bat[any::1,void];
	cb_a := mark(x,nil);
	return cb_a;
end function;
#  PROC x_(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(nil);}
function xn(x:bat[any::1,any]):bat[any::1,void];
	db_a := oid(0);
	eb_a := mark(x,db_a);
	return eb_a;
end function;
#  PROC xn(BAT[any::1,any] x):BAT[any::1,void] := {RETURN x.mark(oid(0));}
function Nseq(N:int):bat[void,int];
#  PROC Nseq(int N):BAT[void,int] := {
	i:= 0;
	fb_a := oid(0);
	gb_a := new(void,int);
	seq:= setSequenceBase(gb_a,fb_a);
#    VAR i := 0; VAR seq := new(void,int).setSequenceBase(oid(0));
barrier	hb_a:= true;
	jb_a := <(i,N);
barrier	ib_a:= jb_a;
	kb_a := insert(seq,nil,i);
	lb_a := :+=(i,1);
redo	hb_a;
end	ib_a;
end	hb_a;
#    WHILE (i<N) { seq.insert(nil,i); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
function randseq(N:int):bat[void,int];
#  PROC randseq(int N):BAT[void,int] := {
	i:= 0;
	mb_a := oid(0);
	nb_a := new(void,int);
	seq:= setSequenceBase(nb_a,mb_a);
#    VAR i := 0; VAR seq := new(void,int).setSequenceBase(oid(0));
barrier	ob_a:= true;
	qb_a := <(i,N);
barrier	pb_a:= qb_a;
	rb_a := rand();
	sb_a := insert(seq,nil,rb_a);
	tb_a := :+=(i,1);
redo	ob_a;
end	pb_a;
end	ob_a;
#    WHILE (i<N) { seq.insert(nil,rand()); i:+=1; }
	return seq;
#    RETURN seq;
end function;
#  }
#
#  # casting bats of bats should have worked with [dbl] but doesn't -- BUG!
function conv2sht(b:bat[any::1,any]):bat[any::1,sht];
	ub_a := multiplex.sht(b);
	return ub_a;
end function;
#  PROC conv2sht(BAT[any::1,any] b):BAT[any::1,sht] := {RETURN [sht](b);}
function conv2flt(b:bat[any::1,any]):bat[any::1,flt];
	vb_a := multiplex.flt(b);
	return vb_a;
end function;
#  PROC conv2flt(BAT[any::1,any] b):BAT[any::1,flt] := {RETURN [flt](b);}
function conv2dbl(b:bat[any::1,any]):bat[any::1,dbl];
	wb_a := multiplex.dbl(b);
	return wb_a;
end function;
#  PROC conv2dbl(BAT[any::1,any] b):BAT[any::1,dbl] := {RETURN [dbl](b);}
#
function sqrt(x:flt):dbl;
	xb_a := dbl(x);
	yb_a := sqrt(xb_a);
	return yb_a;
end function;
#  PROC sqrt(flt x):dbl := {RETURN sqrt(dbl(x));}
function sqrt_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ac_a := multiplex.dbl(x);
	bc_a := multiplex.sqrt(ac_a);
	return bc_a;
end function;
#  PROC [sqrt](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [sqrt]([dbl](x));}
function log(x:flt):dbl;
	cc_a := dbl(x);
	dc_a := log(cc_a);
	return dc_a;
end function;
#  PROC log(flt x):dbl := {RETURN log(dbl(x));}
function log_multiplex(x:bat[any::1,flt]):bat[any::1,dbl];
	ec_a := multiplex.dbl(x);
	fc_a := multiplex.log(ec_a);
	return fc_a;
end function;
#  PROC [log](BAT[any::1,flt] x):BAT[any::1,dbl] := {RETURN [log]([dbl](x));}
#
#
##line 77 "../../../src/gmm/gmm.mx"
#  # circumvent parsing problems with [[op]](bat[bat],bat[bat])
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any]):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y):BAT[any::1,any] := {
	gc_a := mil.multiplex_deref(op,x,y);
	return gc_a;
#    RETURN [* op](x, y); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any], y:bat[any::1,any], z:any):bat[any::1,any];
#  PROC nestedop(str op, bat[any::1,any] x, bat[any::1,any] y, any z):BAT[any::1,any] := 
#  {
	hc_a := mil.multiplex_deref(op,x,y,z);
	return hc_a;
#    RETURN [* op](x, y, z); 
end function;
#  }
function nestedop(op:str, x:bat[any::1,any::2]):bat[any::1,any::2];
#  PROC nestedop(str op, bat[any::1,any::2] x):BAT[any::1,any::2] := {
	ic_a := mil.multiplex_deref(op,x);
	return ic_a;
#    RETURN [* op](x); 
end function;
#  }
#
function square(x:bat[any::1,any::2]):bat[any::1,any::2];
	jc_a := multiplex.*(x,x);
	return jc_a;
end function;
#  PROC square(bat[any::1,any::2] x):BAT[any::1,any::2] := {RETURN [*](x, x );}
#
#  #  post@batloop{
#  #    VAR p := $t;
#  #    p.access(BAT_WRITE);
#  #    [:/=](p, s);
#  #    p.access(BAT_READ);
#  #  }
#
#
#
##line 392 "../../../src/gmm/gmm.mx"
	N := 8;
#  CONST N := 8;
	C := 8;
#  CONST C := 8;
#
	cseq:= Nseq(C);
#  VAR cseq := Nseq( C );
	nseq:= Nseq(N);
#  VAR nseq := Nseq( N );
#
#
##line 455 "../../../src/gmm/gmm.mx"
##VAR dict := new( str, str );
##dict.rename(sessionId + "dict");
#
#
##line 466 "../../../src/gmm/gmm.mx"
use "kernel/enum";
#  module(enum);
function init_clustertype():int;
#  PROC init_clustertype(): int := {
#    VAR tc;
	kc_a := view_bbp_name();
	lc_a := reverse(kc_a);
barrier	mc_a:= exist(lc_a,"TCluster");
#    IF( view_bbp_name().reverse.exist("TCluster" ) ) {
	tc := enum_load("TCluster");
#      tc := enum_load( "TCluster" );
end	mc_a;
barrier	nc_a:= not(mc_a);
#    } ELSE {
	tc := enum_create("TCluster",cseq);
#      tc := enum_create( "TCluster", cseq );
end	nc_a;
#    }
	return tc;
#    RETURN tc;
end function;
#  }
function destroy_clustertype():void;
#  PROC destroy_clustertype():void := {
	TCluster:= take("TCluster");
	oc_a := enum_drop(TCluster);
#    enum_drop( TCluster );
	pc_a := bat("TCluster");
	qc_a := setTransient(pc_a,);
#    bat("TCluster").setTransient();
end function;
#  }
	TCluster:= init_clustertype();
#  VAR TCluster := init_clustertype();
	cseq:= take("cseq");
	cseq := multiplex.encode(TCluster,cseq);
#  cseq := [encode](TCluster,cseq);
#
#
##line 499 "../../../src/gmm/gmm.mx"
function coeffName(i:int):str;
	rc_a := str(i);
	sc_a := +("Icoeff_",rc_a);
	return sc_a;
end function;
#  PROC coeffName(int i): str := { RETURN "Icoeff_" + str(i); }
function newCollection(cname:str, Nimg:int):bat[str,bat];
#  PROC newCollection( str cname, int Nimg ): BAT[str,bat] := {
	tc_a := new(str,bat);
	res:= rename(tc_a,cname);
#    VAR res := new(str,bat).rename(cname);
	uc_a := oid(0);
	vc_a := new(void,str,Nimg);
	wc_a := +(cname,"_I");
	xc_a := setSequenceBase(vc_a,uc_a);
	I:= rename(xc_a,wc_a);
#    VAR I := new( void, str, Nimg ).setSequenceBase(oid(0)).rename( cname + "_I" );
	yc_a := new(oid,void,Nimg);
	ad_a := oid(0);
	bd_a := reverse(yc_a);
	cd_a := setSequenceBase(bd_a,ad_a);
	dd_a := +(cname,"_Ib");
	ed_a := reverse(cd_a);
	Ib:= rename(ed_a,dd_a);
#    VAR Ib := new( oid, void, Nimg ).reverse.setSequenceBase(oid(0)).reverse.rename( cname + "_Ib" );
	fd_a := oid(0);
	gd_a := new(void,int,Nimg);
	hd_a := +(cname,"_Ix");
	id_a := setSequenceBase(gd_a,fd_a);
	Ix:= rename(id_a,hd_a);
#    VAR Ix := new( void, int, Nimg ).setSequenceBase(oid(0)).rename( cname + "_Ix" );
	jd_a := oid(0);
	kd_a := new(void,int,Nimg);
	ld_a := +(cname,"_Iy");
	md_a := setSequenceBase(kd_a,jd_a);
	Iy:= rename(md_a,ld_a);
#    VAR Iy := new( void, int, Nimg ).setSequenceBase(oid(0)).rename( cname + "_Iy" );
	nd_a := insert(res,"I",I);
#    res.insert( "I", I );
	od_a := insert(res,"Ib",Ib);
#    res.insert( "Ib", Ib );
	pd_a := insert(res,"Ix",Ix);
#    res.insert( "Ix", Ix );
	qd_a := insert(res,"Iy",Iy);
#    res.insert( "Iy", Iy );
	N:= take("N");
	rd_a := +(cname,"_Icoeffs");
	sd_a := new(int,bat,N);
	coeffs:= rename(sd_a,rd_a);
#    VAR coeffs := new(int,bat,N).rename(cname + "_Icoeffs" );
	i:= 0;
#    VAR i := 0;
barrier	td_a:= true;
	vd_a := <(i,N);
barrier	ud_a:= vd_a;
#    WHILE (i < N) {
	wd_a := oid(0);
	xd_a := new(void,sht,Nimg);
	yd_a := coeffName(i);
	ae_a := +("_",yd_a);
	be_a := +(cname,ae_a);
	ce_a := setSequenceBase(xd_a,wd_a);
	x_i:= rename(ce_a,be_a);
#      VAR x_i := new(void,sht,Nimg).setSequenceBase(oid(0)).rename( cname + "_" + coeffName(i) );
	de_a := insert(coeffs,i,x_i);
#      coeffs.insert( i, x_i );
	x_i := nil;
#      x_i := nil;
	ee_a := :+=(i,1);
#      i :+= 1;
redo	td_a;
end	ud_a;
end	td_a;
#    }
	fe_a := insert(res,"Coeffs",coeffs);
#    res.insert( "Coeffs", coeffs );
	BAT_READ:= take("BAT_READ");
	ge_a := access(res,BAT_READ);
#    res.access( BAT_READ );
	return res;
#    RETURN res;
end function;
#  }
function newCollection(cname:str):bat[str,bat];
#  PROC newCollection( str cname ): BAT[str,bat] :=
#  {
	he_a := newCollection(cname,1);
	return he_a;
#    RETURN newCollection(cname, 1);
end function;
#  }
#
#
##line 546 "../../../src/gmm/gmm.mx"
function paramName(p:str, i:int):str;
#PROC paramName(str p,int i): str := { 
	ie_a := str(i);
	je_a := +("_",ie_a);
	ke_a := +(p,je_a);
	return ke_a;
#  RETURN p + "_" + str(i); 
end function;
#}
function renameGMM(model:bat[str,bat], mname:str):void;
#PROC renameGMM( bat[str,bat] model, str mname ):void := {
	le_a := rename(model,mname);
#  model.rename(mname);
	me_a_cursor := 0:lng;
barrier	me_a:= batloop(me_a_cursor,model,me_aH,me_aT);
#  model@batloop(){
	ne_a := +("_",me_aH);
	oe_a := +(mname,ne_a);
	pe_a := rename(me_aT,oe_a);
#    $t.rename(mname + "_" + $h);
redo	me_a;
end	me_a;
#  }
	qe_a := find(model,"Mean");
	re_a_cursor := 0:lng;
barrier	re_a:= batloop(re_a_cursor,qe_a,re_aH,re_aT);
#  model.find("Mean")@batloop(){
	se_a := str(re_aH);
	te_a := +("_Mean_",se_a);
	ue_a := +(mname,te_a);
	ve_a := rename(re_aT,ue_a);
#    $t.rename(mname + "_Mean_" + str($h));
redo	re_a;
end	re_a;
#  }
	we_a := find(model,"Covar");
	xe_a_cursor := 0:lng;
barrier	xe_a:= batloop(xe_a_cursor,we_a,xe_aH,xe_aT);
#  model.find("Covar")@batloop(){
	ye_a := str(xe_aH);
	af_a := +("_Covar_",ye_a);
	bf_a := +(mname,af_a);
	cf_a := rename(xe_aT,bf_a);
#    $t.rename(mname + "_Covar_" + str($h));
redo	xe_a;
end	xe_a;
#  }
end function;
#}
function newGMM(Nimg:int):bat[str,bat];
#PROC newGMM( int Nimg ): BAT[str,bat] := {
	model:= new(str,bat);
#  VAR model := new(str,bat);
	C:= take("C");
	df_a := *(Nimg,C);
	mImgIdx:= new(oid,void,df_a);
#  VAR mImgIdx := new(oid,void,Nimg * C);
	ef_a := oid(0);
	ff_a := reverse(mImgIdx);
	gf_a := setSequenceBase(ff_a,ef_a);
#  mImgIdx.reverse.setSequenceBase(oid(0));
	BAT_APPEND:= take("BAT_APPEND");
	hf_a := access(mImgIdx,BAT_APPEND);
#  mImgIdx.access( BAT_APPEND );
	if_a := insert(model,"mImgIdx",mImgIdx);
#  model.insert("mImgIdx", mImgIdx);
	TCluster:= take("TCluster");
	jf_a := *(Nimg,C);
	mCIdx:= new(TCluster,void,jf_a);
#  VAR mCIdx := new(TCluster,void,Nimg * C);
	kf_a := oid(0);
	lf_a := reverse(mCIdx);
	mf_a := setSequenceBase(lf_a,kf_a);
#  mCIdx.reverse.setSequenceBase(oid(0));
	nf_a := access(mCIdx,BAT_APPEND);
#  mCIdx.access( BAT_APPEND );
	of_a := insert(model,"mCIdx",mCIdx);
#  model.insert("mCIdx", mCIdx);
	pf_a := *(Nimg,C);
	qf_a := oid(0);
	rf_a := new(void,flt,pf_a);
	prior:= setSequenceBase(rf_a,qf_a);
#  VAR prior := new(void,flt,Nimg * C).setSequenceBase(oid(0));
	sf_a := access(prior,BAT_APPEND);
#  prior.access( BAT_APPEND );
	tf_a := insert(model,"Prior",prior);
#  model.insert("Prior", prior);
	N:= take("N");
	mean:= new(int,bat,N);
#  VAR mean := new(int,bat,N);
	covar:= new(int,bat,N);
#  VAR covar := new(int,bat,N);
	i:= 0;
#  VAR i := 0;
barrier	uf_a:= true;
	wf_a := <(i,N);
barrier	vf_a:= wf_a;
#  WHILE (i < N) {
	xf_a := *(Nimg,C);
	yf_a := oid(0);
	ag_a := new(void,flt,xf_a);
	mean_i:= setSequenceBase(ag_a,yf_a);
#    VAR mean_i := new(void,flt,Nimg*C).setSequenceBase(oid(0));
	bg_a := *(Nimg,C);
	cg_a := oid(0);
	dg_a := new(void,flt,bg_a);
	variance_i:= setSequenceBase(dg_a,cg_a);
#    VAR variance_i := new(void,flt,Nimg*C).setSequenceBase(oid(0));
	eg_a := access(mean_i,BAT_APPEND);
#    mean_i.access( BAT_APPEND );
	fg_a := access(variance_i,BAT_APPEND);
#    variance_i.access( BAT_APPEND );
	gg_a := insert(mean,i,mean_i);
#    mean.insert( i, mean_i );
	hg_a := insert(covar,i,variance_i);
#    covar.insert( i, variance_i );
	mean_i := nil;
#    mean_i := nil;
	variance_i := nil;
#    variance_i := nil;
	ig_a := :+=(i,1);
#    i :+= 1;
redo	uf_a;
end	vf_a;
end	uf_a;
#  }
	BAT_READ:= take("BAT_READ");
	jg_a := access(mean,BAT_READ);
#  mean.access( BAT_READ );
	kg_a := access(covar,BAT_READ);
#  covar.access( BAT_READ );
	lg_a := insert(model,"Mean",mean);
#  model.insert( "Mean", mean );
	mg_a := insert(model,"Covar",covar);
#  model.insert( "Covar", covar );
	ng_a := *(Nimg,C);
	og_a := oid(0);
	pg_a := new(void,flt,ng_a);
	init_variances:= setSequenceBase(pg_a,og_a);
#  VAR init_variances := new(void,flt,Nimg * C).setSequenceBase(oid(0));
	qg_a := access(init_variances,BAT_APPEND);
#  init_variances.access( BAT_APPEND );
	rg_a := insert(model,"init_variances",init_variances);
#  model.insert("init_variances", init_variances);
	sg_a := access(model,BAT_READ);
#  model.access( BAT_READ );
	return model;
#  RETURN model;
end function;
#}
function newGMM(mname:str, Nimg:int):bat[str,bat];
#PROC newGMM( str mname, int Nimg ): BAT[str,bat] := {
	gmm:= newGMM(Nimg);
#  VAR gmm := newGMM(Nimg);
	tg_a := renameGMM(gmm,mname);
#  renameGMM(gmm, mname);
	return gmm;
#  RETURN gmm;
end function;
#}
function newGMM(mname:str):bat[str,bat];
#PROC newGMM( str mname ): BAT[str,bat] := {
	ug_a := newGMM(mname,1);
	return ug_a;
#  RETURN newGMM( mname, 1 );
end function;
#}
#
#
##line 669 "../../../src/gmm/gmm.mx"
function newImage(dict:bat[str,str], theUrl:str):oid;
#  PROC newImage( BAT[str,str] dict, str theUrl ): oid := {
#    VAR theImgId;
	vg_a := find(dict,"I");
	wg_a := bat(vg_a);
	xg_a := insert(wg_a,nil,theUrl);
#    bat(dict.find("I")).insert( nil, theUrl );
	I:= take("I");
	yg_a := max(I);
	ah_a := reverse(I);
	theImgId := fetch(ah_a,yg_a);
#    theImgId := I.reverse.fetch( I.max );
	return theImgId;
#    RETURN theImgId;
end function;
#  }
#
#
#
##line 1264 "../../../src/gmm/gmm.mx"
	Niter := 100;
#  CONST Niter     := 100;
	MIN_COVAR := 0.005;
#  CONST MIN_COVAR := 0.005;           # 0.005LL;
	MIN_S := 1.0E-300LL;
#  CONST MIN_S     := 1.0E-300LL;
	COVAR_INIT_FRACTION := 0.1;
#  CONST COVAR_INIT_FRACTION := 0.1;   # 1.0LL/10;
#
#  VAR olde;
#  VAR loglikelihood;
#  VAR EM_model;
#  VAR EM_coll;
#
#
#
##line 1330 "../../../src/gmm/gmm.mx"
#
#
##line 1431 "../../../src/gmm/gmm.mx"
#
#
##line 1494 "../../../src/gmm/gmm.mx"
#    # PROC EM(int Niter, bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel(Niter:int):bat[str,bat];
#  PROC EM_globalmodel(int Niter): bat[str,bat] := {
#    
##line 1279 "../../../src/gmm/gmm.mx"
	gmm:= EM_model;
#  VAR gmm      := EM_model;
#
	bh_a := find(EM_coll,"I");
	NImg:= count(bh_a);
#  VAR NImg     := EM_coll.find("I").count;
	Ib:= find(EM_coll,"Ib");
#  VAR Ib       := EM_coll.find("Ib");
	coeffs:= find(EM_coll,"Coeffs");
#  VAR coeffs   := EM_coll.find("Coeffs");
#
	sessionId:= take("sessionId");
	ch_a := +(sessionId,"_final");
	dh_a := +("gmm",ch_a);
	gmmfinal:= newGMM(dh_a,NImg);
#  VAR gmmfinal := newGMM("gmm" + sessionId + "_final", NImg);
#  
##line 655 "../../../src/gmm/gmm.mx"
	eh_a := find(gmmfinal,"init_variances");
	BAT_APPEND:= take("BAT_APPEND");
	fh_a := access(eh_a,BAT_APPEND);
#  access( gmmfinal.find("init_variances"), BAT_APPEND );
	gh_a := find(gmmfinal,"Prior");
	hh_a := access(gh_a,BAT_APPEND);
#  access( gmmfinal.find("Prior"), BAT_APPEND );
	ih_a := find(gmmfinal,"mImgIdx");
	jh_a := access(ih_a,BAT_APPEND);
#  access( gmmfinal.find("mImgIdx"), BAT_APPEND );
	kh_a := find(gmmfinal,"mCIdx");
	lh_a := access(kh_a,BAT_APPEND);
#  access( gmmfinal.find("mCIdx"), BAT_APPEND );
	mh_a := find(gmmfinal,"Mean");
	nh_a_cursor := 0:lng;
barrier	nh_a:= batloop(nh_a_cursor,mh_a,nh_aH,nh_aT);
	oh_a := access(nh_aT,BAT_APPEND);
redo	nh_a;
end	nh_a;
#  gmmfinal.find("Mean")@batloop{  access($t, BAT_APPEND); }
	ph_a := find(gmmfinal,"Covar");
	qh_a_cursor := 0:lng;
barrier	qh_a:= batloop(qh_a_cursor,ph_a,qh_aH,qh_aT);
	rh_a := access(qh_aT,BAT_APPEND);
redo	qh_a;
end	qh_a;
#  gmmfinal.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1286 "../../../src/gmm/gmm.mx"
#
#      # @@modelop(gmmfinal,persists,true)@
#  
##line 655 "../../../src/gmm/gmm.mx"
	sh_a := find(gmmfinal,"init_variances");
	STORE_MEM:= take("STORE_MEM");
	th_a := mmap(sh_a,STORE_MEM);
#  mmap( gmmfinal.find("init_variances"), STORE_MEM );
	uh_a := find(gmmfinal,"Prior");
	vh_a := mmap(uh_a,STORE_MEM);
#  mmap( gmmfinal.find("Prior"), STORE_MEM );
	wh_a := find(gmmfinal,"mImgIdx");
	xh_a := mmap(wh_a,STORE_MEM);
#  mmap( gmmfinal.find("mImgIdx"), STORE_MEM );
	yh_a := find(gmmfinal,"mCIdx");
	ai_a := mmap(yh_a,STORE_MEM);
#  mmap( gmmfinal.find("mCIdx"), STORE_MEM );
	bi_a := find(gmmfinal,"Mean");
	ci_a_cursor := 0:lng;
barrier	ci_a:= batloop(ci_a_cursor,bi_a,ci_aH,ci_aT);
	di_a := mmap(ci_aT,STORE_MEM);
redo	ci_a;
end	ci_a;
#  gmmfinal.find("Mean")@batloop{  mmap($t, STORE_MEM); }
	ei_a := find(gmmfinal,"Covar");
	fi_a_cursor := 0:lng;
barrier	fi_a:= batloop(fi_a_cursor,ei_a,fi_aH,fi_aT);
	gi_a := mmap(fi_aT,STORE_MEM);
redo	fi_a;
end	fi_a;
#  gmmfinal.find("Covar")@batloop{ mmap($t, STORE_MEM); }
#
#
##line 1288 "../../../src/gmm/gmm.mx"
#
#
	mImgIdx:= find(gmm,"mImgIdx");
#  VAR mImgIdx  := gmm.find("mImgIdx");
	mCIdx:= find(gmm,"mCIdx");
#  VAR mCIdx    := gmm.find("mCIdx");
	hi_a := reverse(Ib);
	xcIdx:= join(hi_a,mImgIdx);
#  VAR xcIdx    := join(Ib.reverse, mImgIdx);
	ii_a := xn(xcIdx);
	xIdx:= reverse(ii_a);
#  VAR xIdx     := xn(xcIdx).reverse;
	cIdx:= nx(xcIdx);
#  VAR cIdx     := nx(xcIdx);
#
#
##line 1496 "../../../src/gmm/gmm.mx"
#
	iter:= 1;
#    VAR iter := 1;
barrier	ji_a:= true;
	li_a := <(iter,Niter);
barrier	ki_a:= li_a;
#    WHILE (iter < Niter) {
#      
##line 1349 "../../../src/gmm/gmm.mx"
#  
##line 1331 "../../../src/gmm/gmm.mx"
#  
##line 1305 "../../../src/gmm/gmm.mx"
	covar:= find(gmm,"Covar");
#  VAR covar    := gmm.find("Covar");
	covar := multiplex.nestedop("dbl",covar);
#                  covar := [nestedop]( "dbl", covar);
#  
##line 107 "../../../src/gmm/gmm.mx"
	mi_a := htype(covar);
	ni_a := count(covar);
	ivariances:= new(mi_a,bat,ni_a);
#  VAR ivariances := new(covar.htype,bat,covar.count);
#  {
	ivariances_lock:= lock_create();
#    VAR ivariances_lock := lock_create();
	Nthreads:= take("Nthreads");
	oi_a_cursor := 0:lng;
barrier	oi_a:= batloop(oi_a_cursor,Nthreads,oi_aH,oi_aT);
#    covar@ [Nthreads]batloop(){
#      VAR _ivariances_result := [inv]($t
	_ivariances_result:= multiplex.inv(oi_aT);
#	   );
	pi_a := lock_set(ivariances_lock);
#      lock_set(ivariances_lock);
	qi_a := insert(ivariances,oi_aH,_ivariances_result);
#      ivariances.insert($h,_ivariances_result);
	ri_a := lock_unset(ivariances_lock);
#      lock_unset(ivariances_lock);
redo	oi_a;
end	oi_a;
#    }
	si_a := lock_destroy(ivariances_lock);
#    lock_destroy(ivariances_lock);
#  }
#
#
##line 1307 "../../../src/gmm/gmm.mx"
#
	covar := nil;
#                  covar  := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR isqrtdet;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	isqrtdet_a:= fetch(ivariances,0);
	isqrtdet_e:= fetch(ivariances,4);
#    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
	isqrtdet_b:= fetch(ivariances,1);
	isqrtdet_f:= fetch(ivariances,5);
#    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
	isqrtdet_c:= fetch(ivariances,2);
	isqrtdet_g:= fetch(ivariances,6);
#    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
	isqrtdet_d:= fetch(ivariances,3);
	isqrtdet_h:= fetch(ivariances,7);
#    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations isqrtdet_a in parallel
#    {
#      {|
barrier	ti_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_a in parallel
#      {
#	{|
barrier	ui_a:= true;
	BAT_WRITE:= take("BAT_WRITE");
	vi_a := multiplex.*(isqrtdet_a,isqrtdet_b);
	isqrtdet_a := access(vi_a,BAT_WRITE);
#	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	isqrtdet_c := multiplex.*(isqrtdet_c,isqrtdet_d);
#	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
end	ui_a;
#	 |}
	wi_a := multiplex.:*=(isqrtdet_a,isqrtdet_c);
#	 [:*=](isqrtdet_a,isqrtdet_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_e in parallel
#      {
#	{|
barrier	xi_a:= true;
	yi_a := multiplex.*(isqrtdet_e,isqrtdet_f);
	isqrtdet_e := access(yi_a,BAT_WRITE);
#	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	isqrtdet_g := multiplex.*(isqrtdet_g,isqrtdet_h);
#	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
end	xi_a;
#	 |}
	aj_a := multiplex.:*=(isqrtdet_e,isqrtdet_g);
#	 [:*=](isqrtdet_e,isqrtdet_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	ti_a;
#       |}
	bj_a := multiplex.:*=(isqrtdet_a,isqrtdet_e);
#       [:*=](isqrtdet_a,isqrtdet_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	isqrtdet := isqrtdet_a;
#    isqrtdet := isqrtdet_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1309 "../../../src/gmm/gmm.mx"
#
	isqrtdet := multiplex.sqrt(isqrtdet);
#  isqrtdet     := [sqrt](isqrtdet);
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR xs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	cj_a := htype(coeffs);
	dj_a := count(coeffs);
	xs := new(cj_a,bat,dj_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
	ej_a_cursor := 0:lng;
barrier	ej_a:= batloop(ej_a_cursor,Nthreads,ej_aH,ej_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,ej_aT);
#    VAR _xs_result := join( xIdx, $t );
	fj_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	gj_a := insert(xs,ej_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	hj_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	ej_a;
end	ej_a;
#  }
	ij_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1311 "../../../src/gmm/gmm.mx"
#
	jj_a := find(gmm,"Mean");
	means:= multiplex.join(cIdx,jj_a);
#  VAR means    := [join]( const cIdx, gmm.find("Mean") );
	ivars:= multiplex.join(cIdx,ivariances);
#  VAR ivars    := [join]( const cIdx, ivariances );
	diffs:= multiplex.nestedop("dmahalanobis_i_diagcov",xs,means,ivars);
#  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR dists;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	dists_a:= fetch(diffs,0);
	dists_e:= fetch(diffs,4);
#    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
	dists_b:= fetch(diffs,1);
	dists_f:= fetch(diffs,5);
#    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
	dists_c:= fetch(diffs,2);
	dists_g:= fetch(diffs,6);
#    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
	dists_d:= fetch(diffs,3);
	dists_h:= fetch(diffs,7);
#    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations dists_a in parallel
#    {
#      {|
barrier	kj_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_a in parallel
#      {
#	{|
barrier	lj_a:= true;
	mj_a := multiplex.+(dists_a,dists_b);
	dists_a := access(mj_a,BAT_WRITE);
#	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	dists_c := multiplex.+(dists_c,dists_d);
#	   dists_c := [+](dists_c,dists_d);
end	lj_a;
#	 |}
	nj_a := multiplex.:+=(dists_a,dists_c);
#	 [:+=](dists_a,dists_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_e in parallel
#      {
#	{|
barrier	oj_a:= true;
	pj_a := multiplex.+(dists_e,dists_f);
	dists_e := access(pj_a,BAT_WRITE);
#	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	dists_g := multiplex.+(dists_g,dists_h);
#	   dists_g := [+](dists_g,dists_h);
end	oj_a;
#	 |}
	qj_a := multiplex.:+=(dists_e,dists_g);
#	 [:+=](dists_e,dists_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	kj_a;
#       |}
	rj_a := multiplex.:+=(dists_a,dists_e);
#       [:+=](dists_a,dists_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	dists := dists_a;
#    dists := dists_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1315 "../../../src/gmm/gmm.mx"
#
	xs := nil;
#                  xs     := nil;
	diffs := nil;
#                  diffs  := nil;
	means := nil;
#		  means  := nil;
	ivars := nil;
#		  ivars  := nil;
	ivariances := nil;
#		  ivariances := nil;
	isdet:= join(cIdx,isqrtdet);
#  VAR isdet    := join( cIdx, isqrtdet );
	N:= take("N");
	act:= multiplex.multivariate_gaussian_pdf_diagcov(dists,isdet,N);
#  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
	dists := nil;
#                  dists  := nil;
	isdet := nil;
#                  isdet  := nil;
#
#
##line 1331 "../../../src/gmm/gmm.mx"
#
	sj_a := find(gmm,"Prior");
	tj_a := multiplex.dbl(sj_a);
	priors:= join(cIdx,tj_a);
#  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
	act := multiplex.*(act,priors);
#  act          := [*]( act, priors );
	uj_a := reverse(xIdx);
	vj_a := join(uj_a,act);
	s:= pump.sum(vj_a);
#  VAR s        := {sum}( xIdx.reverse.join(act) );
##  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
##  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
	wj_a := multiplex.>(s,MIN_S);
	xj_a := M2m.ifthen(wj_a,s,1.0LL);
	yj_a:= M2m.batconstruct1(xj_a);
	s := yj_a;
#  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
	ak_a := join(xIdx,s);
	post:= multiplex./(act,ak_a);
#  VAR post     := [/](act,xIdx.join(s));
	priors := nil;
#                  priors := nil;
	act := nil;
#                  act    := nil;
#
#
##line 1349 "../../../src/gmm/gmm.mx"
#
#  
##line 1353 "../../../src/gmm/gmm.mx"
	bk_a := multiplex.log(s);
	loglikelihood := multiplex.*(bk_a,-1);
#  loglikelihood := [*]([log](s), const -1);
	ck_a := join(Ib,loglikelihood);
	loglikelihood := pump.sum(ck_a);
#  loglikelihood := {sum}(join(Ib,loglikelihood));
	s := nil;
#                  s      := nil;
	dk_a := max(loglikelihood);
	ek_a := isnil(dk_a);
barrier	fk_a:= not(ek_a);
#  IF (not(isnil(loglikelihood.max)))
	gk_a := max(loglikelihood);
	hk_a := debug("Iter %d, maxLL %lf",iter,gk_a);
#    debug("Iter %d, maxLL %lf", iter, loglikelihood.max);
#  ELSE
end	fk_a;
barrier	ik_a:= not(fk_a);
	jk_a := debug("Iter %d",iter);
end	ik_a;
#    debug("Iter %d", iter);    
barrier	kk_a:= >(iter,1);
#  IF (iter>1) {
	lk_a := multiplex.-(loglikelihood,olde);
	deltall:= multiplex.abs(lk_a);
#    VAR deltall := [abs]([-](loglikelihood, olde));
##print( loglikelihood, olde, deltall );
	mk_a := multiplex.<(deltall,1.0LL);
	converged:= uselect(mk_a,1);
#    VAR converged := [<](deltall, const 1.0LL).uselect(true);
	nk_a_cursor := 0:lng;
barrier	nk_a:= batloop(nk_a_cursor,converged,nk_aH,nk_aT);
#    converged@batloop(){
	ok_a := "Image %3d converged to (local?) maximum of likelihood";
	pk_a := debug(ok_a,nk_aH);
#      debug("Image %3d converged to (local?) maximum of likelihood", $h);
redo	nk_a;
end	nk_a;
#    }
	qk_a := count(converged);
barrier	rk_a:= >(qk_a,0);
#    IF (converged.count > 0) {
	loglikelihood := kdiff(loglikelihood,converged);
#      loglikelihood := kdiff( loglikelihood, converged );
#      
##line 1386 "../../../src/gmm/gmm.mx"
	restgmm:= new(str,bat);
#  VAR restgmm := new(str,bat);
#
#  VAR fff;
#  {
	sk_a := find(gmmfinal,"mImgIdx");
	tk_a := count(sk_a);
	convNewId:= oid(tk_a);
#    VAR convNewId := oid(gmmfinal.find("mImgIdx").count);
	uk_a := mirror(converged);
	convIdx:= join(uk_a,mImgIdx);
#    VAR convIdx   := join(converged.mirror, mImgIdx);
#    
##line 611 "../../../src/gmm/gmm.mx"
#{
	vk_a := reverse(convIdx);
	wk_a := mark(vk_a,convNewId);
	fIdx:= reverse(wk_a);
#  VAR fIdx := convIdx.reverse.mark(convNewId).reverse;
#
	xk_a := find(gmm,"mImgIdx");
	yk_a := reverse(xk_a);
	convImgIdx:= join(fIdx,yk_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	al_a := find(gmm,"mCIdx");
	bl_a := reverse(al_a);
	convCIdx:= join(fIdx,bl_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	cl_a := find(gmmfinal,"mImgIdx");
	dl_a := info(cl_a);
	el_a := find(dl_a,"hkey");
	fl_a := debug("<PROPCHECK1 hkey=%s />",el_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	gl_a := reverse(convImgIdx);
	hl_a := find(gmmfinal,"mImgIdx");
	il_a := insert(hl_a,gl_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	jl_a := find(gmmfinal,"mImgIdx");
	kl_a := info(jl_a);
	ll_a := find(kl_a,"hkey");
	ml_a := debug("<PROPCHECK2 hkey=%s />",ll_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	nl_a := reverse(convCIdx);
	ol_a := find(gmmfinal,"mCIdx");
	pl_a := insert(ol_a,nl_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	ql_a := find(gmm,"Prior");
	rl_a := join(fIdx,ql_a);
	sl_a := find(gmmfinal,"Prior");
	tl_a := insert(sl_a,rl_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	ul_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	vl_a := find(gmm,"Mean");
	wl_a := multiplex.join(fIdx,vl_a);
	xl_a := multiplex.insert(ul_a,wl_a);
#            [join](const fIdx, gmm.find("Mean")) );
	yl_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	am_a := find(gmm,"Covar");
	bm_a := multiplex.join(fIdx,am_a);
	cm_a := multiplex.insert(yl_a,bm_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	dm_a := find(gmm,"init_variances");
	em_a := join(fIdx,dm_a);
	fm_a := find(gmmfinal,"init_variances");
	gm_a := insert(fm_a,em_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1392 "../../../src/gmm/gmm.mx"
#
#    
##line 1376 "../../../src/gmm/gmm.mx"
	hm_a := find(gmmfinal,"mImgIdx");
	im_a := kunique(hm_a);
	jm_a := count(im_a);
barrier	km_a:= =(jm_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	lm_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	km_a;
#      BREAK;
#    }
#
#
##line 1393 "../../../src/gmm/gmm.mx"
#
#
end	km_a;
	nconvIdx:= diff(mImgIdx,convIdx);
#    VAR nconvIdx  := diff(mImgIdx,convIdx);
#    
##line 634 "../../../src/gmm/gmm.mx"
	mm_a := oid(0);
	nm_a := reverse(nconvIdx);
	om_a := mark(nm_a,mm_a);
	fIdx:= reverse(om_a);
#VAR fIdx           := nconvIdx.reverse.mark(oid(0)).reverse;
#{
	pm_a := find(gmm,"mImgIdx");
	qm_a := reverse(pm_a);
	convImgIdx:= join(fIdx,qm_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	rm_a := find(gmm,"mCIdx");
	sm_a := reverse(rm_a);
	convCIdx:= join(fIdx,sm_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	tm_a := reverse(convImgIdx);
	um_a := insert(restgmm,"mImgIdx",tm_a);
#  restgmm.insert( "mImgIdx", convImgIdx.reverse );
	vm_a := reverse(convCIdx);
	wm_a := insert(restgmm,"mCIdx",vm_a);
#  restgmm.insert( "mCIdx",   convCIdx.reverse );
#
	xm_a := find(gmm,"Prior");
	ym_a := join(fIdx,xm_a);
	an_a := insert(restgmm,"Prior",ym_a);
#  restgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	bn_a := find(gmm,"Mean");
	cn_a := multiplex.join(fIdx,bn_a);
	dn_a := insert(restgmm,"Mean",cn_a);
#  restgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	en_a := find(gmm,"Covar");
	fn_a := multiplex.join(fIdx,en_a);
	gn_a := insert(restgmm,"Covar",fn_a);
#  restgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	hn_a := find(gmm,"init_variances");
	in_a := join(fIdx,hn_a);
	jn_a := insert(restgmm,"init_variances",in_a);
#  restgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1396 "../../../src/gmm/gmm.mx"
#
#
	fff := fIdx;
#    fff := fIdx;
#  }
	kn_a := str(iter);
	ln_a := +(kn_a,"_rest");
	mn_a := +("_",ln_a);
	nn_a := +(sessionId,mn_a);
	on_a := +("gmm",nn_a);
	pn_a := renameGMM(restgmm,on_a);
#  renameGMM(restgmm,"gmm" + sessionId + "_" + str(iter) + "_rest");
#  
##line 655 "../../../src/gmm/gmm.mx"
	qn_a := find(restgmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	rn_a := access(qn_a,BAT_READ);
#  access( restgmm.find("init_variances"), BAT_READ );
	sn_a := find(restgmm,"Prior");
	tn_a := access(sn_a,BAT_READ);
#  access( restgmm.find("Prior"), BAT_READ );
	un_a := find(restgmm,"mImgIdx");
	vn_a := access(un_a,BAT_READ);
#  access( restgmm.find("mImgIdx"), BAT_READ );
	wn_a := find(restgmm,"mCIdx");
	xn_a := access(wn_a,BAT_READ);
#  access( restgmm.find("mCIdx"), BAT_READ );
	yn_a := find(restgmm,"Mean");
	ao_a_cursor := 0:lng;
barrier	ao_a:= batloop(ao_a_cursor,yn_a,ao_aH,ao_aT);
	bo_a := access(ao_aT,BAT_READ);
redo	ao_a;
end	ao_a;
#  restgmm.find("Mean")@batloop{  access($t, BAT_READ); }
	co_a := find(restgmm,"Covar");
	do_a_cursor := 0:lng;
barrier	do_a:= batloop(do_a_cursor,co_a,do_aH,do_aT);
	eo_a := access(do_aT,BAT_READ);
redo	do_a;
end	do_a;
#  restgmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1401 "../../../src/gmm/gmm.mx"
#
	gmm := restgmm;
#  gmm         := restgmm;
	restgmm := nil;
#  restgmm     := nil;
#
	Ib := kdiff(Ib,converged);
#  Ib          := kdiff(Ib, converged);
	iIdx:= nx(Ib);
#  VAR iIdx    := nx(Ib); # <new oid, old oid>
	Ib := xn(Ib);
#  Ib          := xn(Ib);
#
	oldc:= coeffs;
#  VAR oldc    := coeffs; # UGLY: nestedjoin macro makes new variable
#  
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	fo_a := htype(oldc);
	go_a := count(oldc);
	coeffs := new(fo_a,bat,go_a);
#  coeffs := new(oldc.htype,bat,oldc.count);
	coeffs_lock:= lock_create();
#  VAR coeffs_lock := lock_create();
	ho_a_cursor := 0:lng;
barrier	ho_a:= batloop(ho_a_cursor,Nthreads,ho_aH,ho_aT);
#  oldc@ [Nthreads]batloop(){
	_coeffs_result:= join(iIdx,ho_aT);
#    VAR _coeffs_result := join( iIdx, $t );
	io_a := lock_set(coeffs_lock);
#    lock_set(coeffs_lock);
	jo_a := insert(coeffs,ho_aH,_coeffs_result);
#    coeffs.insert( $h, _coeffs_result );
	ko_a := lock_unset(coeffs_lock);
#    lock_unset(coeffs_lock);
redo	ho_a;
end	ho_a;
#  }
	lo_a := lock_destroy(coeffs_lock);
#  lock_destroy(coeffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1410 "../../../src/gmm/gmm.mx"
#
	oldc := nil;
#                  oldc    := nil;
#
	mo_a := reverse(iIdx);
	xIdx := join(xIdx,mo_a);
#  xIdx        := join(xIdx, iIdx.reverse);
	no_a := xn(xIdx);
	newxIdx:= reverse(no_a);
#  VAR newxIdx := xn(xIdx).reverse;
	xIdx := nx(xIdx);
#  xIdx        := nx(xIdx);
	post := join(newxIdx,post);
#  post        := join(newxIdx, post);
	cIdx := join(newxIdx,cIdx);
#  cIdx        := join(newxIdx, cIdx);
	oo_a := reverse(fff);
	cIdx := join(cIdx,oo_a);
#  cIdx        := join( cIdx, fff.reverse ); # renumber for mCIdx/mImgIdx
	newxIdx := nil;
#                  newxIdx := nil;             
	fff := nil;
#                  fff     := nil;             
#
	mImgIdx := find(gmm,"mImgIdx");
#  mImgIdx     := gmm.find("mImgIdx");
	mCIdx := find(gmm,"mCIdx");
#  mCIdx       := gmm.find("mCIdx");
#
#
##line 1369 "../../../src/gmm/gmm.mx"
#
#    }
#    
##line 1376 "../../../src/gmm/gmm.mx"
end	rk_a;
	po_a := find(gmmfinal,"mImgIdx");
	qo_a := kunique(po_a);
	ro_a := count(qo_a);
barrier	so_a:= =(ro_a,NImg);
#    IF ( gmmfinal.find("mImgIdx").kunique.count = NImg ) {
	to_a := debug("All images converged; break...");
#      debug("All images converged; break...");
leave	so_a;
#      BREAK;
#    }
#
#
##line 1371 "../../../src/gmm/gmm.mx"
#
end	so_a;
#  }
end	kk_a;
	olde := loglikelihood;
#  olde := loglikelihood;
#
#
##line 1350 "../../../src/gmm/gmm.mx"
#
#
#
##line 1499 "../../../src/gmm/gmm.mx"
#
#      
##line 1432 "../../../src/gmm/gmm.mx"
	uo_a := reverse(cIdx);
	vo_a := join(uo_a,post);
	newpr:= pump.sum(vo_a);
#   VAR newpr     := {sum}( cIdx.reverse.join(post) );
	newpr := multiplex.flt(newpr);
#                  newpr := [flt]( newpr );
#   VAR newpriors := [/]( newpr,
	wo_a := reverse(Ib);
	xo_a := histogram(wo_a);
	yo_a := reverse(mImgIdx);
	ap_a := join(yo_a,xo_a);
	newpriors:= multiplex./(newpr,ap_a);
#                         mImgIdx.reverse.join( Ib.reverse.histogram ) );
#debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",
	bp_a := reverse(cIdx);
	cp_a := join(bp_a,post);
	dp_a := count(cp_a);
#  cIdx.reverse.join(post).count,
	ep_a := count(newpr);
#  newpr.count,
	fp_a := count(newpriors);
#  newpriors.count,
	gp_a := reverse(Ib);
#  Ib.reverse.histogram.count
	hp_a := histogram(gp_a);
	ip_a := count(hp_a);
	jp_a := debug("NP: #post %d, #newpr %d, #newpriors %d, #Ndata %d",dp_a,ep_a,fp_a,ip_a);
#);
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	kp_a := htype(coeffs);
	lp_a := count(coeffs);
	xs := new(kp_a,bat,lp_a);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
	mp_a_cursor := 0:lng;
barrier	mp_a:= batloop(mp_a_cursor,Nthreads,mp_aH,mp_aT);
#  coeffs@ [Nthreads]batloop(){
	_xs_result:= join(xIdx,mp_aT);
#    VAR _xs_result := join( xIdx, $t );
	np_a := lock_set(xs_lock);
#    lock_set(xs_lock);
	op_a := insert(xs,mp_aH,_xs_result);
#    xs.insert( $h, _xs_result );
	pp_a := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	mp_a;
end	mp_a;
#  }
	qp_a := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1443 "../../../src/gmm/gmm.mx"
#
	xhc:= multiplex.nestedop("*",xs,post);
#   VAR xhc       := [nestedop]( "*", xs, const post );
	xhc := multiplex.nestedop("flt",xhc);
#                  xhc := [nestedop]("flt", xhc);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR gxhc;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	rp_a := htype(xhc);
	sp_a := count(xhc);
	gxhc := new(rp_a,bat,sp_a);
#  gxhc := new(xhc.htype,bat,xhc.count);
	gxhc_lock:= lock_create();
#  VAR gxhc_lock := lock_create();
	tp_a_cursor := 0:lng;
barrier	tp_a:= batloop(tp_a_cursor,Nthreads,tp_aH,tp_aT);
#  xhc@ [Nthreads]batloop(){
	up_a := reverse(cIdx);
	_gxhc_result:= join(up_a,tp_aT);
#    VAR _gxhc_result := join( cIdx.reverse, $t );
	vp_a := lock_set(gxhc_lock);
#    lock_set(gxhc_lock);
	wp_a := insert(gxhc,tp_aH,_gxhc_result);
#    gxhc.insert( $h, _gxhc_result );
	xp_a := lock_unset(gxhc_lock);
#    lock_unset(gxhc_lock);
redo	tp_a;
end	tp_a;
#  }
	yp_a := lock_destroy(gxhc_lock);
#  lock_destroy(gxhc_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1446 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	aq_a := htype(gxhc);
	bq_a := count(gxhc);
	newc:= new(aq_a,bat,bq_a);
#  VAR newc := new(gxhc.htype,bat,gxhc.count);
#  {
	newc_lock:= lock_create();
#    VAR newc_lock := lock_create();
	cq_a_cursor := 0:lng;
barrier	cq_a:= batloop(cq_a_cursor,Nthreads,cq_aH,cq_aT);
#    gxhc@ [Nthreads]batloop(){
#      VAR _newc_result := {sum}($t
	_newc_result:= pump.sum(cq_aT);
#	   );
	dq_a := lock_set(newc_lock);
#      lock_set(newc_lock);
	eq_a := insert(newc,cq_aH,_newc_result);
#      newc.insert($h,_newc_result);
	fq_a := lock_unset(newc_lock);
#      lock_unset(newc_lock);
redo	cq_a;
end	cq_a;
#    }
	gq_a := lock_destroy(newc_lock);
#    lock_destroy(newc_lock);
#  }
#
#
##line 1447 "../../../src/gmm/gmm.mx"
#
	gxhc := nil;
#                  gxhc    := nil;
	xhc := nil;
#                  xhc     := nil;
	newmeans:= multiplex.nestedop("/",newc,newpr);
#   VAR newmeans  := [nestedop]("/", newc, const newpr);
	newc := nil;
#                  newc    := nil;
#
#   
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	hq_a := htype(newmeans);
	iq_a := count(newmeans);
	means := new(hq_a,bat,iq_a);
#  means := new(newmeans.htype,bat,newmeans.count);
	means_lock:= lock_create();
#  VAR means_lock := lock_create();
	jq_a_cursor := 0:lng;
barrier	jq_a:= batloop(jq_a_cursor,Nthreads,jq_aH,jq_aT);
#  newmeans@ [Nthreads]batloop(){
	_means_result:= join(cIdx,jq_aT);
#    VAR _means_result := join( cIdx, $t );
	kq_a := lock_set(means_lock);
#    lock_set(means_lock);
	lq_a := insert(means,jq_aH,_means_result);
#    means.insert( $h, _means_result );
	mq_a := lock_unset(means_lock);
#    lock_unset(means_lock);
redo	jq_a;
end	jq_a;
#  }
	nq_a := lock_destroy(means_lock);
#  lock_destroy(means_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1453 "../../../src/gmm/gmm.mx"
#
	hdiffs:= multiplex.nestedop("-",xs,means);
#   VAR hdiffs    := [nestedop]("-",xs,means);
	xs := nil;
#                  xs      := nil;
	means := nil;
#                  means   := nil;
	hdiffs := multiplex.square(hdiffs);
#   hdiffs        := [square](hdiffs);
	hdiffs := multiplex.nestedop("*",hdiffs,post);
#   hdiffs	 := [nestedop]("*",hdiffs,const post);
	hdiffs := multiplex.nestedop("flt",hdiffs);
#                  hdiffs := [nestedop]("flt", hdiffs);
#   
##line 1227 "../../../src/gmm/gmm.mx"
#VAR ghdiffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	oq_a := htype(hdiffs);
	pq_a := count(hdiffs);
	ghdiffs := new(oq_a,bat,pq_a);
#  ghdiffs := new(hdiffs.htype,bat,hdiffs.count);
	ghdiffs_lock:= lock_create();
#  VAR ghdiffs_lock := lock_create();
	qq_a_cursor := 0:lng;
barrier	qq_a:= batloop(qq_a_cursor,Nthreads,qq_aH,qq_aT);
#  hdiffs@ [Nthreads]batloop(){
	rq_a := reverse(cIdx);
	_ghdiffs_result:= join(rq_a,qq_aT);
#    VAR _ghdiffs_result := join( cIdx.reverse, $t );
	sq_a := lock_set(ghdiffs_lock);
#    lock_set(ghdiffs_lock);
	tq_a := insert(ghdiffs,qq_aH,_ghdiffs_result);
#    ghdiffs.insert( $h, _ghdiffs_result );
	uq_a := lock_unset(ghdiffs_lock);
#    lock_unset(ghdiffs_lock);
redo	qq_a;
end	qq_a;
#  }
	vq_a := lock_destroy(ghdiffs_lock);
#  lock_destroy(ghdiffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1460 "../../../src/gmm/gmm.mx"
#
#   
##line 107 "../../../src/gmm/gmm.mx"
	wq_a := htype(ghdiffs);
	xq_a := count(ghdiffs);
	diffs:= new(wq_a,bat,xq_a);
#  VAR diffs := new(ghdiffs.htype,bat,ghdiffs.count);
#  {
	diffs_lock:= lock_create();
#    VAR diffs_lock := lock_create();
	yq_a_cursor := 0:lng;
barrier	yq_a:= batloop(yq_a_cursor,Nthreads,yq_aH,yq_aT);
#    ghdiffs@ [Nthreads]batloop(){
#      VAR _diffs_result := {sum}($t
	_diffs_result:= pump.sum(yq_aT);
#	   );
	ar_a := lock_set(diffs_lock);
#      lock_set(diffs_lock);
	br_a := insert(diffs,yq_aH,_diffs_result);
#      diffs.insert($h,_diffs_result);
	cr_a := lock_unset(diffs_lock);
#      lock_unset(diffs_lock);
redo	yq_a;
end	yq_a;
#    }
	dr_a := lock_destroy(diffs_lock);
#    lock_destroy(diffs_lock);
#  }
#
#
##line 1461 "../../../src/gmm/gmm.mx"
#
	ghdiffs := nil;
#                  ghdiffs := nil;
	hdiffs := nil;
#                  hdiffs  := nil;
	newvars:= multiplex.nestedop("/",diffs,newpr);
#   VAR newvars   := [nestedop]("/",diffs,const newpr);
	diffs := nil;
#                  diffs   := nil;
#
#
##line 1500 "../../../src/gmm/gmm.mx"
#
#      
##line 1471 "../../../src/gmm/gmm.mx"
#   
##line 130 "../../../src/gmm/gmm.mx"
#VAR minvars;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	minvars_a:= fetch(newvars,0);
	minvars_e:= fetch(newvars,4);
#    VAR minvars_a := newvars.fetch(0);    VAR minvars_e := newvars.fetch(4);
	minvars_b:= fetch(newvars,1);
	minvars_f:= fetch(newvars,5);
#    VAR minvars_b := newvars.fetch(1);    VAR minvars_f := newvars.fetch(5);
	minvars_c:= fetch(newvars,2);
	minvars_g:= fetch(newvars,6);
#    VAR minvars_c := newvars.fetch(2);    VAR minvars_g := newvars.fetch(6);
	minvars_d:= fetch(newvars,3);
	minvars_h:= fetch(newvars,7);
#    VAR minvars_d := newvars.fetch(3);    VAR minvars_h := newvars.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations minvars_a in parallel
#    {
#      {|
barrier	er_a:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_a in parallel
#      {
#	{|
barrier	fr_a:= true;
	gr_a := multiplex.min(minvars_a,minvars_b);
	minvars_a := access(gr_a,BAT_WRITE);
#	   minvars_a := [min](minvars_a,minvars_b).access(BAT_WRITE);
	minvars_c := multiplex.min(minvars_c,minvars_d);
#	   minvars_c := [min](minvars_c,minvars_d);
end	fr_a;
#	 |}
	hr_a := multiplex.:min=(minvars_a,minvars_c);
#	 [:min=](minvars_a,minvars_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations minvars_e in parallel
#      {
#	{|
barrier	ir_a:= true;
	jr_a := multiplex.min(minvars_e,minvars_f);
	minvars_e := access(jr_a,BAT_WRITE);
#	   minvars_e := [min](minvars_e,minvars_f).access(BAT_WRITE);
	minvars_g := multiplex.min(minvars_g,minvars_h);
#	   minvars_g := [min](minvars_g,minvars_h);
end	ir_a;
#	 |}
	kr_a := multiplex.:min=(minvars_e,minvars_g);
#	 [:min=](minvars_e,minvars_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	er_a;
#       |}
	lr_a := multiplex.:min=(minvars_a,minvars_e);
#       [:min=](minvars_a,minvars_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	minvars := minvars_a;
#    minvars := minvars_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1471 "../../../src/gmm/gmm.mx"
#
	covarsmall:= multiplex.<(minvars,MIN_COVAR);
#   VAR covarsmall    := [<](minvars,const MIN_COVAR);
	covarnil:= multiplex.isnil(minvars);
#   VAR covarnil      := [isnil](minvars);
	mr_a := multiplex.or(covarsmall,covarnil);
	covarnotsmall:= multiplex.not(mr_a);
#   VAR covarnotsmall := [not]([or](covarsmall,covarnil));
	covarsmall := nil;
#                  covarsmall := nil;
	covarnil := nil;
#                  covarnil   := nil;
	nr_a := select(covarnotsmall,0);
	Ntoosmall:= count(nr_a);
#   VAR Ntoosmall     := select(covarnotsmall,false).count;
barrier	or_a:= >(Ntoosmall,0);
#   IF ( Ntoosmall > 0 ) {
	pr_a := "Covariance too small in %d model(s)";
	qr_a := debug(pr_a,Ntoosmall);
#     debug("Covariance too small in %d model(s)", Ntoosmall);
	init_variances:= find(gmm,"init_variances");
#     VAR init_variances := gmm.find("init_variances");
	rr_a := htype(newvars);
	sr_a := count(newvars);
	ccovars:= new(rr_a,bat,sr_a);
#     VAR ccovars   := new( newvars.htype, bat, newvars.count );
	tr_a_cursor := 0:lng;
barrier	tr_a:= batloop(tr_a_cursor,newvars,tr_aH,tr_aT);
#     newvars@batloop(){
	ur_a := M2m.ifthen(covarnotsmall,tr_aT,init_variances);
	vr_a:= M2m.batconstruct1(ur_a);
	cv:= vr_a;
#       VAR cv := [ covarnotsmall ? $t : init_variances ];
	wr_a := insert(ccovars,tr_aH,cv);
#       ccovars.insert($h, cv);
redo	tr_a;
end	tr_a;
#     }
	newvars := ccovars;
#     newvars := ccovars;
#   }
#
#
##line 1501 "../../../src/gmm/gmm.mx"
#
end	or_a;
	xr_a := :+=(iter,1);
#      iter :+= 1;
#
	gmmnew:= new(str,bat);
#      VAR gmmnew := new(str,bat);
	yr_a := insert(gmmnew,"Prior",newpriors);
#      gmmnew.insert( "Prior",  newpriors );
	as_a := insert(gmmnew,"Mean",newmeans);
#      gmmnew.insert( "Mean",   newmeans );
	bs_a := insert(gmmnew,"Covar",newvars);
#      gmmnew.insert( "Covar",  newvars );
#
	cs_a := insert(gmmnew,"mImgIdx",mImgIdx);
#      gmmnew.insert("mImgIdx", mImgIdx );
	ds_a := insert(gmmnew,"mCIdx",mCIdx);
#      gmmnew.insert("mCIdx",   mCIdx );
	es_a := find(gmm,"init_variances");
	fs_a := insert(gmmnew,"init_variances",es_a);
#      gmmnew.insert("init_variances", gmm.find("init_variances") );
#      
##line 655 "../../../src/gmm/gmm.mx"
	gs_a := find(gmmnew,"init_variances");
	hs_a := access(gs_a,BAT_READ);
#  access( gmmnew.find("init_variances"), BAT_READ );
	is_a := find(gmmnew,"Prior");
	js_a := access(is_a,BAT_READ);
#  access( gmmnew.find("Prior"), BAT_READ );
	ks_a := find(gmmnew,"mImgIdx");
	ls_a := access(ks_a,BAT_READ);
#  access( gmmnew.find("mImgIdx"), BAT_READ );
	ms_a := find(gmmnew,"mCIdx");
	ns_a := access(ms_a,BAT_READ);
#  access( gmmnew.find("mCIdx"), BAT_READ );
	os_a := find(gmmnew,"Mean");
	ps_a_cursor := 0:lng;
barrier	ps_a:= batloop(ps_a_cursor,os_a,ps_aH,ps_aT);
	qs_a := access(ps_aT,BAT_READ);
redo	ps_a;
end	ps_a;
#  gmmnew.find("Mean")@batloop{  access($t, BAT_READ); }
	rs_a := find(gmmnew,"Covar");
	ss_a_cursor := 0:lng;
barrier	ss_a:= batloop(ss_a_cursor,rs_a,ss_aH,ss_aT);
	ts_a := access(ss_aT,BAT_READ);
redo	ss_a;
end	ss_a;
#  gmmnew.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1512 "../../../src/gmm/gmm.mx"
#
	us_a := str(iter);
	vs_a := +("_",us_a);
	ws_a := +(sessionId,vs_a);
	xs_a := +("gmm",ws_a);
	ys_a := renameGMM(gmmnew,xs_a);
#      gmmnew.renameGMM("gmm" + sessionId + "_" + str(iter));
#
	gmm := gmmnew;
#      gmm := gmmnew;
#
barrier	at_a:= =(iter,2);
#      IF (iter = 2) {
#        # free memory for globals
	EM_coll := nil;
#        EM_coll  := nil;
	EM_model := nil;
#        EM_model := nil;
#      }
end	at_a;
redo	ji_a;
end	ki_a;
end	ji_a;
#    }
barrier	bt_a:= =(iter,Niter);
#    IF (iter = Niter) {
	ct_a := debug("Not all images have converged");
#      debug("Not all images have converged");
	dt_a := find(gmmfinal,"mImgIdx");
	et_a := count(dt_a);
	lastId:= oid(et_a);
#      VAR lastId       := oid(gmmfinal.find("mImgIdx").count);
	remainingIdx:= find(gmm,"mImgIdx");
#      VAR remainingIdx := gmm.find("mImgIdx");
#      
##line 611 "../../../src/gmm/gmm.mx"
#{
	ft_a := reverse(remainingIdx);
	gt_a := mark(ft_a,lastId);
	fIdx:= reverse(gt_a);
#  VAR fIdx := remainingIdx.reverse.mark(lastId).reverse;
#
	ht_a := find(gmm,"mImgIdx");
	it_a := reverse(ht_a);
	convImgIdx:= join(fIdx,it_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	jt_a := find(gmm,"mCIdx");
	kt_a := reverse(jt_a);
	convCIdx:= join(fIdx,kt_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	lt_a := find(gmmfinal,"mImgIdx");
	mt_a := info(lt_a);
	nt_a := find(mt_a,"hkey");
	ot_a := debug("<PROPCHECK1 hkey=%s />",nt_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	pt_a := reverse(convImgIdx);
	qt_a := find(gmmfinal,"mImgIdx");
	rt_a := insert(qt_a,pt_a);
#  gmmfinal.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	st_a := find(gmmfinal,"mImgIdx");
	tt_a := info(st_a);
	ut_a := find(tt_a,"hkey");
	vt_a := debug("<PROPCHECK2 hkey=%s />",ut_a);
#          gmmfinal.find("mImgIdx").info.find("hkey"));
	wt_a := reverse(convCIdx);
	xt_a := find(gmmfinal,"mCIdx");
	yt_a := insert(xt_a,wt_a);
#  gmmfinal.find("mCIdx").insert( convCIdx.reverse );
#
	au_a := find(gmm,"Prior");
	bu_a := join(fIdx,au_a);
	cu_a := find(gmmfinal,"Prior");
	du_a := insert(cu_a,bu_a);
#  gmmfinal.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	eu_a := find(gmmfinal,"Mean");
#  [insert]( gmmfinal.find("Mean"),
	fu_a := find(gmm,"Mean");
	gu_a := multiplex.join(fIdx,fu_a);
	hu_a := multiplex.insert(eu_a,gu_a);
#            [join](const fIdx, gmm.find("Mean")) );
	iu_a := find(gmmfinal,"Covar");
#  [insert]( gmmfinal.find("Covar"),
	ju_a := find(gmm,"Covar");
	ku_a := multiplex.join(fIdx,ju_a);
	lu_a := multiplex.insert(iu_a,ku_a);
#            [join](const fIdx, gmm.find("Covar")) );
#
	mu_a := find(gmm,"init_variances");
	nu_a := join(fIdx,mu_a);
	ou_a := find(gmmfinal,"init_variances");
	pu_a := insert(ou_a,nu_a);
#  gmmfinal.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1527 "../../../src/gmm/gmm.mx"
#
#    }
#      # @@modelop(gmmfinal,persists,false)@
end	bt_a;
	return gmmfinal;
#    RETURN gmmfinal;
end function;
#  }
#
#    # PROC EM(bat[str,bat] EM_coll, bat[str,bat] EM_model):bat[str,bat]
function EM_globalmodel():bat[str,bat];
#  PROC EM_globalmodel():bat[str,bat] := {
	Niter:= take("Niter");
	qu_a := EM_globalmodel(Niter);
	return qu_a;
#    RETURN EM_globalmodel(Niter);
end function;
#  }
#
#
#
##line 1557 "../../../src/gmm/gmm.mx"
	Nsamples := 100;
#  CONST Nsamples := 100;
	mu_1 := 5.0LL;
	sigma_1 := 2.0LL;
#  CONST mu_1 := 5.0LL; CONST sigma_1 := 2.0LL;
	mu_2 := 7.0LL;
	sigma_2 := 3.0LL;
#  CONST mu_2 := 7.0LL; CONST sigma_2 := 3.0LL;
#
function mix2g():dbl;
#  PROC mix2g(): dbl := {
	rand:= take("rand");
	ru_a := and(rand,15);
barrier	su_a:= >(ru_a,10);
#    IF ( (rand and 15) > 10 ) 
	tu_a := ran_gaussian(mu_1,sigma_1);
	return tu_a;
#      RETURN ran_gaussian(mu_1,sigma_1);
end	su_a;
barrier	uu_a:= not(su_a);
	vu_a := ran_gaussian(mu_2,sigma_2);
	return vu_a;
end	uu_a;
#    ELSE RETURN ran_gaussian(mu_2,sigma_2);
end function;
#  }
#
function gen2mix(Nel:int):bat[void,dbl];
#  PROC gen2mix(int Nel):BAT[void,dbl] := {
	wu_a := oid(0);
	xu_a := new(void,dbl);
	res:= setSequenceBase(xu_a,wu_a);
#    VAR res := new(void,dbl).setSequenceBase(oid(0));
	i:= 0;
#    VAR i := 0;
barrier	yu_a:= true;
	bv_a := <(i,Nel);
barrier	av_a:= bv_a;
#    WHILE (i < Nel) {
	cv_a := mix2g();
	dv_a := insert(res,nil,cv_a);
#      res.insert(nil, mix2g());
	ev_a := :+=(i,1);
#      i :+=1; 
redo	yu_a;
end	av_a;
end	yu_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#
##line 1591 "../../../src/gmm/gmm.mx"
function cumsum_multiplex(xs:bat[any::1,any]):bat[any::1,lng];
#  PROC [cumsum](BAT[any::1,any] xs): BAT[any::1,lng] := {
	fv_a := htype(xs);
	gv_a := count(xs);
	res:= new(fv_a,lng,gv_a);
#    VAR res := new(xs.htype,lng,xs.count);
	s:= lng(0);
#    VAR s := lng(0);
	hv_a_cursor := 0:lng;
barrier	hv_a:= batloop(hv_a_cursor,xs,hv_aH,hv_aT);
#    xs@batloop(){
	iv_a := :+=(s,hv_aT);
#      s :+= $t;
	jv_a := insert(res,hv_aH,s);
#      res.insert( $h, s );
redo	hv_a;
end	hv_a;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[int,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[int,flt] prior): bat[void,any::1] := {
	kv_a := htype(prior);
	res:= new(oid,kv_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	lv_a := randseq(Nsamples);
	samp:= multiplex.lng(lv_a);
#    VAR samp := [lng](randseq(Nsamples));
	mv_a := multiplex.*(prior,RAND_MAX);
	nv_a := multiplex.int(mv_a);
	ov_a := multiplex.cumsum(nv_a);
	cint:= reverse(ov_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	pv_a_cursor := 0:lng;
barrier	pv_a:= batloop(pv_a_cursor,cint,pv_aH,pv_aT);
#    cint@batloop(){
	ie:= pv_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	qv_a := multiplex.>(samp,ib);
	rv_a := multiplex.<=(samp,ie);
	sv_a := multiplex.and(qv_a,rv_a);
	tv_a := uselect(sv_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	uv_a := project(tv_a,pv_aT);
	vv_a := insert(res,uv_a);
#      );
	ib := ie;
#      ib := ie;
redo	pv_a;
end	pv_a;
#    }
	wv_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	xv_a := nx(res);
	yv_a := access(xv_a,BAT_READ);
	return yv_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1601 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[TCluster,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[TCluster,flt] prior): bat[void,any::1] := {
	aw_a := htype(prior);
	res:= new(oid,aw_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	bw_a := randseq(Nsamples);
	samp:= multiplex.lng(bw_a);
#    VAR samp := [lng](randseq(Nsamples));
	cw_a := multiplex.*(prior,RAND_MAX);
	dw_a := multiplex.int(cw_a);
	ew_a := multiplex.cumsum(dw_a);
	cint:= reverse(ew_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	fw_a_cursor := 0:lng;
barrier	fw_a:= batloop(fw_a_cursor,cint,fw_aH,fw_aT);
#    cint@batloop(){
	ie:= fw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	gw_a := multiplex.>(samp,ib);
	hw_a := multiplex.<=(samp,ie);
	iw_a := multiplex.and(gw_a,hw_a);
	jw_a := uselect(iw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	kw_a := project(jw_a,fw_aT);
	lw_a := insert(res,kw_a);
#      );
	ib := ie;
#      ib := ie;
redo	fw_a;
end	fw_a;
#    }
	mw_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	nw_a := nx(res);
	ow_a := access(nw_a,BAT_READ);
	return ow_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1602 "../../../src/gmm/gmm.mx"
#
#  
##line 1605 "../../../src/gmm/gmm.mx"
function randseq(Nsamples:int, prior:bat[void,flt]):bat[void,any::1];
#  PROC randseq(int Nsamples, bat[void,flt] prior): bat[void,any::1] := {
	pw_a := htype(prior);
	res:= new(oid,pw_a,Nsamples);
#    VAR res := new(oid, prior.htype,Nsamples);
	qw_a := randseq(Nsamples);
	samp:= multiplex.lng(qw_a);
#    VAR samp := [lng](randseq(Nsamples));
	rw_a := multiplex.*(prior,RAND_MAX);
	sw_a := multiplex.int(rw_a);
	tw_a := multiplex.cumsum(sw_a);
	cint:= reverse(tw_a);
#    VAR cint := [cumsum]( [int]([*](prior, const RAND_MAX)) ).reverse;
	ib:= lng(0);
#    VAR ib := lng(0);
	uw_a_cursor := 0:lng;
barrier	uw_a:= batloop(uw_a_cursor,cint,uw_aH,uw_aT);
#    cint@batloop(){
	ie:= uw_aH;
#      VAR ie := $h;
#      # a poor man's interval-join
#      res.insert(
	vw_a := multiplex.>(samp,ib);
	ww_a := multiplex.<=(samp,ie);
	xw_a := multiplex.and(vw_a,ww_a);
	yw_a := uselect(xw_a,1);
#	[and]( [>](samp,ib), [<=](samp,ie) ).uselect(true).project($t) 
	ax_a := project(yw_a,uw_aT);
	bx_a := insert(res,ax_a);
#      );
	ib := ie;
#      ib := ie;
redo	uw_a;
end	uw_a;
#    }
	cx_a := order(res);
#    res.order;
	BAT_READ:= take("BAT_READ");
	dx_a := nx(res);
	ex_a := access(dx_a,BAT_READ);
	return ex_a;
#    RETURN nx(res).access(BAT_READ);
end function;
#  }
#
#
##line 1603 "../../../src/gmm/gmm.mx"
#
#
#
##line 1623 "../../../src/gmm/gmm.mx"
function gmmsamp_diag(Nsamples:int, gmm:bat[str,bat]):bat[str,bat];
#  PROC gmmsamp_diag( int Nsamples, bat[str,bat] gmm ): bat[str,bat] := {
	res:= new(str,bat,2);
#    VAR res := new(str,bat,2);
	N:= take("N");
	samples:= new(int,bat,N);
#    VAR samples := new(int,bat,N);
	nseq:= take("nseq");
	fx_a_cursor := 0:lng;
barrier	fx_a:= batloop(fx_a_cursor,nseq,fx_aH,fx_aT);
	gx_a := oid(0);
	hx_a := new(void,dbl,Nsamples);
	ix_a := setSequenceBase(hx_a,gx_a);
	jx_a := insert(samples,fx_aT,ix_a);
redo	fx_a;
end	fx_a;
#    nseq@batloop{ samples.insert($t,new(void,dbl,Nsamples).setSequenceBase(oid(0))); }
	BAT_READ:= take("BAT_READ");
	kx_a := access(samples,BAT_READ);
#    samples.access(BAT_READ);
#    # do it...
	mean:= find(gmm,"Mean");
#    VAR mean := gmm.find("Mean");
	covar:= find(gmm,"Covar");
#    VAR covar := gmm.find("Covar");
#    
##line 107 "../../../src/gmm/gmm.mx"
	lx_a := htype(covar);
	mx_a := count(covar);
	sigma:= new(lx_a,bat,mx_a);
#  VAR sigma := new(covar.htype,bat,covar.count);
#  {
	sigma_lock:= lock_create();
#    VAR sigma_lock := lock_create();
	Nthreads:= take("Nthreads");
	nx_a_cursor := 0:lng;
barrier	nx_a:= batloop(nx_a_cursor,Nthreads,nx_aH,nx_aT);
#    covar@ [Nthreads]batloop(){
#      VAR _sigma_result := [sqrt]($t
	_sigma_result:= multiplex.sqrt(nx_aT);
#	   );
	ox_a := lock_set(sigma_lock);
#      lock_set(sigma_lock);
	px_a := insert(sigma,nx_aH,_sigma_result);
#      sigma.insert($h,_sigma_result);
	qx_a := lock_unset(sigma_lock);
#      lock_unset(sigma_lock);
redo	nx_a;
end	nx_a;
#    }
	rx_a := lock_destroy(sigma_lock);
#    lock_destroy(sigma_lock);
#  }
#
#
##line 1631 "../../../src/gmm/gmm.mx"
#
#
	cseq:= take("cseq");
	sx_a := find(gmm,"Prior");
	tx_a := reverse(cseq);
	ux_a := join(tx_a,sx_a);
	clusters:= randseq(Nsamples,ux_a);
#    VAR clusters := randseq(Nsamples, cseq.reverse.join(gmm.find("Prior")));
	vx_a_cursor := 0:lng;
barrier	vx_a:= batloop(vx_a_cursor,clusters,vx_aH,vx_aT);
#    clusters@batloop(){
	wx_a := reverse(cseq);
	c:= find(wx_a,vx_aT);
#      VAR c := cseq.reverse.find($t);
#      [insert]( samples, const $h,
	xx_a := multiplex.find(mean,c);
	yx_a := multiplex.find(sigma,c);
	ay_a := multiplex.ran_gaussian(xx_a,yx_a);
	by_a := multiplex.insert(samples,vx_aH,ay_a);
#	[ran_gaussian]( [find](mean,c), [find](sigma,c) ) );
redo	vx_a;
end	vx_a;
#    }
	cy_a := multiplex.access(samples,BAT_READ);
#    [access](samples,BAT_READ);
#    # return structure
	dy_a := insert(res,"Samples",samples);
#    res.insert( "Samples", samples );
	ey_a := insert(res,"Clusters",clusters);
#    res.insert( "Clusters", clusters );
	return res;
#    RETURN res;
end function;
#  }
function gmmsamp_diag(Nsamples:int, theImg:oid, gmm:bat[str,bat]):bat[str,bat];
#  PROC gmmsamp_diag( int Nsamples, oid theImg, bat[str,bat] gmm ): bat[str,bat] := {
	fy_a := find(gmm,"mImgIdx");
	gy_a := reverse(fy_a);
	hy_a := uselect(gy_a,theImg);
	selIdx:= mirror(hy_a);
#    VAR selIdx := gmm.find("mImgIdx").reverse.uselect(theImg).mirror;
	subgmm:= new(str,bat);
#    VAR subgmm := new(str,bat);
#    
##line 634 "../../../src/gmm/gmm.mx"
	iy_a := oid(0);
	jy_a := reverse(selIdx);
	ky_a := mark(jy_a,iy_a);
	fIdx:= reverse(ky_a);
#VAR fIdx           := selIdx.reverse.mark(oid(0)).reverse;
#{
	ly_a := find(gmm,"mImgIdx");
	my_a := reverse(ly_a);
	convImgIdx:= join(fIdx,my_a);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	ny_a := find(gmm,"mCIdx");
	oy_a := reverse(ny_a);
	convCIdx:= join(fIdx,oy_a);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	py_a := reverse(convImgIdx);
	qy_a := insert(subgmm,"mImgIdx",py_a);
#  subgmm.insert( "mImgIdx", convImgIdx.reverse );
	ry_a := reverse(convCIdx);
	sy_a := insert(subgmm,"mCIdx",ry_a);
#  subgmm.insert( "mCIdx",   convCIdx.reverse );
#
	ty_a := find(gmm,"Prior");
	uy_a := join(fIdx,ty_a);
	vy_a := insert(subgmm,"Prior",uy_a);
#  subgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	wy_a := find(gmm,"Mean");
	xy_a := multiplex.join(fIdx,wy_a);
	yy_a := insert(subgmm,"Mean",xy_a);
#  subgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	aa_b := find(gmm,"Covar");
	ba_b := multiplex.join(fIdx,aa_b);
	ca_b := insert(subgmm,"Covar",ba_b);
#  subgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	da_b := find(gmm,"init_variances");
	ea_b := join(fIdx,da_b);
	fa_b := insert(subgmm,"init_variances",ea_b);
#  subgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1648 "../../../src/gmm/gmm.mx"
#
	ga_b := gmmsamp_diag(Nsamples,subgmm);
	return ga_b;
#    RETURN gmmsamp_diag( Nsamples, subgmm );
end function;
#  }
#
function randprob(N:int):bat[void,dbl];
#  PROC randprob(int N):bat[void,dbl] := {
	t:= randseq(N);
#    VAR t := randseq(N);
	ha_b := multiplex.lng(t);
	ia_b := sum(ha_b);
	ja_b := dbl(ia_b);
	t := multiplex./(t,ja_b);
#    t := [/]( t, const dbl([lng](t).sum) );
	return t;
#    RETURN t;
end function;
#  }
#
#
##line 1705 "../../../src/gmm/gmm.mx"
function initGMM(coll:bat[str,bat]):bat[str,bat];
#PROC initGMM( bat[str,bat] coll ):bat[str,bat] := {
	ka_b := debug("Estimating initial model");
#  debug("Estimating initial model");
	gmm:= new(str,bat);
#  VAR gmm := new(str,bat);
#
	I:= find(coll,"I");
#  VAR I       := coll.find("I");
	Ib:= find(coll,"Ib");
#  VAR Ib      := coll.find("Ib");
	coeffs:= find(coll,"Coeffs");
#  VAR coeffs  := coll.find("Coeffs");
#
	cseq:= take("cseq");
	la_b := reverse(cseq);
	ma_b := project(la_b,1);
	na_b := reverse(ma_b);
	oa_b := project(I,1);
	icIdx:= join(oa_b,na_b);
#  VAR icIdx   := I.project(1).join(cseq.reverse.project(1).reverse);
	mImgIdx:= xn(icIdx);
#  VAR mImgIdx := xn(icIdx);
	pa_b := nx(icIdx);
	mCIdx:= reverse(pa_b);
#  VAR mCIdx   := nx(icIdx).reverse;
#
	qa_b := insert(gmm,"mImgIdx",mImgIdx);
#  gmm.insert( "mImgIdx", mImgIdx );
	ra_b := insert(gmm,"mCIdx",mCIdx);
#  gmm.insert( "mCIdx",   mCIdx );
#
#
##line 1722 "../../../src/gmm/gmm.mx"
	C:= take("C");
	sa_b := /(1.0,C);
	ta_b := reverse(mImgIdx);
	ua_b := project(ta_b,sa_b);
	va_b := insert(gmm,"Prior",ua_b);
#  gmm.insert( "Prior", mImgIdx.reverse.project(1.0 / C ) );
#
#
##line 1727 "../../../src/gmm/gmm.mx"
	wa_b := count(I);
	xa_b := *(wa_b,C);
	ya_b := new(oid,void,xa_b);
	ab_b := oid(0);
	bb_b := reverse(ya_b);
	cb_b := setSequenceBase(bb_b,ab_b);
	aSample:= reverse(cb_b);
#  VAR aSample := new(oid,void,I.count * C).reverse.setSequenceBase(oid(0)).reverse;
	db_b := oid(0);
	eb_b := mark(I,db_b);
	fb_b_cursor := 0:lng;
barrier	fb_b:= batloop(fb_b_cursor,eb_b,fb_bH,fb_bT);
#  I.mark(oid(0))@batloop(){
	gb_b := reverse(Ib);
	hb_b := select(gb_b,fb_bH);
	ib_b := int(fb_bT);
	jb_b := *(C,ib_b);
	kb_b := oid(jb_b);
	lb_b := sample(hb_b,C);
	mb_b := mark(lb_b,kb_b);
	nb_b := insert(aSample,mb_b);
#    aSample.insert( Ib.reverse.select($h).sample(C).mark(oid(C * int($t))) );
redo	fb_b;
end	fb_b;
#  }
#  gmm.insert( "Mean",
#      [reverse]( 
#	[join](
	ob_b := multiplex.reverse(coeffs);
#	  [reverse](coeffs), 
	pb_b := multiplex.join(ob_b,aSample);
#	  const aSample ))
	qb_b := multiplex.reverse(pb_b);
	rb_b := insert(gmm,"Mean",qb_b);
#  );
#
#
##line 1741 "../../../src/gmm/gmm.mx"
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR imgcoeffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	sb_b := htype(coeffs);
	tb_b := count(coeffs);
	imgcoeffs := new(sb_b,bat,tb_b);
#  imgcoeffs := new(coeffs.htype,bat,coeffs.count);
	imgcoeffs_lock:= lock_create();
#  VAR imgcoeffs_lock := lock_create();
	Nthreads:= take("Nthreads");
	ub_b_cursor := 0:lng;
barrier	ub_b:= batloop(ub_b_cursor,Nthreads,ub_bH,ub_bT);
#  coeffs@ [Nthreads]batloop(){
	_imgcoeffs_result:= join(Ib,ub_bT);
#    VAR _imgcoeffs_result := join( Ib, $t );
	vb_b := lock_set(imgcoeffs_lock);
#    lock_set(imgcoeffs_lock);
	wb_b := insert(imgcoeffs,ub_bH,_imgcoeffs_result);
#    imgcoeffs.insert( $h, _imgcoeffs_result );
	xb_b := lock_unset(imgcoeffs_lock);
#    lock_unset(imgcoeffs_lock);
redo	ub_b;
end	ub_b;
#  }
	yb_b := lock_destroy(imgcoeffs_lock);
#  lock_destroy(imgcoeffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1741 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	ac_b := htype(imgcoeffs);
	bc_b := count(imgcoeffs);
	Area:= new(ac_b,bat,bc_b);
#  VAR Area := new(imgcoeffs.htype,bat,imgcoeffs.count);
#  {
	Area_lock:= lock_create();
#    VAR Area_lock := lock_create();
	cc_b_cursor := 0:lng;
barrier	cc_b:= batloop(cc_b_cursor,Nthreads,cc_bH,cc_bT);
#    imgcoeffs@ [Nthreads]batloop(){
#      VAR _Area_result := {sum}($t
	_Area_result:= pump.sum(cc_bT);
#	   );
	dc_b := lock_set(Area_lock);
#      lock_set(Area_lock);
	ec_b := insert(Area,cc_bH,_Area_result);
#      Area.insert($h,_Area_result);
	fc_b := lock_unset(Area_lock);
#      lock_unset(Area_lock);
redo	cc_b;
end	cc_b;
#    }
	gc_b := lock_destroy(Area_lock);
#    lock_destroy(Area_lock);
#  }
#
#
##line 1742 "../../../src/gmm/gmm.mx"
#
	imgcoeffs := nil;
#            imgcoeffs := nil;
	hc_b := reverse(Ib);
	Ndata:= histogram(hc_b);
#  VAR Ndata := Ib.reverse.histogram;
#  
##line 107 "../../../src/gmm/gmm.mx"
	ic_b := htype(Area);
	jc_b := count(Area);
	means:= new(ic_b,bat,jc_b);
#  VAR means := new(Area.htype,bat,Area.count);
#  {
	means_lock:= lock_create();
#    VAR means_lock := lock_create();
	kc_b_cursor := 0:lng;
barrier	kc_b:= batloop(kc_b_cursor,Nthreads,kc_bH,kc_bT);
#    Area@ [Nthreads]batloop(){
#      VAR _means_result := [/]($t
#	
##line 104 "../../../src/gmm/gmm.mx"
#,Ndata
#
#
##line 112 "../../../src/gmm/gmm.mx"
	_means_result:= multiplex./(kc_bT,Ndata);
#   );
	lc_b := lock_set(means_lock);
#      lock_set(means_lock);
	mc_b := insert(means,kc_bH,_means_result);
#      means.insert($h,_means_result);
	nc_b := lock_unset(means_lock);
#      lock_unset(means_lock);
redo	kc_b;
end	kc_b;
#    }
	oc_b := lock_destroy(means_lock);
#    lock_destroy(means_lock);
#  }
#
#
##line 1745 "../../../src/gmm/gmm.mx"
#
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR alignedmeans;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	pc_b := htype(means);
	qc_b := count(means);
	alignedmeans := new(pc_b,bat,qc_b);
#  alignedmeans := new(means.htype,bat,means.count);
	alignedmeans_lock:= lock_create();
#  VAR alignedmeans_lock := lock_create();
	rc_b_cursor := 0:lng;
barrier	rc_b:= batloop(rc_b_cursor,Nthreads,rc_bH,rc_bT);
#  means@ [Nthreads]batloop(){
	sc_b := reverse(Ib);
	_alignedmeans_result:= join(sc_b,rc_bT);
#    VAR _alignedmeans_result := join( Ib.reverse, $t );
	tc_b := lock_set(alignedmeans_lock);
#    lock_set(alignedmeans_lock);
	uc_b := insert(alignedmeans,rc_bH,_alignedmeans_result);
#    alignedmeans.insert( $h, _alignedmeans_result );
	vc_b := lock_unset(alignedmeans_lock);
#    lock_unset(alignedmeans_lock);
redo	rc_b;
end	rc_b;
#  }
	wc_b := lock_destroy(alignedmeans_lock);
#  lock_destroy(alignedmeans_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1746 "../../../src/gmm/gmm.mx"
#
	means := nil;
#            means := nil;
#
	diffs:= multiplex.nestedop("-",coeffs,alignedmeans);
#  VAR diffs := [nestedop]("-",coeffs,alignedmeans);
	alignedmeans := nil;
#            alignedmeans := nil;
	coeffs := nil;
#	    coeffs := nil;
	diffs := multiplex.square(diffs);
#  diffs := [square](diffs);       # deepop?
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR imgdiffs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	xc_b := htype(diffs);
	yc_b := count(diffs);
	imgdiffs := new(xc_b,bat,yc_b);
#  imgdiffs := new(diffs.htype,bat,diffs.count);
	imgdiffs_lock:= lock_create();
#  VAR imgdiffs_lock := lock_create();
	ad_b_cursor := 0:lng;
barrier	ad_b:= batloop(ad_b_cursor,Nthreads,ad_bH,ad_bT);
#  diffs@ [Nthreads]batloop(){
	_imgdiffs_result:= join(Ib,ad_bT);
#    VAR _imgdiffs_result := join( Ib, $t );
	bd_b := lock_set(imgdiffs_lock);
#    lock_set(imgdiffs_lock);
	cd_b := insert(imgdiffs,ad_bH,_imgdiffs_result);
#    imgdiffs.insert( $h, _imgdiffs_result );
	dd_b := lock_unset(imgdiffs_lock);
#    lock_unset(imgdiffs_lock);
redo	ad_b;
end	ad_b;
#  }
	ed_b := lock_destroy(imgdiffs_lock);
#  lock_destroy(imgdiffs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1753 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	fd_b := htype(imgdiffs);
	gd_b := count(imgdiffs);
	tmp:= new(fd_b,bat,gd_b);
#  VAR tmp := new(imgdiffs.htype,bat,imgdiffs.count);
#  {
	tmp_lock:= lock_create();
#    VAR tmp_lock := lock_create();
	hd_b_cursor := 0:lng;
barrier	hd_b:= batloop(hd_b_cursor,Nthreads,hd_bH,hd_bT);
#    imgdiffs@ [Nthreads]batloop(){
#      VAR _tmp_result := {sum}($t
	_tmp_result:= pump.sum(hd_bT);
#	   );
	id_b := lock_set(tmp_lock);
#      lock_set(tmp_lock);
	jd_b := insert(tmp,hd_bH,_tmp_result);
#      tmp.insert($h,_tmp_result);
	kd_b := lock_unset(tmp_lock);
#      lock_unset(tmp_lock);
redo	hd_b;
end	hd_b;
#    }
	ld_b := lock_destroy(tmp_lock);
#    lock_destroy(tmp_lock);
#  }
#
#
##line 1754 "../../../src/gmm/gmm.mx"
#
#  
##line 107 "../../../src/gmm/gmm.mx"
	md_b := htype(tmp);
	nd_b := count(tmp);
	variances:= new(md_b,bat,nd_b);
#  VAR variances := new(tmp.htype,bat,tmp.count);
#  {
	variances_lock:= lock_create();
#    VAR variances_lock := lock_create();
	od_b_cursor := 0:lng;
barrier	od_b:= batloop(od_b_cursor,Nthreads,od_bH,od_bT);
#    tmp@ [Nthreads]batloop(){
#      VAR _variances_result := [/]($t
#	
##line 104 "../../../src/gmm/gmm.mx"
#,Ndata
#
#
##line 112 "../../../src/gmm/gmm.mx"
	_variances_result:= multiplex./(od_bT,Ndata);
#   );
	pd_b := lock_set(variances_lock);
#      lock_set(variances_lock);
	qd_b := insert(variances,od_bH,_variances_result);
#      variances.insert($h,_variances_result);
	rd_b := lock_unset(variances_lock);
#      lock_unset(variances_lock);
redo	od_b;
end	od_b;
#    }
	sd_b := lock_destroy(variances_lock);
#    lock_destroy(variances_lock);
#  }
#
#
##line 1755 "../../../src/gmm/gmm.mx"
#
	tmp := nil;
#            tmp := nil;
	imgdiffs := nil;
#	    imgdiffs := nil;
	Ndata := nil;
#	    Ndata := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR init_variances;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	init_variances_a:= fetch(variances,0);
	init_variances_e:= fetch(variances,4);
#    VAR init_variances_a := variances.fetch(0);    VAR init_variances_e := variances.fetch(4);
	init_variances_b:= fetch(variances,1);
	init_variances_f:= fetch(variances,5);
#    VAR init_variances_b := variances.fetch(1);    VAR init_variances_f := variances.fetch(5);
	init_variances_c:= fetch(variances,2);
	init_variances_g:= fetch(variances,6);
#    VAR init_variances_c := variances.fetch(2);    VAR init_variances_g := variances.fetch(6);
	init_variances_d:= fetch(variances,3);
	init_variances_h:= fetch(variances,7);
#    VAR init_variances_d := variances.fetch(3);    VAR init_variances_h := variances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations init_variances_a in parallel
#    {
#      {|
barrier	td_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations init_variances_a in parallel
#      {
#	{|
barrier	ud_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	vd_b := multiplex.+(init_variances_a,init_variances_b);
	init_variances_a := access(vd_b,BAT_WRITE);
#	   init_variances_a := [+](init_variances_a,init_variances_b).access(BAT_WRITE);
	init_variances_c := multiplex.+(init_variances_c,init_variances_d);
#	   init_variances_c := [+](init_variances_c,init_variances_d);
end	ud_b;
#	 |}
	wd_b := multiplex.:+=(init_variances_a,init_variances_c);
#	 [:+=](init_variances_a,init_variances_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations init_variances_e in parallel
#      {
#	{|
barrier	xd_b:= true;
	yd_b := multiplex.+(init_variances_e,init_variances_f);
	init_variances_e := access(yd_b,BAT_WRITE);
#	   init_variances_e := [+](init_variances_e,init_variances_f).access(BAT_WRITE);
	init_variances_g := multiplex.+(init_variances_g,init_variances_h);
#	   init_variances_g := [+](init_variances_g,init_variances_h);
end	xd_b;
#	 |}
	ae_b := multiplex.:+=(init_variances_e,init_variances_g);
#	 [:+=](init_variances_e,init_variances_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	td_b;
#       |}
	be_b := multiplex.:+=(init_variances_a,init_variances_e);
#       [:+=](init_variances_a,init_variances_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	init_variances := init_variances_a;
#    init_variances := init_variances_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1759 "../../../src/gmm/gmm.mx"
#
	ce_b := multiplex./(init_variances,N);
#  init_variances := [*]( [/]( init_variances, const N ), 
	init_variances := multiplex.*(ce_b,COVAR_INIT_FRACTION);
#    const COVAR_INIT_FRACTION );
#    # Q: blow up this one here or in the loop???
	de_b := reverse(mImgIdx);
	init_variances := join(de_b,init_variances);
#  init_variances := join(mImgIdx.reverse, init_variances);
	ee_b := insert(gmm,"init_variances",init_variances);
#  gmm.insert( "init_variances", init_variances );
#
	covar:= new(int,bat,N);
#  VAR covar := new(int,bat,N);
	i:= 0;
#  VAR i := 0;
barrier	fe_b:= true;
	he_b := <(i,N);
barrier	ge_b:= he_b;
#  WHILE (i < N) {
	ie_b := insert(covar,i,init_variances);
#    covar.insert( i, init_variances );
	je_b := :+=(i,1);
#    i :+= 1;
redo	fe_b;
end	ge_b;
end	fe_b;
#  }
	ke_b := insert(gmm,"Covar",covar);
#  gmm.insert( "Covar", covar );
#
	sessionId:= take("sessionId");
	le_b := +(sessionId,"_init");
	me_b := +("gmm",le_b);
	ne_b := renameGMM(gmm,me_b);
#  gmm.renameGMM("gmm" + sessionId + "_init");
	return gmm;
#  RETURN gmm;
end function;
#}
#
#
#
##line 1781 "../../../src/gmm/gmm.mx"
function test_EM(Nimg:int, M:int):bat[str,bat];
#PROC test_EM(int Nimg, int M): bat[str,bat] := {
	testmodels:= new(str,bat);
#  VAR testmodels := new(str,bat);
#
	oe_b := debug("Creating collection with M=%d",M);
#  debug("Creating collection with M=%d",M);
	sessionId:= take("sessionId");
	pe_b := +("imgs",sessionId);
	imgs:= newCollection(pe_b,Nimg);
#  VAR imgs := newCollection("imgs" + sessionId, Nimg);
#  
##line 663 "../../../src/gmm/gmm.mx"
	qe_b := find(imgs,"Coeffs");
	re_b_cursor := 0:lng;
barrier	re_b:= batloop(re_b_cursor,qe_b,re_bH,re_bT);
	se_b := setPersistent(re_bT);
redo	re_b;
end	re_b;
#  imgs.find("Coeffs")@batloop{ setPersistent($t); }
	te_b_cursor := 0:lng;
barrier	te_b:= batloop(te_b_cursor,imgs,te_bH,te_bT);
	ue_b := setPersistent(te_bT);
redo	te_b;
end	te_b;
#  imgs@batloop(){ setPersistent($t); }
#
#
##line 1786 "../../../src/gmm/gmm.mx"
#
#  
##line 663 "../../../src/gmm/gmm.mx"
	ve_b := find(imgs,"Coeffs");
	we_b_cursor := 0:lng;
barrier	we_b:= batloop(we_b_cursor,ve_b,we_bH,we_bT);
	STORE_MMAP:= take("STORE_MMAP");
	xe_b := mmap(we_bT,STORE_MMAP);
redo	we_b;
end	we_b;
#  imgs.find("Coeffs")@batloop{ mmap($t, STORE_MMAP); }
	ye_b_cursor := 0:lng;
barrier	ye_b:= batloop(ye_b_cursor,imgs,ye_bH,ye_bT);
	af_b := mmap(ye_bT,STORE_MMAP);
redo	ye_b;
end	ye_b;
#  imgs@batloop(){ mmap($t, STORE_MMAP); }
#
#
##line 1787 "../../../src/gmm/gmm.mx"
#
#
#
##line 1793 "../../../src/gmm/gmm.mx"
	bf_b := find(imgs,"Coeffs");
	cf_b := setTransient(bf_b,);
#           imgs.find("Coeffs").setTransient();
	df_b := +("src",sessionId);
	src_gmm:= newGMM(df_b);
#  VAR src_gmm := newGMM("src" + sessionId);
#  
##line 655 "../../../src/gmm/gmm.mx"
	ef_b := find(src_gmm,"init_variances");
	ff_b := setPersistent(ef_b);
#  setPersistent( src_gmm.find("init_variances") );
	gf_b := find(src_gmm,"Prior");
	hf_b := setPersistent(gf_b);
#  setPersistent( src_gmm.find("Prior") );
	if_b := find(src_gmm,"mImgIdx");
	jf_b := setPersistent(if_b);
#  setPersistent( src_gmm.find("mImgIdx") );
	kf_b := find(src_gmm,"mCIdx");
	lf_b := setPersistent(kf_b);
#  setPersistent( src_gmm.find("mCIdx") );
	mf_b := find(src_gmm,"Mean");
	nf_b_cursor := 0:lng;
barrier	nf_b:= batloop(nf_b_cursor,mf_b,nf_bH,nf_bT);
	of_b := setPersistent(nf_bT);
redo	nf_b;
end	nf_b;
#  src_gmm.find("Mean")@batloop{  setPersistent($t); }
	pf_b := find(src_gmm,"Covar");
	qf_b_cursor := 0:lng;
barrier	qf_b:= batloop(qf_b_cursor,pf_b,qf_bH,qf_bT);
	rf_b := setPersistent(qf_bT);
redo	qf_b;
end	qf_b;
#  src_gmm.find("Covar")@batloop{ setPersistent($t); }
#
#
##line 1795 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	sf_b := find(src_gmm,"init_variances");
	tf_b := mmap(sf_b,STORE_MMAP);
#  mmap( src_gmm.find("init_variances"), STORE_MMAP );
	uf_b := find(src_gmm,"Prior");
	vf_b := mmap(uf_b,STORE_MMAP);
#  mmap( src_gmm.find("Prior"), STORE_MMAP );
	wf_b := find(src_gmm,"mImgIdx");
	xf_b := mmap(wf_b,STORE_MMAP);
#  mmap( src_gmm.find("mImgIdx"), STORE_MMAP );
	yf_b := find(src_gmm,"mCIdx");
	ag_b := mmap(yf_b,STORE_MMAP);
#  mmap( src_gmm.find("mCIdx"), STORE_MMAP );
	bg_b := find(src_gmm,"Mean");
	cg_b_cursor := 0:lng;
barrier	cg_b:= batloop(cg_b_cursor,bg_b,cg_bH,cg_bT);
	dg_b := mmap(cg_bT,STORE_MMAP);
redo	cg_b;
end	cg_b;
#  src_gmm.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
	eg_b := find(src_gmm,"Covar");
	fg_b_cursor := 0:lng;
barrier	fg_b:= batloop(fg_b_cursor,eg_b,fg_bH,fg_bT);
	gg_b := mmap(fg_bT,STORE_MMAP);
redo	fg_b;
end	fg_b;
#  src_gmm.find("Covar")@batloop{ mmap($t, STORE_MMAP); }
#
#
##line 1796 "../../../src/gmm/gmm.mx"
#
#
#  
##line 1663 "../../../src/gmm/gmm.mx"
#  
##line 663 "../../../src/gmm/gmm.mx"
	hg_b := find(imgs,"Coeffs");
	ig_b_cursor := 0:lng;
barrier	ig_b:= batloop(ig_b_cursor,hg_b,ig_bH,ig_bT);
	BAT_APPEND:= take("BAT_APPEND");
	jg_b := access(ig_bT,BAT_APPEND);
redo	ig_b;
end	ig_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
	kg_b_cursor := 0:lng;
barrier	kg_b:= batloop(kg_b_cursor,imgs,kg_bH,kg_bT);
	lg_b := access(kg_bT,BAT_APPEND);
redo	kg_b;
end	kg_b;
#  imgs@batloop(){ access($t, BAT_APPEND); }
#
#
##line 1663 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	mg_b := find(src_gmm,"init_variances");
	ng_b := access(mg_b,BAT_APPEND);
#  access( src_gmm.find("init_variances"), BAT_APPEND );
	og_b := find(src_gmm,"Prior");
	pg_b := access(og_b,BAT_APPEND);
#  access( src_gmm.find("Prior"), BAT_APPEND );
	qg_b := find(src_gmm,"mImgIdx");
	rg_b := access(qg_b,BAT_APPEND);
#  access( src_gmm.find("mImgIdx"), BAT_APPEND );
	sg_b := find(src_gmm,"mCIdx");
	tg_b := access(sg_b,BAT_APPEND);
#  access( src_gmm.find("mCIdx"), BAT_APPEND );
	ug_b := find(src_gmm,"Mean");
	vg_b_cursor := 0:lng;
barrier	vg_b:= batloop(vg_b_cursor,ug_b,vg_bH,vg_bT);
	wg_b := access(vg_bT,BAT_APPEND);
redo	vg_b;
end	vg_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
	xg_b := find(src_gmm,"Covar");
	yg_b_cursor := 0:lng;
barrier	yg_b:= batloop(yg_b_cursor,xg_b,yg_bH,yg_bT);
	ah_b := access(yg_bT,BAT_APPEND);
redo	yg_b;
end	yg_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1664 "../../../src/gmm/gmm.mx"
#
#  # some random metadata for now
	bh_b := str(0);
	ch_b := +(bh_b,".jpg");
	dh_b := +("http://nowhere.org/noimg_",ch_b);
	eh_b := find(imgs,"I");
	fh_b := insert(eh_b,nil,dh_b);
#  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(0) + ".jpg");
	gh_b := Nseq(M);
	hh_b_cursor := 0:lng;
barrier	hh_b:= batloop(hh_b_cursor,gh_b,hh_bH,hh_bT);
#  Nseq(M)@batloop(){
	ih_b := oid(0);
	jh_b := find(imgs,"Ib");
	kh_b := insert(jh_b,ih_b,nil);
#    imgs.find("Ib").insert(oid(0),nil);
	lh_b := %(hh_bT,44);
	mh_b := find(imgs,"Ix");
	nh_b := insert(mh_b,nil,lh_b);
#    imgs.find("Ix").insert(nil, ($t % 44));
	oh_b := /(hh_bT,44);
	ph_b := find(imgs,"Iy");
	qh_b := insert(ph_b,nil,oh_b);
#    imgs.find("Iy").insert(nil, ($t / 44));
redo	hh_b;
end	hh_b;
#  }
	C:= take("C");
	rh_b := randprob(C);
	sh_b := multiplex.flt(rh_b);
	th_b := find(src_gmm,"Prior");
	uh_b := insert(th_b,sh_b);
#  src_gmm.find("Prior").insert( [flt](randprob(C)) );
	cseq:= take("cseq");
	vh_b_cursor := 0:lng;
barrier	vh_b:= batloop(vh_b_cursor,cseq,vh_bH,vh_bT);
#  cseq@batloop(){
#    # NOTE: was RAND_MAX + 1.0LL
	wh_b := find(src_gmm,"Mean");
#    [insert]( src_gmm.find("Mean"), const nil,
	xh_b := randseq(N);
	yh_b := +(RAND_MAX,1.0);
	ai_b := /(yh_b,255);
	bi_b := multiplex./(xh_b,ai_b);
	ci_b := reverse(bi_b);
	di_b := number(ci_b);
	ei_b := reverse(di_b);
	fi_b := multiplex.insert(wh_b,nil,ei_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse.number.reverse );
	gi_b := find(src_gmm,"Covar");
#    [insert]( src_gmm.find("Covar"), const nil,
	hi_b := randseq(N);
	ii_b := +(RAND_MAX,1.0);
	ji_b := /(ii_b,128);
	ki_b := multiplex./(hi_b,ji_b);
	li_b := reverse(ki_b);
	mi_b := number(li_b);
	ni_b := reverse(mi_b);
	oi_b := multiplex.insert(gi_b,nil,ni_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse.number.reverse );
redo	vh_b;
end	vh_b;
#  }
	pi_b := oid(0);
	qi_b := _x(cseq);
	ri_b := project(qi_b,pi_b);
	si_b := reverse(ri_b);
	ti_b := find(src_gmm,"mImgIdx");
	ui_b := insert(ti_b,si_b);
#  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(0)).reverse);
	vi_b := _x(cseq);
	wi_b := reverse(vi_b);
	xi_b := find(src_gmm,"mCIdx");
	yi_b := insert(xi_b,wi_b);
#  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
#    # bug with first insert in table
	aj_b := find(src_gmm,"mImgIdx");
	bj_b := oid(0);
	cj_b := reverse(aj_b);
	dj_b := setSequenceBase(cj_b,bj_b);
	ej_b := reverse(dj_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)).reverse;
	fj_b := find(src_gmm,"mCIdx");
	gj_b := oid(0);
	hj_b := reverse(fj_b);
	ij_b := setSequenceBase(hj_b,gj_b);
	jj_b := reverse(ij_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0)).reverse;
#  
##line 655 "../../../src/gmm/gmm.mx"
	kj_b := find(src_gmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	lj_b := access(kj_b,BAT_READ);
#  access( src_gmm.find("init_variances"), BAT_READ );
	mj_b := find(src_gmm,"Prior");
	nj_b := access(mj_b,BAT_READ);
#  access( src_gmm.find("Prior"), BAT_READ );
	oj_b := find(src_gmm,"mImgIdx");
	pj_b := access(oj_b,BAT_READ);
#  access( src_gmm.find("mImgIdx"), BAT_READ );
	qj_b := find(src_gmm,"mCIdx");
	rj_b := access(qj_b,BAT_READ);
#  access( src_gmm.find("mCIdx"), BAT_READ );
	sj_b := find(src_gmm,"Mean");
	tj_b_cursor := 0:lng;
barrier	tj_b:= batloop(tj_b_cursor,sj_b,tj_bH,tj_bT);
	uj_b := access(tj_bT,BAT_READ);
redo	tj_b;
end	tj_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
	vj_b := find(src_gmm,"Covar");
	wj_b_cursor := 0:lng;
barrier	wj_b:= batloop(wj_b_cursor,vj_b,wj_bH,wj_bT);
	xj_b := access(wj_bT,BAT_READ);
redo	wj_b;
end	wj_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1685 "../../../src/gmm/gmm.mx"
#
	yj_b := oid(0);
	aSampleImg:= gmmsamp_diag(M,yj_b,src_gmm);
#  VAR aSampleImg := gmmsamp_diag(M, oid(0), src_gmm);
#  {
	ak_b := find(aSampleImg,"Samples");
	imgSamples:= multiplex.nestedop("sht",ak_b);
#    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
#    [insert](
	bk_b := find(imgs,"Coeffs");
#      imgs.find("Coeffs"),
#      imgSamples
	ck_b := multiplex.insert(bk_b,imgSamples);
#    );
	commit:= take("commit");
#    commit;
#  }
#  
##line 663 "../../../src/gmm/gmm.mx"
	dk_b := find(imgs,"Coeffs");
	ek_b_cursor := 0:lng;
barrier	ek_b:= batloop(ek_b_cursor,dk_b,ek_bH,ek_bT);
	fk_b := access(ek_bT,BAT_READ);
redo	ek_b;
end	ek_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
	gk_b_cursor := 0:lng;
barrier	gk_b:= batloop(gk_b_cursor,imgs,gk_bH,gk_bT);
	hk_b := access(gk_bT,BAT_READ);
redo	gk_b;
end	gk_b;
#  imgs@batloop(){ access($t, BAT_READ); }
#
#
##line 1695 "../../../src/gmm/gmm.mx"
#
#
#
##line 1798 "../../../src/gmm/gmm.mx"
#
	ik_b := find(src_gmm,"mImgIdx");
	jk_b := oid(0);
	kk_b := reverse(ik_b);
	lk_b := setSequenceBase(kk_b,jk_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)); # bug??
	mk_b := find(src_gmm,"mCIdx");
	nk_b := oid(0);
	ok_b := reverse(mk_b);
	pk_b := setSequenceBase(ok_b,nk_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0));
#
#  # Insert additional images
	imgNr:= 1;
#  VAR imgNr := 1;
barrier	qk_b:= true;
	sk_b := <(imgNr,Nimg);
barrier	rk_b:= sk_b;
#  WHILE ( imgNr < Nimg ) {
#    
##line 1663 "../../../src/gmm/gmm.mx"
#  
##line 663 "../../../src/gmm/gmm.mx"
	tk_b := find(imgs,"Coeffs");
	uk_b_cursor := 0:lng;
barrier	uk_b:= batloop(uk_b_cursor,tk_b,uk_bH,uk_bT);
	vk_b := access(uk_bT,BAT_APPEND);
redo	uk_b;
end	uk_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_APPEND); }
	wk_b_cursor := 0:lng;
barrier	wk_b:= batloop(wk_b_cursor,imgs,wk_bH,wk_bT);
	xk_b := access(wk_bT,BAT_APPEND);
redo	wk_b;
end	wk_b;
#  imgs@batloop(){ access($t, BAT_APPEND); }
#
#
##line 1663 "../../../src/gmm/gmm.mx"
#
#  
##line 655 "../../../src/gmm/gmm.mx"
	yk_b := find(src_gmm,"init_variances");
	al_b := access(yk_b,BAT_APPEND);
#  access( src_gmm.find("init_variances"), BAT_APPEND );
	bl_b := find(src_gmm,"Prior");
	cl_b := access(bl_b,BAT_APPEND);
#  access( src_gmm.find("Prior"), BAT_APPEND );
	dl_b := find(src_gmm,"mImgIdx");
	el_b := access(dl_b,BAT_APPEND);
#  access( src_gmm.find("mImgIdx"), BAT_APPEND );
	fl_b := find(src_gmm,"mCIdx");
	gl_b := access(fl_b,BAT_APPEND);
#  access( src_gmm.find("mCIdx"), BAT_APPEND );
	hl_b := find(src_gmm,"Mean");
	il_b_cursor := 0:lng;
barrier	il_b:= batloop(il_b_cursor,hl_b,il_bH,il_bT);
	jl_b := access(il_bT,BAT_APPEND);
redo	il_b;
end	il_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_APPEND); }
	kl_b := find(src_gmm,"Covar");
	ll_b_cursor := 0:lng;
barrier	ll_b:= batloop(ll_b_cursor,kl_b,ll_bH,ll_bT);
	ml_b := access(ll_bT,BAT_APPEND);
redo	ll_b;
end	ll_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 1664 "../../../src/gmm/gmm.mx"
#
#  # some random metadata for now
	nl_b := str(imgNr);
	ol_b := +(nl_b,".jpg");
	pl_b := +("http://nowhere.org/noimg_",ol_b);
	ql_b := find(imgs,"I");
	rl_b := insert(ql_b,nil,pl_b);
#  imgs.find("I").insert(nil,"http://nowhere.org/noimg_" + str(imgNr) + ".jpg");
	sl_b := Nseq(M);
	tl_b_cursor := 0:lng;
barrier	tl_b:= batloop(tl_b_cursor,sl_b,tl_bH,tl_bT);
#  Nseq(M)@batloop(){
	ul_b := oid(imgNr);
	vl_b := find(imgs,"Ib");
	wl_b := insert(vl_b,ul_b,nil);
#    imgs.find("Ib").insert(oid(imgNr),nil);
	xl_b := %(tl_bT,44);
	yl_b := find(imgs,"Ix");
	am_b := insert(yl_b,nil,xl_b);
#    imgs.find("Ix").insert(nil, ($t % 44));
	bm_b := /(tl_bT,44);
	cm_b := find(imgs,"Iy");
	dm_b := insert(cm_b,nil,bm_b);
#    imgs.find("Iy").insert(nil, ($t / 44));
redo	tl_b;
end	tl_b;
#  }
	em_b := randprob(C);
	fm_b := multiplex.flt(em_b);
	gm_b := find(src_gmm,"Prior");
	hm_b := insert(gm_b,fm_b);
#  src_gmm.find("Prior").insert( [flt](randprob(C)) );
	im_b_cursor := 0:lng;
barrier	im_b:= batloop(im_b_cursor,cseq,im_bH,im_bT);
#  cseq@batloop(){
#    # NOTE: was RAND_MAX + 1.0LL
	jm_b := find(src_gmm,"Mean");
#    [insert]( src_gmm.find("Mean"), const nil,
	km_b := randseq(N);
	lm_b := +(RAND_MAX,1.0);
	mm_b := /(lm_b,255);
	nm_b := multiplex./(km_b,mm_b);
	om_b := reverse(nm_b);
	pm_b := number(om_b);
	qm_b := reverse(pm_b);
	rm_b := multiplex.insert(jm_b,nil,qm_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 255).reverse.number.reverse );
	sm_b := find(src_gmm,"Covar");
#    [insert]( src_gmm.find("Covar"), const nil,
	tm_b := randseq(N);
	um_b := +(RAND_MAX,1.0);
	vm_b := /(um_b,128);
	wm_b := multiplex./(tm_b,vm_b);
	xm_b := reverse(wm_b);
	ym_b := number(xm_b);
	an_b := reverse(ym_b);
	bn_b := multiplex.insert(sm_b,nil,an_b);
#      [/]( randseq(N), const (RAND_MAX + 1.0) / 128).reverse.number.reverse );
redo	im_b;
end	im_b;
#  }
	cn_b := oid(imgNr);
	dn_b := _x(cseq);
	en_b := project(dn_b,cn_b);
	fn_b := reverse(en_b);
	gn_b := find(src_gmm,"mImgIdx");
	hn_b := insert(gn_b,fn_b);
#  src_gmm.find("mImgIdx").insert(_x(cseq).project(const oid(imgNr)).reverse);
	in_b := _x(cseq);
	jn_b := reverse(in_b);
	kn_b := find(src_gmm,"mCIdx");
	ln_b := insert(kn_b,jn_b);
#  src_gmm.find("mCIdx").insert(_x(cseq).reverse);
#    # bug with first insert in table
	mn_b := find(src_gmm,"mImgIdx");
	nn_b := oid(0);
	on_b := reverse(mn_b);
	pn_b := setSequenceBase(on_b,nn_b);
	qn_b := reverse(pn_b);
#  src_gmm.find("mImgIdx").reverse.setSequenceBase(oid(0)).reverse;
	rn_b := find(src_gmm,"mCIdx");
	sn_b := oid(0);
	tn_b := reverse(rn_b);
	un_b := setSequenceBase(tn_b,sn_b);
	vn_b := reverse(un_b);
#  src_gmm.find("mCIdx").reverse.setSequenceBase(oid(0)).reverse;
#  
##line 655 "../../../src/gmm/gmm.mx"
	wn_b := find(src_gmm,"init_variances");
	xn_b := access(wn_b,BAT_READ);
#  access( src_gmm.find("init_variances"), BAT_READ );
	yn_b := find(src_gmm,"Prior");
	ao_b := access(yn_b,BAT_READ);
#  access( src_gmm.find("Prior"), BAT_READ );
	bo_b := find(src_gmm,"mImgIdx");
	co_b := access(bo_b,BAT_READ);
#  access( src_gmm.find("mImgIdx"), BAT_READ );
	do_b := find(src_gmm,"mCIdx");
	eo_b := access(do_b,BAT_READ);
#  access( src_gmm.find("mCIdx"), BAT_READ );
	fo_b := find(src_gmm,"Mean");
	go_b_cursor := 0:lng;
barrier	go_b:= batloop(go_b_cursor,fo_b,go_bH,go_bT);
	ho_b := access(go_bT,BAT_READ);
redo	go_b;
end	go_b;
#  src_gmm.find("Mean")@batloop{  access($t, BAT_READ); }
	io_b := find(src_gmm,"Covar");
	jo_b_cursor := 0:lng;
barrier	jo_b:= batloop(jo_b_cursor,io_b,jo_bH,jo_bT);
	ko_b := access(jo_bT,BAT_READ);
redo	jo_b;
end	jo_b;
#  src_gmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1685 "../../../src/gmm/gmm.mx"
#
	lo_b := oid(imgNr);
	aSampleImg:= gmmsamp_diag(M,lo_b,src_gmm);
#  VAR aSampleImg := gmmsamp_diag(M, oid(imgNr), src_gmm);
#  {
	mo_b := find(aSampleImg,"Samples");
	imgSamples:= multiplex.nestedop("sht",mo_b);
#    VAR imgSamples := [nestedop]( "sht", aSampleImg.find("Samples") );
#    [insert](
	no_b := find(imgs,"Coeffs");
#      imgs.find("Coeffs"),
#      imgSamples
	oo_b := multiplex.insert(no_b,imgSamples);
#    );
#    commit;
#  }
#  
##line 663 "../../../src/gmm/gmm.mx"
	po_b := find(imgs,"Coeffs");
	qo_b_cursor := 0:lng;
barrier	qo_b:= batloop(qo_b_cursor,po_b,qo_bH,qo_bT);
	ro_b := access(qo_bT,BAT_READ);
redo	qo_b;
end	qo_b;
#  imgs.find("Coeffs")@batloop{ access($t, BAT_READ); }
	so_b_cursor := 0:lng;
barrier	so_b:= batloop(so_b_cursor,imgs,so_bH,so_bT);
	to_b := access(so_bT,BAT_READ);
redo	so_b;
end	so_b;
#  imgs@batloop(){ access($t, BAT_READ); }
#
#
##line 1695 "../../../src/gmm/gmm.mx"
#
#
#
##line 1805 "../../../src/gmm/gmm.mx"
#
	uo_b := :+=(imgNr,1);
#    imgNr :+= 1;
redo	qk_b;
end	rk_b;
end	qk_b;
#  }
##  testmodels.insert( "coll",  imgs );
##  testmodels.insert( "src",   src_gmm );
#
	gmm:= initGMM(imgs);
#  VAR gmm := initGMM( imgs );
##  testmodels.insert( "init",  gmm );
#
#
##line 1816 "../../../src/gmm/gmm.mx"
	vo_b := debug("EM model training");
#  debug("EM model training");
	EM_coll:= take("EM_coll");
	EM_coll := imgs;
#  EM_coll  := imgs;
	EM_model:= take("EM_model");
	EM_model := gmm;
#  EM_model := gmm;
	src_gmm := nil;
#    src_gmm := nil;
	imgs := nil;
#    imgs := nil;
	gmm := nil;
#    gmm  := nil;
#    #VAR gmmnew := EM(imgs, gmm);
	gmmnew:= EM_globalmodel();
#  VAR gmmnew := EM_globalmodel();
	wo_b := insert(testmodels,"final",gmmnew);
#  testmodels.insert( "final", gmmnew );
#
#  # @@imgop(imgs,persists,false)@
#  # @@modelop(src_gmm,persists,false)@
#
	return testmodels;
#  RETURN testmodels;
end function;
#}
##VAR testmodels := test_EM(128,1320);
##VAR testmodels := test_EM(10,100);
#
#
#
##line 1838 "../../../src/gmm/gmm.mx"
function classify(coeffs:bat[int,bat], gmm:bat[str,bat]):bat[void,TCluster];
#  PROC classify( bat[int,bat] coeffs, bat[str,bat] gmm ): bat[void,TCluster] := {
#    
##line 1331 "../../../src/gmm/gmm.mx"
#  
##line 1305 "../../../src/gmm/gmm.mx"
	covar:= find(gmm,"Covar");
#  VAR covar    := gmm.find("Covar");
	covar := multiplex.nestedop("dbl",covar);
#                  covar := [nestedop]( "dbl", covar);
#  
##line 107 "../../../src/gmm/gmm.mx"
	xo_b := htype(covar);
	yo_b := count(covar);
	ivariances:= new(xo_b,bat,yo_b);
#  VAR ivariances := new(covar.htype,bat,covar.count);
#  {
	ivariances_lock:= lock_create();
#    VAR ivariances_lock := lock_create();
	Nthreads:= take("Nthreads");
	ap_b_cursor := 0:lng;
barrier	ap_b:= batloop(ap_b_cursor,Nthreads,ap_bH,ap_bT);
#    covar@ [Nthreads]batloop(){
#      VAR _ivariances_result := [inv]($t
	_ivariances_result:= multiplex.inv(ap_bT);
#	   );
	bp_b := lock_set(ivariances_lock);
#      lock_set(ivariances_lock);
	cp_b := insert(ivariances,ap_bH,_ivariances_result);
#      ivariances.insert($h,_ivariances_result);
	dp_b := lock_unset(ivariances_lock);
#      lock_unset(ivariances_lock);
redo	ap_b;
end	ap_b;
#    }
	ep_b := lock_destroy(ivariances_lock);
#    lock_destroy(ivariances_lock);
#  }
#
#
##line 1307 "../../../src/gmm/gmm.mx"
#
	covar := nil;
#                  covar  := nil;
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR isqrtdet;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	isqrtdet_a:= fetch(ivariances,0);
	isqrtdet_e:= fetch(ivariances,4);
#    VAR isqrtdet_a := ivariances.fetch(0);    VAR isqrtdet_e := ivariances.fetch(4);
	isqrtdet_b:= fetch(ivariances,1);
	isqrtdet_f:= fetch(ivariances,5);
#    VAR isqrtdet_b := ivariances.fetch(1);    VAR isqrtdet_f := ivariances.fetch(5);
	isqrtdet_c:= fetch(ivariances,2);
	isqrtdet_g:= fetch(ivariances,6);
#    VAR isqrtdet_c := ivariances.fetch(2);    VAR isqrtdet_g := ivariances.fetch(6);
	isqrtdet_d:= fetch(ivariances,3);
	isqrtdet_h:= fetch(ivariances,7);
#    VAR isqrtdet_d := ivariances.fetch(3);    VAR isqrtdet_h := ivariances.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations isqrtdet_a in parallel
#    {
#      {|
barrier	fp_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_a in parallel
#      {
#	{|
barrier	gp_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	hp_b := multiplex.*(isqrtdet_a,isqrtdet_b);
	isqrtdet_a := access(hp_b,BAT_WRITE);
#	   isqrtdet_a := [*](isqrtdet_a,isqrtdet_b).access(BAT_WRITE);
	isqrtdet_c := multiplex.*(isqrtdet_c,isqrtdet_d);
#	   isqrtdet_c := [*](isqrtdet_c,isqrtdet_d);
end	gp_b;
#	 |}
	ip_b := multiplex.:*=(isqrtdet_a,isqrtdet_c);
#	 [:*=](isqrtdet_a,isqrtdet_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations isqrtdet_e in parallel
#      {
#	{|
barrier	jp_b:= true;
	kp_b := multiplex.*(isqrtdet_e,isqrtdet_f);
	isqrtdet_e := access(kp_b,BAT_WRITE);
#	   isqrtdet_e := [*](isqrtdet_e,isqrtdet_f).access(BAT_WRITE);
	isqrtdet_g := multiplex.*(isqrtdet_g,isqrtdet_h);
#	   isqrtdet_g := [*](isqrtdet_g,isqrtdet_h);
end	jp_b;
#	 |}
	lp_b := multiplex.:*=(isqrtdet_e,isqrtdet_g);
#	 [:*=](isqrtdet_e,isqrtdet_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	fp_b;
#       |}
	mp_b := multiplex.:*=(isqrtdet_a,isqrtdet_e);
#       [:*=](isqrtdet_a,isqrtdet_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	isqrtdet := isqrtdet_a;
#    isqrtdet := isqrtdet_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1309 "../../../src/gmm/gmm.mx"
#
	isqrtdet := multiplex.sqrt(isqrtdet);
#  isqrtdet     := [sqrt](isqrtdet);
#  
##line 1227 "../../../src/gmm/gmm.mx"
#VAR xs;
#
##line 1224 "../../../src/gmm/gmm.mx"
#
##line 1240 "../../../src/gmm/gmm.mx"
	np_b := htype(coeffs);
	op_b := count(coeffs);
	xs := new(np_b,bat,op_b);
#  xs := new(coeffs.htype,bat,coeffs.count);
	xs_lock:= lock_create();
#  VAR xs_lock := lock_create();
	pp_b_cursor := 0:lng;
barrier	pp_b:= batloop(pp_b_cursor,Nthreads,pp_bH,pp_bT);
#  coeffs@ [Nthreads]batloop(){
	xIdx:= take("xIdx");
	_xs_result:= join(xIdx,pp_bT);
#    VAR _xs_result := join( xIdx, $t );
	qp_b := lock_set(xs_lock);
#    lock_set(xs_lock);
	rp_b := insert(xs,pp_bH,_xs_result);
#    xs.insert( $h, _xs_result );
	sp_b := lock_unset(xs_lock);
#    lock_unset(xs_lock);
redo	pp_b;
end	pp_b;
#  }
	tp_b := lock_destroy(xs_lock);
#  lock_destroy(xs_lock);
#
#
##line 1224 "../../../src/gmm/gmm.mx"
#
#
#
##line 1228 "../../../src/gmm/gmm.mx"
#
#
#
##line 1311 "../../../src/gmm/gmm.mx"
#
	up_b := find(gmm,"Mean");
	means:= multiplex.join(cIdx,up_b);
#  VAR means    := [join]( const cIdx, gmm.find("Mean") );
	ivars:= multiplex.join(cIdx,ivariances);
#  VAR ivars    := [join]( const cIdx, ivariances );
	diffs:= multiplex.nestedop("dmahalanobis_i_diagcov",xs,means,ivars);
#  VAR diffs    := [nestedop]("dmahalanobis_i_diagcov",xs,means,ivars);
#  
##line 130 "../../../src/gmm/gmm.mx"
#VAR dists;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	dists_a:= fetch(diffs,0);
	dists_e:= fetch(diffs,4);
#    VAR dists_a := diffs.fetch(0);    VAR dists_e := diffs.fetch(4);
	dists_b:= fetch(diffs,1);
	dists_f:= fetch(diffs,5);
#    VAR dists_b := diffs.fetch(1);    VAR dists_f := diffs.fetch(5);
	dists_c:= fetch(diffs,2);
	dists_g:= fetch(diffs,6);
#    VAR dists_c := diffs.fetch(2);    VAR dists_g := diffs.fetch(6);
	dists_d:= fetch(diffs,3);
	dists_h:= fetch(diffs,7);
#    VAR dists_d := diffs.fetch(3);    VAR dists_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations dists_a in parallel
#    {
#      {|
barrier	vp_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_a in parallel
#      {
#	{|
barrier	wp_b:= true;
	xp_b := multiplex.+(dists_a,dists_b);
	dists_a := access(xp_b,BAT_WRITE);
#	   dists_a := [+](dists_a,dists_b).access(BAT_WRITE);
	dists_c := multiplex.+(dists_c,dists_d);
#	   dists_c := [+](dists_c,dists_d);
end	wp_b;
#	 |}
	yp_b := multiplex.:+=(dists_a,dists_c);
#	 [:+=](dists_a,dists_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations dists_e in parallel
#      {
#	{|
barrier	aq_b:= true;
	bq_b := multiplex.+(dists_e,dists_f);
	dists_e := access(bq_b,BAT_WRITE);
#	   dists_e := [+](dists_e,dists_f).access(BAT_WRITE);
	dists_g := multiplex.+(dists_g,dists_h);
#	   dists_g := [+](dists_g,dists_h);
end	aq_b;
#	 |}
	cq_b := multiplex.:+=(dists_e,dists_g);
#	 [:+=](dists_e,dists_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	vp_b;
#       |}
	dq_b := multiplex.:+=(dists_a,dists_e);
#       [:+=](dists_a,dists_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	dists := dists_a;
#    dists := dists_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1315 "../../../src/gmm/gmm.mx"
#
	xs := nil;
#                  xs     := nil;
	diffs := nil;
#                  diffs  := nil;
	means := nil;
#		  means  := nil;
	ivars := nil;
#		  ivars  := nil;
	ivariances := nil;
#		  ivariances := nil;
	isdet:= join(cIdx,isqrtdet);
#  VAR isdet    := join( cIdx, isqrtdet );
	N:= take("N");
	act:= multiplex.multivariate_gaussian_pdf_diagcov(dists,isdet,N);
#  VAR act      := [multivariate_gaussian_pdf_diagcov]( dists, isdet, N );
	dists := nil;
#                  dists  := nil;
	isdet := nil;
#                  isdet  := nil;
#
#
##line 1331 "../../../src/gmm/gmm.mx"
#
	eq_b := find(gmm,"Prior");
	fq_b := multiplex.dbl(eq_b);
	priors:= join(cIdx,fq_b);
#  VAR priors   := join( cIdx, [dbl](gmm.find("Prior")) );
	act := multiplex.*(act,priors);
#  act          := [*]( act, priors );
	gq_b := reverse(xIdx);
	hq_b := join(gq_b,act);
	s:= pump.sum(hq_b);
#  VAR s        := {sum}( xIdx.reverse.join(act) );
##  s            := [ [>](s,const MIN_S)? s : const MIN_S ];
##  s            := [ [!=](s,const dbl(0))? s : const 1.0LL ];
	iq_b := multiplex.>(s,MIN_S);
	jq_b := M2m.ifthen(iq_b,s,1.0LL);
	kq_b:= M2m.batconstruct1(jq_b);
	s := kq_b;
#  s            := [ [>](s,const MIN_S)? s : const 1.0LL ];
	lq_b := join(xIdx,s);
	post:= multiplex./(act,lq_b);
#  VAR post     := [/](act,xIdx.join(s));
	priors := nil;
#                  priors := nil;
	act := nil;
#                  act    := nil;
#
#
##line 1839 "../../../src/gmm/gmm.mx"
#
	pmax:= fetch(post,0);
#    VAR pmax := post.fetch(0);
	mq_b := mirror(post);
	nq_b := fetch(mq_b,0);
	oq_b := encode(TCluster,nq_b);
	res:= project(pmax,oq_b);
#    VAR res  := pmax.project(const encode(TCluster, post.mirror.fetch(0)));
	pq_b_cursor := 0:lng;
barrier	pq_b:= batloop(pq_b_cursor,post,pq_bH,pq_bT);
#    post@batloop(){
	pcomp:= multiplex.<=(pq_bT,pmax);
#      VAR pcomp := [<=]($t,pmax);
	qq_b := encode(TCluster,pq_bH);
	rq_b := M2m.ifthen(pcomp,res,qq_b);
	sq_b:= M2m.batconstruct1(rq_b);
	res := sq_b;
#      res :=  [ pcomp ?  res : const encode(TCluster, $h) ];
	tq_b := M2m.ifthen(pcomp,pmax,pq_bT);
	uq_b:= M2m.batconstruct1(tq_b);
	pmax := uq_b;
#      pmax := [ pcomp ? pmax : $t ];
redo	pq_b;
end	pq_b;
#    }
	return res;
#    RETURN res;
end function;
#  }
#
#
##line 1853 "../../../src/gmm/gmm.mx"
function vectostr(x:bat[any,dbl]):str;
#  PROC vectostr( BAT[any,dbl] x ): str := {
	s:= "< ";
#    VAR s := "< ";
	vq_b := fetch(x,0);
	wq_b := sprintf("%4.0lf",vq_b);
	xq_b := :+=(s,wq_b);
#    s :+= sprintf( "%4.0lf", x.fetch(0) );
	yq_b := count(x);
	ar_b := -(yq_b,1);
	br_b := slice(x,1,ar_b);
	cr_b_cursor := 0:lng;
barrier	cr_b:= batloop(cr_b_cursor,br_b,cr_bH,cr_bT);
#    x.slice(1, x.count - 1)@batloop(){
	dr_b := sprintf(", %4.0lf",cr_bT);
	er_b := :+=(s,dr_b);
#      s :+= sprintf( ", %4.0lf", $t );
redo	cr_b;
end	cr_b;
#    }
	fr_b := :+=(s," >");
#    s :+= " >";
	return s;
#    RETURN s;
end function;
#  }
function vectostr(x:bat[any,flt]):str;
#  PROC vectostr( BAT[any,flt] x ): str := {
	s:= "< ";
#    VAR s := "< ";
	gr_b := fetch(x,0);
	hr_b := sprintf("%4.0f",gr_b);
	ir_b := :+=(s,hr_b);
#    s :+= sprintf( "%4.0f", x.fetch(0) );
	jr_b := count(x);
	kr_b := -(jr_b,1);
	lr_b := slice(x,1,kr_b);
	mr_b_cursor := 0:lng;
barrier	mr_b:= batloop(mr_b_cursor,lr_b,mr_bH,mr_bT);
#    x.slice(1, x.count - 1)@batloop(){
	nr_b := sprintf(", %4.0f",mr_bT);
	or_b := :+=(s,nr_b);
#      s :+= sprintf( ", %4.0f", $t );
redo	mr_b;
end	mr_b;
#    }
	pr_b := :+=(s," >");
#    s :+= " >";
	return s;
#    RETURN s;
end function;
#  }
#
#  CONST infosep :=
	infosep := "------------------------------------------------------------";
#    "------------------------------------------------------------";
function gmminfo(gmm:bat[str,bat]):bat[void,str];
#  PROC gmminfo( BAT[str,bat] gmm ): BAT[void,str] := {
	qr_b := oid(0);
	rr_b := new(void,str);
	s:= setSequenceBase(rr_b,qr_b);
#    VAR s := new(void,str).setSequenceBase(oid(0));
	sr_b := find(gmm,"mImgIdx");
	imgidx:= reverse(sr_b);
#    VAR imgidx := gmm.find("mImgIdx").reverse;
	oldimgid:= fetch(imgidx,0);
#    VAR oldimgid := imgidx.fetch(0);
	imgid:= oldimgid;
#    VAR imgid := oldimgid;
	tr_b := find(gmm,"mImgIdx");
	ur_b := kunique(tr_b);
	vr_b := sort(ur_b);
	wr_b_cursor := 0:lng;
barrier	wr_b:= batloop(wr_b_cursor,vr_b,wr_bH,wr_bT);
#    gmm.find("mImgIdx").kunique.sort@batloop(){
	imgid:= wr_bH;
#      VAR imgid := $h;
	xr_b := sprintf("-- Img %3d --",imgid);
	yr_b := +(xr_b,infosep);
	as_b := insert(s,nil,yr_b);
#      s.insert( nil, sprintf("-- Img %3d --", imgid) + infosep );
#
	bs_b := select(imgidx,wr_bH);
	cs_b := find(gmm,"mCIdx");
	ds_b := reverse(cs_b);
	es_b := mirror(bs_b);
	fs_b := join(es_b,ds_b);
	gs_b := reverse(fs_b);
	hs_b := sort(gs_b);
	is_b_cursor := 0:lng;
barrier	is_b:= batloop(is_b_cursor,hs_b,is_bH,is_bT);
#      imgidx.select($h).mirror.join(gmm.find("mCIdx").reverse).reverse.sort@batloop(){
	js_b := find(gmm,"Prior");
	ks_b := find(js_b,is_bT);
	ls_b := dbl(ks_b);
#	s.insert( nil, sprintf( "prior[%d]: %.3lf\t", $h, dbl(find(gmm.find("Prior"), $t)) ) +
	ms_b := find(gmm,"Mean");
	ns_b := multiplex.find(ms_b,is_bT);
	os_b := vectostr(ns_b);
	ps_b := sprintf("prior[%d]: %.3lf\t",is_bH,ls_b);
	qs_b := +("mean:  ",os_b);
	rs_b := +(ps_b,qs_b);
	ss_b := insert(s,nil,rs_b);
#		       "mean:  " + vectostr([find](gmm.find("Mean" ),$t)) );
	ts_b := find(gmm,"Covar");
	us_b := multiplex.find(ts_b,is_bT);
	vs_b := vectostr(us_b);
	ws_b := +("            \tcovar: ",vs_b);
	xs_b := insert(s,nil,ws_b);
#	s.insert( nil, "            \tcovar: " +vectostr([find](gmm.find("Covar"),$t)) );
redo	is_b;
end	is_b;
#      }
redo	wr_b;
end	wr_b;
#    }
	ys_b := +("-------------",infosep);
	at_b := insert(s,nil,ys_b);
#    s.insert( nil, "-------------" + infosep );
	return s;
#    RETURN s;
end function;
#  }
#
function printmodel(gmm:bat[str,bat]):void;
#  PROC printmodel( BAT[str,bat] gmm ): void := {
	g:= gmminfo(gmm);
#    VAR g := gmminfo(gmm);
	bt_b := project(g,"%s\n");
	ct_b := multiplex.printf(bt_b,g);
#    [printf]( g.project("%s\n"), g );
end function;
#  }
function printmodels(gmma:bat[str,bat], gmmb:bat[str,bat]):void;
#  PROC printmodels( BAT[str,bat] gmma, BAT[str,bat] gmmb ): void := {
	ga:= gmminfo(gmma);
#    VAR ga := gmminfo(gmma);
	gb:= gmminfo(gmmb);
#    VAR gb := gmminfo(gmmb);
	dt_b := multiplex.printf("%s\t|\t%s\n",ga,gb);
#    [printf]( const "%s\t|\t%s\n", ga, gb );
end function;
#  }
#
##  printmodels( testmodels.find("src"), 
##               testmodels.find("final") );
#
#
##line 1909 "../../../src/gmm/gmm.mx"
function sampleQueries(Nqimg:int, testmodels:bat[str,bat]):bat[str,bat];
#  PROC sampleQueries(int Nqimg, BAT[str,bat] testmodels):bat[str,bat] := {
	qgmm:= new(str,bat);
#    VAR qgmm := new(str,bat);
#    {
	gmm:= find(testmodels,"src");
#      VAR gmm   := testmodels.find("src");
	et_b := find(testmodels,"coll");
	ft_b := find(et_b,"I");
	qimgs:= sample(ft_b,Nqimg);
#      VAR qimgs := testmodels.find("coll").find("I").sample(Nqimg);
	gt_b := mirror(qimgs);
	ht_b := find(gmm,"mImgIdx");
	qimgidx:= join(gt_b,ht_b);
#      VAR qimgidx := join(qimgs.mirror, gmm.find("mImgIdx"));
#      
##line 634 "../../../src/gmm/gmm.mx"
	it_b := oid(0);
	jt_b := reverse(qimgidx);
	kt_b := mark(jt_b,it_b);
	fIdx:= reverse(kt_b);
#VAR fIdx           := qimgidx.reverse.mark(oid(0)).reverse;
#{
	lt_b := find(gmm,"mImgIdx");
	mt_b := reverse(lt_b);
	convImgIdx:= join(fIdx,mt_b);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	nt_b := find(gmm,"mCIdx");
	ot_b := reverse(nt_b);
	convCIdx:= join(fIdx,ot_b);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
	pt_b := reverse(convImgIdx);
	qt_b := insert(qgmm,"mImgIdx",pt_b);
#  qgmm.insert( "mImgIdx", convImgIdx.reverse );
	rt_b := reverse(convCIdx);
	st_b := insert(qgmm,"mCIdx",rt_b);
#  qgmm.insert( "mCIdx",   convCIdx.reverse );
#
	tt_b := find(gmm,"Prior");
	ut_b := join(fIdx,tt_b);
	vt_b := insert(qgmm,"Prior",ut_b);
#  qgmm.insert( "Prior", join(fIdx, gmm.find("Prior")) );
	wt_b := find(gmm,"Mean");
	xt_b := multiplex.join(fIdx,wt_b);
	yt_b := insert(qgmm,"Mean",xt_b);
#  qgmm.insert( "Mean",  [join](const fIdx, gmm.find("Mean")) );
	au_b := find(gmm,"Covar");
	bu_b := multiplex.join(fIdx,au_b);
	cu_b := insert(qgmm,"Covar",bu_b);
#  qgmm.insert( "Covar", [join](const fIdx, gmm.find("Covar")) );
#
	du_b := find(gmm,"init_variances");
	eu_b := join(fIdx,du_b);
	fu_b := insert(qgmm,"init_variances",eu_b);
#  qgmm.insert( "init_variances", join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 1915 "../../../src/gmm/gmm.mx"
#
	sessionId:= take("sessionId");
	gu_b := +(sessionId,"_query");
	hu_b := +("gmm",gu_b);
	iu_b := renameGMM(qgmm,hu_b);
#      renameGMM(qgmm,"gmm" + sessionId + "_query");
#      
##line 655 "../../../src/gmm/gmm.mx"
	ju_b := find(qgmm,"init_variances");
	BAT_READ:= take("BAT_READ");
	ku_b := access(ju_b,BAT_READ);
#  access( qgmm.find("init_variances"), BAT_READ );
	lu_b := find(qgmm,"Prior");
	mu_b := access(lu_b,BAT_READ);
#  access( qgmm.find("Prior"), BAT_READ );
	nu_b := find(qgmm,"mImgIdx");
	ou_b := access(nu_b,BAT_READ);
#  access( qgmm.find("mImgIdx"), BAT_READ );
	pu_b := find(qgmm,"mCIdx");
	qu_b := access(pu_b,BAT_READ);
#  access( qgmm.find("mCIdx"), BAT_READ );
	ru_b := find(qgmm,"Mean");
	su_b_cursor := 0:lng;
barrier	su_b:= batloop(su_b_cursor,ru_b,su_bH,su_bT);
	tu_b := access(su_bT,BAT_READ);
redo	su_b;
end	su_b;
#  qgmm.find("Mean")@batloop{  access($t, BAT_READ); }
	uu_b := find(qgmm,"Covar");
	vu_b_cursor := 0:lng;
barrier	vu_b:= batloop(vu_b_cursor,uu_b,vu_bH,vu_bT);
	wu_b := access(vu_bT,BAT_READ);
redo	vu_b;
end	vu_b;
#  qgmm.find("Covar")@batloop{ access($t, BAT_READ); }
#
#
##line 1917 "../../../src/gmm/gmm.mx"
#
#    }
	return qgmm;
#    RETURN qgmm;
end function;
#  }
#
#
##line 1926 "../../../src/gmm/gmm.mx"
#  # VAR gmm_q := sampleQueries(4,testmodels);
#  # VAR gmm_i := testmodels.find("final");
#
function RSL(gmm_q:bat[str,bat], gmm_i:bat[str,bat]):void;
#  PROC RSL( bat[str,bat] gmm_q, bat[str,bat] gmm_i ):void := {
	xu_b := find(gmm_q,"mCIdx");
	yu_b := reverse(xu_b);
	av_b := find(gmm_i,"mCIdx");
	cqciIdx:= join(yu_b,av_b);
#    VAR cqciIdx     := join(gmm_q.find("mCIdx").reverse, gmm_i.find("mCIdx"));
	ciIdx:= nx(cqciIdx);
#    VAR ciIdx	    := nx(cqciIdx);
	bv_b := xn(cqciIdx);
	cqIdx:= reverse(bv_b);
#    VAR cqIdx	    := xn(cqciIdx).reverse;
#
	cv_b := find(gmm_q,"mImgIdx");
	dv_b := reverse(cv_b);
#    VAR gqiIdx      := join(gmm_q.find("mImgIdx").reverse, 
	ev_b := find(gmm_q,"mImgIdx");
	fv_b := reverse(cqIdx);
	gv_b := join(ev_b,fv_b);
	gqiIdx:= join(dv_b,gv_b);
#			 join(gmm_q.find("mImgIdx"), cqIdx.reverse));
	giIdx:= nx(gqiIdx);
#    VAR giIdx       := nx(gqiIdx);
#
	qiIdx:= join(gqiIdx,ciIdx);
#    VAR qiIdx       := join(gqiIdx, ciIdx);
	hv_b := xn(qiIdx);
	qIdx:= reverse(hv_b);
#    VAR qIdx        := xn(qiIdx).reverse;
	iIdx:= nx(qiIdx);
#    VAR iIdx        := nx(qiIdx);
#
#
##line 1944 "../../../src/gmm/gmm.mx"
	iv_b := find(gmm_i,"Prior");
	logpriors_i:= multiplex.log(iv_b);
#    VAR logpriors_i := [log](gmm_i.find("Prior"));
	covar_i:= find(gmm_i,"Covar");
#    VAR covar_i     := gmm_i.find("Covar");
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR det_i;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	det_i_a:= fetch(covar_i,0);
	det_i_e:= fetch(covar_i,4);
#    VAR det_i_a := covar_i.fetch(0);    VAR det_i_e := covar_i.fetch(4);
	det_i_b:= fetch(covar_i,1);
	det_i_f:= fetch(covar_i,5);
#    VAR det_i_b := covar_i.fetch(1);    VAR det_i_f := covar_i.fetch(5);
	det_i_c:= fetch(covar_i,2);
	det_i_g:= fetch(covar_i,6);
#    VAR det_i_c := covar_i.fetch(2);    VAR det_i_g := covar_i.fetch(6);
	det_i_d:= fetch(covar_i,3);
	det_i_h:= fetch(covar_i,7);
#    VAR det_i_d := covar_i.fetch(3);    VAR det_i_h := covar_i.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations det_i_a in parallel
#    {
#      {|
barrier	jv_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations det_i_a in parallel
#      {
#	{|
barrier	kv_b:= true;
	BAT_WRITE:= take("BAT_WRITE");
	lv_b := multiplex.*(det_i_a,det_i_b);
	det_i_a := access(lv_b,BAT_WRITE);
#	   det_i_a := [*](det_i_a,det_i_b).access(BAT_WRITE);
	det_i_c := multiplex.*(det_i_c,det_i_d);
#	   det_i_c := [*](det_i_c,det_i_d);
end	kv_b;
#	 |}
	mv_b := multiplex.:*=(det_i_a,det_i_c);
#	 [:*=](det_i_a,det_i_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations det_i_e in parallel
#      {
#	{|
barrier	nv_b:= true;
	ov_b := multiplex.*(det_i_e,det_i_f);
	det_i_e := access(ov_b,BAT_WRITE);
#	   det_i_e := [*](det_i_e,det_i_f).access(BAT_WRITE);
	det_i_g := multiplex.*(det_i_g,det_i_h);
#	   det_i_g := [*](det_i_g,det_i_h);
end	nv_b;
#	 |}
	pv_b := multiplex.:*=(det_i_e,det_i_g);
#	 [:*=](det_i_e,det_i_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	jv_b;
#       |}
	qv_b := multiplex.:*=(det_i_a,det_i_e);
#       [:*=](det_i_a,det_i_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	det_i := det_i_a;
#    det_i := det_i_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1946 "../../../src/gmm/gmm.mx"
#
	logdet_i:= multiplex.log(det_i);
#    VAR logdet_i    := [log](det_i);
	ivars_i:= multiplex.nestedop("inv",covar_i);
#    VAR ivars_i     := [nestedop]("inv",covar_i);
#
#
##line 1955 "../../../src/gmm/gmm.mx"
	qivars_i:= multiplex.join(iIdx,ivars_i);
#    VAR qivars_i    := [join](const iIdx, ivars_i);
	covar_q:= find(gmm_q,"Covar");
#    VAR covar_q     := gmm_q.find("Covar");
	qvars_q:= multiplex.join(qIdx,covar_q);
#    VAR qvars_q     := [join](const qIdx, covar_q);
	tmp:= multiplex.nestedop("*",qvars_q,qivars_i);
#    VAR tmp         := [nestedop]("*", qvars_q, qivars_i);
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR traces;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	traces_a:= fetch(tmp,0);
	traces_e:= fetch(tmp,4);
#    VAR traces_a := tmp.fetch(0);    VAR traces_e := tmp.fetch(4);
	traces_b:= fetch(tmp,1);
	traces_f:= fetch(tmp,5);
#    VAR traces_b := tmp.fetch(1);    VAR traces_f := tmp.fetch(5);
	traces_c:= fetch(tmp,2);
	traces_g:= fetch(tmp,6);
#    VAR traces_c := tmp.fetch(2);    VAR traces_g := tmp.fetch(6);
	traces_d:= fetch(tmp,3);
	traces_h:= fetch(tmp,7);
#    VAR traces_d := tmp.fetch(3);    VAR traces_h := tmp.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations traces_a in parallel
#    {
#      {|
barrier	rv_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations traces_a in parallel
#      {
#	{|
barrier	sv_b:= true;
	tv_b := multiplex.+(traces_a,traces_b);
	traces_a := access(tv_b,BAT_WRITE);
#	   traces_a := [+](traces_a,traces_b).access(BAT_WRITE);
	traces_c := multiplex.+(traces_c,traces_d);
#	   traces_c := [+](traces_c,traces_d);
end	sv_b;
#	 |}
	uv_b := multiplex.:+=(traces_a,traces_c);
#	 [:+=](traces_a,traces_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations traces_e in parallel
#      {
#	{|
barrier	vv_b:= true;
	wv_b := multiplex.+(traces_e,traces_f);
	traces_e := access(wv_b,BAT_WRITE);
#	   traces_e := [+](traces_e,traces_f).access(BAT_WRITE);
	traces_g := multiplex.+(traces_g,traces_h);
#	   traces_g := [+](traces_g,traces_h);
end	vv_b;
#	 |}
	xv_b := multiplex.:+=(traces_e,traces_g);
#	 [:+=](traces_e,traces_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	rv_b;
#       |}
	yv_b := multiplex.:+=(traces_a,traces_e);
#       [:+=](traces_a,traces_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	traces := traces_a;
#    traces := traces_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1959 "../../../src/gmm/gmm.mx"
#
#
#
##line 1966 "../../../src/gmm/gmm.mx"
	aw_b := find(gmm_q,"Mean");
	qmeanq:= multiplex.join(qIdx,aw_b);
#    VAR qmeanq      := [join](const qIdx, gmm_q.find("Mean"));
	bw_b := find(gmm_i,"Mean");
	qmeani:= multiplex.join(iIdx,bw_b);
#    VAR qmeani	    := [join](const iIdx, gmm_i.find("Mean"));
	diffs:= multiplex.nestedop("-",qmeanq,qmeani);
#    VAR diffs       := [nestedop]("-", qmeanq, qmeani);
	diffs := multiplex.square(diffs);
#    diffs           := [square]( diffs );
	diffs := multiplex.nestedop("*",diffs,qivars_i);
#    diffs	    := [nestedop]("*", diffs, qivars_i);
#    
##line 130 "../../../src/gmm/gmm.mx"
#VAR Dmaha;
#
##line 127 "../../../src/gmm/gmm.mx"
#
##line 167 "../../../src/gmm/gmm.mx"
#  {
	Dmaha_a:= fetch(diffs,0);
	Dmaha_e:= fetch(diffs,4);
#    VAR Dmaha_a := diffs.fetch(0);    VAR Dmaha_e := diffs.fetch(4);
	Dmaha_b:= fetch(diffs,1);
	Dmaha_f:= fetch(diffs,5);
#    VAR Dmaha_b := diffs.fetch(1);    VAR Dmaha_f := diffs.fetch(5);
	Dmaha_c:= fetch(diffs,2);
	Dmaha_g:= fetch(diffs,6);
#    VAR Dmaha_c := diffs.fetch(2);    VAR Dmaha_g := diffs.fetch(6);
	Dmaha_d:= fetch(diffs,3);
	Dmaha_h:= fetch(diffs,7);
#    VAR Dmaha_d := diffs.fetch(3);    VAR Dmaha_h := diffs.fetch(7);
#    
##line 157 "../../../src/gmm/gmm.mx"
#    # perform four operations Dmaha_a in parallel
#    {
#      {|
barrier	cw_b:= true;
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations Dmaha_a in parallel
#      {
#	{|
barrier	dw_b:= true;
	ew_b := multiplex.+(Dmaha_a,Dmaha_b);
	Dmaha_a := access(ew_b,BAT_WRITE);
#	   Dmaha_a := [+](Dmaha_a,Dmaha_b).access(BAT_WRITE);
	Dmaha_c := multiplex.+(Dmaha_c,Dmaha_d);
#	   Dmaha_c := [+](Dmaha_c,Dmaha_d);
end	dw_b;
#	 |}
	fw_b := multiplex.:+=(Dmaha_a,Dmaha_c);
#	 [:+=](Dmaha_a,Dmaha_c);
#      }
#
#
##line 160 "../../../src/gmm/gmm.mx"
#
#	
##line 147 "../../../src/gmm/gmm.mx"
#      # perform two operations Dmaha_e in parallel
#      {
#	{|
barrier	gw_b:= true;
	hw_b := multiplex.+(Dmaha_e,Dmaha_f);
	Dmaha_e := access(hw_b,BAT_WRITE);
#	   Dmaha_e := [+](Dmaha_e,Dmaha_f).access(BAT_WRITE);
	Dmaha_g := multiplex.+(Dmaha_g,Dmaha_h);
#	   Dmaha_g := [+](Dmaha_g,Dmaha_h);
end	gw_b;
#	 |}
	iw_b := multiplex.:+=(Dmaha_e,Dmaha_g);
#	 [:+=](Dmaha_e,Dmaha_g);
#      }
#
#
##line 161 "../../../src/gmm/gmm.mx"
#
end	cw_b;
#       |}
	jw_b := multiplex.:+=(Dmaha_a,Dmaha_e);
#       [:+=](Dmaha_a,Dmaha_e);      
#    }
#
#
##line 172 "../../../src/gmm/gmm.mx"
#
	Dmaha := Dmaha_a;
#    Dmaha := Dmaha_a;
#  }
#
#
##line 127 "../../../src/gmm/gmm.mx"
#
#
#
##line 131 "../../../src/gmm/gmm.mx"
#
#
#
##line 1971 "../../../src/gmm/gmm.mx"
#
#
	tmp:= multiplex.+(Dmaha,traces);
#    VAR tmp         := [+](Dmaha,traces);
	kw_b := join(iIdx,logdet_i);
	tmp := multiplex.+(kw_b,tmp);
#    tmp             := [+](iIdx.join(logdet_i), tmp);
	lw_b := join(iIdx,logpriors_i);
	compiL:= multiplex.-(lw_b,tmp);
#    VAR compiL	    := [-](iIdx.join(logpriors_i), tmp);
	mw_b := reverse(giIdx);
	nw_b := join(mw_b,compiL);
	maxcompiL:= pump.max(nw_b);
#    VAR maxcompiL   := {max}(giIdx.reverse.join(compiL));
#
	ow_b := find(gmm_q,"Prior");
	pw_b := join(cqIdx,ow_b);
	compqL:= multiplex.*(pw_b,maxcompiL);
#    VAR compqL	    := [*](join(cqIdx,gmm_q.find("Prior")), maxcompiL);
#
#
##line 1983 "../../../src/gmm/gmm.mx"
	qw_b := find(gmm_q,"mImgIdx");
	rw_b := reverse(qw_b);
	imgidx_q:= join(cqIdx,rw_b);
#    VAR imgidx_q    := join( cqIdx, gmm_q.find("mImgIdx").reverse);
	sw_b := find(gmm_i,"mImgIdx");
	tw_b := reverse(sw_b);
	imgidx_i:= join(ciIdx,tw_b);
#    VAR imgidx_i    := join( ciIdx, gmm_i.find("mImgIdx").reverse);
	gimgidx_q:= CTgroup(imgidx_q);
#    VAR gimgidx_q   := CTgroup(imgidx_q);
	gimgidx_i:= CTgroup(gimgidx_q,imgidx_i);
#    VAR gimgidx_i   := CTgroup(gimgidx_q, imgidx_i);
#   
	uw_b := reverse(gimgidx_i);
	vw_b := join(uw_b,compqL);
	RSL:= pump.sum(vw_b);
#    VAR RSL         := {sum}(join( gimgidx_i.reverse, compqL));
#
	ww_b := debug("Results ranked");
#debug("Results ranked");
##      VAR printres  := new(void,str);
##      printres.insert(nil, sprintf( "%3s %3s  %8s\n", "Q", "I", "RSL(Q,I)" ));
##      printres.insert(nil, sprintf( "================\n" ));
##      printres.insert([sprintf]( const "%3d,%3d,%8.lf\n", imgidx_q,imgidx_i, RSL));
##      printres@batloop(){printf("%s",$t);}
#
##    VAR minRSL      := {min}(join(gimgidx_q.reverse, RSL));
end function;
#}
#
#
#
##line 2009 "../../../src/gmm/gmm.mx"
function L2dist(x:bat[any::1,dbl], y:bat[any::1,dbl]):dbl;
#  PROC L2dist( BAT[any::1,dbl] x, BAT[any::1,dbl] y ): dbl := {
	dist:= multiplex.-(x,y);
#    VAR dist := [-](x, y);
	dist := multiplex.*(dist,dist);
#    dist := [*](dist, dist);
	xw_b := sum(dist);
	yw_b := count(dist);
	dist := /(xw_b,yw_b);
#    dist := dist.sum / dist.count;
	return dist;
#    RETURN dist;
end function;
#  }
#
#  # this is really a fitness-join
function mapnearest(ma:bat[int,bat], mb:bat[int,bat]):bat[int,int];
#  PROC mapnearest( BAT[int,bat] ma, BAT[int,bat] mb ): BAT[int,int] := {
	TCluster:= take("TCluster");
	C:= take("C");
	cdist:= new(TCluster,bat,C);
#    VAR cdist := new(TCluster,bat,C);
	cseq:= take("cseq");
	ax_b_cursor := 0:lng;
barrier	ax_b:= batloop(ax_b_cursor,cseq,ax_bH,ax_bT);
#    cseq@batloop(){
	csrcoid:= ax_bH;
#      VAR csrcoid := $h;
	csrc:= ax_bT;
#      VAR csrc := $t;
	cdist_c:= new(TCluster,dbl);
#      VAR cdist_c := new(TCluster,dbl);
	bx_b_cursor := 0:lng;
barrier	bx_b:= batloop(bx_b_cursor,cseq,bx_bH,bx_bT);
#      cseq@batloop(){
	cnewoid:= bx_bH;
#        VAR cnewoid := $h;
	cnew:= bx_bT;
#	VAR cnew := $t;
#	cdist_c.insert( cnew, 
	cx_b := multiplex.find(ma,csrcoid);
#	  L2dist( [find](ma,csrcoid), 
	dx_b := multiplex.find(mb,cnewoid);
	ex_b := L2dist(cx_b,dx_b);
	fx_b := insert(cdist_c,cnew,ex_b);
#		[find](mb,cnewoid) ) ); 
redo	bx_b;
end	bx_b;
#      }
	gx_b := reverse(cdist_c);
	hx_b := order(gx_b);
	ix_b := insert(cdist,csrc,hx_b);
#      cdist.insert( csrc, cdist_c.reverse.order );
redo	ax_b;
end	ax_b;
#    }
	jx_b := multiplex.fetch(cdist,0);
	return jx_b;
#    RETURN [fetch](cdist, const 0);
end function;
#  }
#
function testclassify(src_gmm:bat[str,bat], gmmnew:bat[str,bat]):void;
#  PROC testclassify( BAT[str,bat] src_gmm, BAT[str,bat] gmmnew ): void := {
	sampleImg:= take("sampleImg");
	kx_b := find(sampleImg,"Samples");
	c:= classify(kx_b,gmmnew);
#    VAR c := classify( sampleImg.find("Samples"), gmmnew );
	lx_b := find(sampleImg,"Clusters");
	mx_b := diff(c,lx_b);
	Nerr:= count(mx_b);
#    VAR Nerr := diff(c, sampleImg.find("Clusters")).count;
#
	Nerrmap:= Nerr;
#    VAR Nerrmap := Nerr;
#      # don't know setoriented solution yet
#      #  VAR cmap := mapnearest( src_gmm.find("Mean"), gmmnew.find("Mean") );
#      #  VAR Nerrmap := diff(c.join(cmap.reverse),sampleImg.find("Clusters")).count;
	nx_b := "Estimated # misclassified blocks: %4d (raw: %4d)\n";
	ox_b := printf(nx_b,Nerrmap,Nerr);
#    printf("Estimated # misclassified blocks: %4d (raw: %4d)\n", Nerrmap, Nerr);
end function;
#  }
#
#  # testclassify(src_gmm, gmmnew);
#
#
##line 2052 "../../../src/gmm/gmm.mx"
function dmahalanobis(x:bat[void,dbl], mu:dbl, variance:dbl):bat[void,dbl];
#  PROC dmahalanobis( BAT[void,dbl] x, dbl mu, dbl variance ): BAT[void,dbl] := {
	dist:= multiplex.-(x,mu);
#    VAR dist := [-](x, const mu);
	dist := multiplex.*(dist,dist);
#    dist := [*](dist, dist);
	dist := multiplex./(dist,variance);
#    dist := [/]( dist, const variance );
	return dist;
#    RETURN dist;
end function;
#  }
#
function mvgpdf(d:bat[void,dbl], det:dbl, Ndim:int):bat[void,dbl];
#  PROC mvgpdf( BAT[void,dbl] d, dbl det, int Ndim ): BAT[void,dbl] := {
	M_PI:= take("M_PI");
	px_b := *(2,M_PI);
	qx_b := dbl(Ndim);
	rx_b := /(qx_b,2);
	sx_b := pow(px_b,rx_b);
	tx_b := sqrt(det);
	ux_b := *(sx_b,tx_b);
	norm:= /(1,ux_b);
#    VAR norm := 1/(pow((2*M_PI), dbl(Ndim)/2) * sqrt(det) );
	vx_b := multiplex.*(d,-0.5LL);
	p:= multiplex.exp(vx_b);
#    VAR p := [exp]( [*]( d, -0.5LL ) );
	wx_b := multiplex.*(p,norm);
	return wx_b;
#    RETURN [*]( p, const norm );
end function;
#  }
#
function test():void;
#  PROC test():void := {
	xx_b := debug("Testing...");
#    debug( "Testing..." );
#
#
##line 2070 "../../../src/gmm/gmm.mx"
	mu:= new(int,dbl);
#    VAR mu := new( int, dbl );
	mu_1:= take("mu_1");
	yx_b := insert(mu,1,mu_1);
#    mu.insert( 1, mu_1 );
	mu_2:= take("mu_2");
	ay_b := insert(mu,2,mu_2);
#    mu.insert( 2, mu_2 );
#    # ...
	sigma:= new(int,dbl);
#    VAR sigma := new( int, dbl );
	sigma_1:= take("sigma_1");
	by_b := insert(sigma,1,sigma_1);
#    sigma.insert( 1, sigma_1 );
	sigma_2:= take("sigma_2");
	cy_b := insert(sigma,2,sigma_2);
#    sigma.insert( 2, sigma_2 );
#    # ...
#
#
##line 2081 "../../../src/gmm/gmm.mx"
	covar:= multiplex.*(sigma,sigma);
#    VAR covar := [*]( sigma, sigma );
	det:= prod(covar);
#    VAR det := prod( covar );
	dy_b := "Determinant: %lf (%lf)\n";
	ey_b := *(sigma_2,sigma_2);
	fy_b := *(sigma_1,ey_b);
	gy_b := *(sigma_1,fy_b);
	hy_b := printf(dy_b,det,gy_b);
#    printf( "Determinant: %lf (%lf)\n", det, sigma_1 * sigma_1 * sigma_2 * sigma_2 );
#
#
##line 2087 "../../../src/gmm/gmm.mx"
	iy_b := oid(0);
	jy_b := new(void,dbl);
	x_1:= setSequenceBase(jy_b,iy_b);
#    VAR x_1 := new( void, dbl ).setSequenceBase(oid(0));
	ky_b := oid(0);
	ly_b := new(void,dbl);
	x_2:= setSequenceBase(ly_b,ky_b);
#    VAR x_2 := new( void, dbl ).setSequenceBase(oid(0));
#    # ...
	i:= 0;
#    VAR i := 0;
barrier	my_b:= true;
	Nsamples:= take("Nsamples");
	oy_b := <(i,Nsamples);
barrier	ny_b:= oy_b;
#    WHILE (i < Nsamples) {
	py_b := ran_gaussian(mu_1,sigma_1);
	qy_b := insert(x_1,nil,py_b);
#      x_1.insert( nil, ran_gaussian(mu_1,sigma_1) );
	ry_b := ran_gaussian(mu_2,sigma_2);
	sy_b := insert(x_2,nil,ry_b);
#      x_2.insert( nil, ran_gaussian(mu_2,sigma_2) );
#      # ...
	ty_b := :+=(i,1);
#      i :+= 1;
redo	my_b;
end	ny_b;
end	my_b;
#    }
#
#
##line 2100 "../../../src/gmm/gmm.mx"
	uy_b := find(mu,1);
	vy_b := find(covar,1);
	dist_1:= multiplex.dmahalanobis_i_diagcov(x_1,uy_b,vy_b);
#    VAR dist_1 := [dmahalanobis_i_diagcov]( x_1, mu.find(1), covar.find(1) );
	wy_b := find(mu,2);
	xy_b := find(covar,2);
	dist_2:= multiplex.dmahalanobis_i_diagcov(x_2,wy_b,xy_b);
#    VAR dist_2 := [dmahalanobis_i_diagcov]( x_2, mu.find(2), covar.find(2) );
#    # ...
	dist:= multiplex.+(dist_1,dist_2);
#    VAR dist := [+]( dist_1, dist_2 ); # ...
#
#
##line 2108 "../../../src/gmm/gmm.mx"
	p:= multiplex.multivariate_gaussian_pdf_diagcov(dist,det,2);
#    VAR p := [multivariate_gaussian_pdf_diagcov]( dist, det, 2 );
#    # print( x_1, x_2, p );
#
#
#
##line 2114 "../../../src/gmm/gmm.mx"
	yy_b := find(mu,1);
	aa_c := find(covar,1);
	ba_c := dmahalanobis(x_1,yy_b,aa_c);
	thediff:= multiplex.-(ba_c,dist_1);
#    VAR thediff := [-]( dmahalanobis(x_1, mu.find(1), covar.find(1) ), dist_1 );
	ca_c := find(mu,2);
	da_c := find(covar,2);
	ea_c := dmahalanobis(x_2,ca_c,da_c);
	fa_c := multiplex.-(ea_c,dist_2);
	thediff := multiplex.+(thediff,fa_c);
#    thediff := [+]( thediff, [-]( dmahalanobis(x_2, mu.find(2), covar.find(2) ), dist_2 ) );
	ga_c := sum(thediff);
barrier	ha_c:= >(ga_c,1e-10LL);
#    IF ( thediff.sum > 1e-10LL ) {
	ia_c := "!ERROR: difference in Mahalanobis distances (%lf)!\n";
	ja_c := sum(thediff);
	ka_c := printf(ia_c,ja_c);
#      printf( "!ERROR: difference in Mahalanobis distances (%lf)!\n", thediff.sum );
end	ha_c;
barrier	la_c:= not(ha_c);
	ma_c := printf("Mahalanobis distances ok.\n");
end	la_c;
#    } ELSE printf( "Mahalanobis distances ok.\n" );
	na_c := mvgpdf(dist,det,2);
	thediff := multiplex.-(na_c,p);
#    thediff := [-]( mvgpdf( dist, det, 2 ), p );
	oa_c := sum(thediff);
barrier	pa_c:= >(oa_c,1e-10LL);
#    IF ( thediff.sum > 1e-10LL ) {
	qa_c := "!ERROR: difference in probabilities (%lf)!\n";
	ra_c := sum(thediff);
	sa_c := printf(qa_c,ra_c);
#      printf( "!ERROR: difference in probabilities (%lf)!\n", thediff.sum );
end	pa_c;
barrier	ta_c:= not(pa_c);
	ua_c := printf("Probabilities ok.\n");
end	ta_c;
#    } ELSE printf( "Probabilities ok.\n" );
end function;
#  }
#
#
#
##line 2127 "../../../src/gmm/gmm.mx"
	coeffs:= take("coeffs");
	coeffs := nil;
#  coeffs := nil;
	mImgIdx:= take("mImgIdx");
	mImgIdx := nil;
#  mImgIdx := nil;
	mCIdx:= take("mCIdx");
	mCIdx := nil;
#  mCIdx := nil;
#
##  gmm := nil;
##  gmmnew := nil;
#
	commit:= take("commit");
#  commit;
#
#
#
##line 2140 "../../../src/gmm/gmm.mx"
#
	fragsize := 64;
#  CONST fragsize := 64;
	imgFrameNr:= take("imgFrameNr");
	Nimg:= count(imgFrameNr);
#  VAR Nimg := imgFrameNr.count;
	s_tdict:= take("s_tdict");
	collidx:= reverse(s_tdict);
#  VAR collidx := s_tdict.reverse;
#
#  
##line 2224 "../../../src/gmm/gmm.mx"
#  VAR tmBatIds, tmBatIds_Mean, tmBatIds_Covar;
#
#
##line 2145 "../../../src/gmm/gmm.mx"
#
	view_bbp_name:= take("view_bbp_name");
	va_c := multiplex.startsWith(view_bbp_name,"gmm_trained");
	wa_c := uselect(va_c,1);
	xa_c := count(wa_c);
barrier	ya_c:= >(xa_c,0);
#  IF ([startsWith](view_bbp_name,"gmm_trained").uselect(true).count > 0) {
#    
##line 2229 "../../../src/gmm/gmm.mx"
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2229 "../../../src/gmm/gmm.mx"
#
	ab_c := +("gmm_trained","_Prior");
	bb_c := reverse(view_bbp_name);
barrier	cb_c:= exist(bb_c,ab_c);
	db_c := +("gmm_trained","_Prior");
	eb_c := insert(tmBatIds,"Prior",db_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_Prior"))   tmBatIds.insert("Prior",   "gmm_trained"+"_Prior");
end	cb_c;
	fb_c := +("gmm_trained","_mCIdx");
	gb_c := reverse(view_bbp_name);
barrier	hb_c:= exist(gb_c,fb_c);
	ib_c := +("gmm_trained","_mCIdx");
	jb_c := insert(tmBatIds,"mCIdx",ib_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_mCIdx"))   tmBatIds.insert("mCIdx",   "gmm_trained"+"_mCIdx");
end	hb_c;
	kb_c := +("gmm_trained","_mImgIdx");
	lb_c := reverse(view_bbp_name);
barrier	mb_c:= exist(lb_c,kb_c);
	nb_c := +("gmm_trained","_mImgIdx");
	ob_c := insert(tmBatIds,"mImgIdx",nb_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_mImgIdx")) tmBatIds.insert("mImgIdx", "gmm_trained"+"_mImgIdx");
end	mb_c;
	pb_c := +("gmm_trained","_init_variances");
	qb_c := reverse(view_bbp_name);
barrier	rb_c:= exist(qb_c,pb_c);
#  IF (view_bbp_name.reverse.exist("gmm_trained"+"_init_variances")) 
	sb_c := +("gmm_trained","_init_variances");
	tb_c := insert(tmBatIds,"init_variances",sb_c);
#    tmBatIds.insert("init_variances", "gmm_trained"+"_init_variances");
end	rb_c;
	nseq:= take("nseq");
	ub_c_cursor := 0:lng;
barrier	ub_c:= batloop(ub_c_cursor,nseq,ub_cH,ub_cT);
#  nseq@batloop(){
	vb_c := str(ub_cT);
	wb_c := +("_Mean_",vb_c);
	xb_c := +("gmm_trained",wb_c);
	yb_c := reverse(view_bbp_name);
barrier	ac_c:= exist(yb_c,xb_c);
#    IF (view_bbp_name.reverse.exist("gmm_trained" + "_Mean_"  + str($t)))
	ac_cT:= take("ac_cT");
	bc_c := str(ac_cT);
	cc_c := +("_Mean_",bc_c);
	dc_c := +("gmm_trained",cc_c);
	ec_c := insert(tmBatIds_Mean,ac_cT,dc_c);
#      tmBatIds_Mean.insert( $t, "gmm_trained" + "_Mean_"  + str($t));
end	ac_c;
	fc_c := str(ub_cT);
	gc_c := +("_Covar_",fc_c);
	hc_c := +("gmm_trained",gc_c);
	ic_c := reverse(view_bbp_name);
barrier	jc_c:= exist(ic_c,hc_c);
#    IF (view_bbp_name.reverse.exist("gmm_trained" + "_Covar_" + str($t)))
	jc_cT:= take("jc_cT");
	kc_c := str(jc_cT);
	lc_c := +("_Covar_",kc_c);
	mc_c := +("gmm_trained",lc_c);
	nc_c := insert(tmBatIds_Covar,jc_cT,mc_c);
#      tmBatIds_Covar.insert($t, "gmm_trained" + "_Covar_" + str($t));
end	jc_c;
redo	ub_c;
end	ub_c;
#  }
#
#
##line 2147 "../../../src/gmm/gmm.mx"
#
end	ya_c;
barrier	oc_c:= not(ya_c);
#  } ELSE {
	trainedmodels:= newGMM("gmm_trained",Nimg);
#    VAR trainedmodels := newGMM("gmm_trained", Nimg);
#    
##line 655 "../../../src/gmm/gmm.mx"
	pc_c := find(trainedmodels,"init_variances");
	BAT_APPEND:= take("BAT_APPEND");
	qc_c := access(pc_c,BAT_APPEND);
#  access( trainedmodels.find("init_variances"), BAT_APPEND );
	rc_c := find(trainedmodels,"Prior");
	sc_c := access(rc_c,BAT_APPEND);
#  access( trainedmodels.find("Prior"), BAT_APPEND );
	tc_c := find(trainedmodels,"mImgIdx");
	uc_c := access(tc_c,BAT_APPEND);
#  access( trainedmodels.find("mImgIdx"), BAT_APPEND );
	vc_c := find(trainedmodels,"mCIdx");
	wc_c := access(vc_c,BAT_APPEND);
#  access( trainedmodels.find("mCIdx"), BAT_APPEND );
	xc_c := find(trainedmodels,"Mean");
	yc_c_cursor := 0:lng;
barrier	yc_c:= batloop(yc_c_cursor,xc_c,yc_cH,yc_cT);
	ad_c := access(yc_cT,BAT_APPEND);
redo	yc_c;
end	yc_c;
#  trainedmodels.find("Mean")@batloop{  access($t, BAT_APPEND); }
	bd_c := find(trainedmodels,"Covar");
	cd_c_cursor := 0:lng;
barrier	cd_c:= batloop(cd_c_cursor,bd_c,cd_cH,cd_cT);
	dd_c := access(cd_cT,BAT_APPEND);
redo	cd_c;
end	cd_c;
#  trainedmodels.find("Covar")@batloop{ access($t, BAT_APPEND); }
#
#
##line 2150 "../../../src/gmm/gmm.mx"
#
#    
##line 655 "../../../src/gmm/gmm.mx"
	ed_c := find(trainedmodels,"init_variances");
	fd_c := setPersistent(ed_c);
#  setPersistent( trainedmodels.find("init_variances") );
	gd_c := find(trainedmodels,"Prior");
	hd_c := setPersistent(gd_c);
#  setPersistent( trainedmodels.find("Prior") );
	id_c := find(trainedmodels,"mImgIdx");
	jd_c := setPersistent(id_c);
#  setPersistent( trainedmodels.find("mImgIdx") );
	kd_c := find(trainedmodels,"mCIdx");
	ld_c := setPersistent(kd_c);
#  setPersistent( trainedmodels.find("mCIdx") );
	md_c := find(trainedmodels,"Mean");
	nd_c_cursor := 0:lng;
barrier	nd_c:= batloop(nd_c_cursor,md_c,nd_cH,nd_cT);
	od_c := setPersistent(nd_cT);
redo	nd_c;
end	nd_c;
#  trainedmodels.find("Mean")@batloop{  setPersistent($t); }
	pd_c := find(trainedmodels,"Covar");
	qd_c_cursor := 0:lng;
barrier	qd_c:= batloop(qd_c_cursor,pd_c,qd_cH,qd_cT);
	rd_c := setPersistent(qd_cT);
redo	qd_c;
end	qd_c;
#  trainedmodels.find("Covar")@batloop{ setPersistent($t); }
#
#
##line 2151 "../../../src/gmm/gmm.mx"
#
#    
##line 655 "../../../src/gmm/gmm.mx"
	sd_c := find(trainedmodels,"init_variances");
	STORE_MMAP:= take("STORE_MMAP");
	td_c := mmap(sd_c,STORE_MMAP);
#  mmap( trainedmodels.find("init_variances"), STORE_MMAP );
	ud_c := find(trainedmodels,"Prior");
	vd_c := mmap(ud_c,STORE_MMAP);
#  mmap( trainedmodels.find("Prior"), STORE_MMAP );
	wd_c := find(trainedmodels,"mImgIdx");
	xd_c := mmap(wd_c,STORE_MMAP);
#  mmap( trainedmodels.find("mImgIdx"), STORE_MMAP );
	yd_c := find(trainedmodels,"mCIdx");
	ae_c := mmap(yd_c,STORE_MMAP);
#  mmap( trainedmodels.find("mCIdx"), STORE_MMAP );
	be_c := find(trainedmodels,"Mean");
	ce_c_cursor := 0:lng;
barrier	ce_c:= batloop(ce_c_cursor,be_c,ce_cH,ce_cT);
	de_c := mmap(ce_cT,STORE_MMAP);
redo	ce_c;
end	ce_c;
#  trainedmodels.find("Mean")@batloop{  mmap($t, STORE_MMAP); }
	ee_c := find(trainedmodels,"Covar");
	fe_c_cursor := 0:lng;
barrier	fe_c:= batloop(fe_c_cursor,ee_c,fe_cH,fe_cT);
	ge_c := mmap(fe_cT,STORE_MMAP);
redo	fe_c;
end	fe_c;
#  trainedmodels.find("Covar")@batloop{ mmap($t, STORE_MMAP); }
#
#
##line 2152 "../../../src/gmm/gmm.mx"
#
#    
##line 2194 "../../../src/gmm/gmm.mx"
#  # Can be paired with modelfromBatIds(X,tmBatIds)
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2195 "../../../src/gmm/gmm.mx"
#
	he_c := find(trainedmodels,"mCIdx");
	ie_c := info(he_c);
	je_c := find(ie_c,"batId");
	ke_c := insert(tmBatIds,"mCIdx",je_c);
#  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
	le_c := find(trainedmodels,"mImgIdx");
	me_c := info(le_c);
	ne_c := find(me_c,"batId");
	oe_c := insert(tmBatIds,"mImgIdx",ne_c);
#  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
	pe_c := find(trainedmodels,"Prior");
	qe_c := info(pe_c);
	re_c := find(qe_c,"batId");
	se_c := insert(tmBatIds,"Prior",re_c);
#  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
	te_c := find(trainedmodels,"init_variances");
	ue_c := info(te_c);
	ve_c := find(ue_c,"batId");
	we_c := insert(tmBatIds,"init_variances",ve_c);
#  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
	xe_c := find(trainedmodels,"Mean");
	ye_c := multiplex.info(xe_c);
	af_c := multiplex.find(ye_c,"batId");
	bf_c := insert(tmBatIds_Mean,af_c);
#  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
	cf_c := find(trainedmodels,"Covar");
	df_c := multiplex.info(cf_c);
	ef_c := multiplex.find(df_c,"batId");
	ff_c := insert(tmBatIds_Covar,ef_c);
#  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );
#
#
##line 2153 "../../../src/gmm/gmm.mx"
#
end	oc_c;
#  }
	ii:= 55;
#  VAR ii    := 55; # 0;
barrier	gf_c:= true;
	if_c := *(ii,fragsize);
	jf_c := <(if_c,Nimg);
barrier	hf_c:= jf_c;
#  WHILE ( (ii*fragsize) < Nimg ) {
	kf_c := find(collidx,"keyframes_file");
	lf_c := *(ii,fragsize);
	mf_c := +(ii,1);
	nf_c := *(mf_c,fragsize);
	of_c := -(nf_c,1);
	pf_c := bat(kf_c);
	frag_i:= slice(pf_c,lf_c,of_c);
#    VAR frag_i := bat(collidx.find("keyframes_file")).slice(ii*fragsize,((ii+1)*fragsize) - 1);
	qf_c := oid(0);
	rf_c := mark(frag_i,qf_c);
	sf_c := find(collidx,"imgBlock");
	tf_c := bat(sf_c);
	uf_c := reverse(rf_c);
	vf_c := join(uf_c,tf_c);
	wf_c := oid(0);
	xf_c := reverse(vf_c);
	yf_c := mark(xf_c,wf_c);
	frag_iIdx:= reverse(yf_c);
#    VAR frag_iIdx := frag_i.mark(oid(0)).reverse.join(bat(collidx.find("imgBlock"))).reverse.mark(oid(0)).reverse;
#
	EM_coll:= take("EM_coll");
	EM_coll := new(str,bat);
#    EM_coll := new(str,bat);
	ag_c := insert(EM_coll,"I",frag_i);
#    EM_coll.insert("I",  frag_i);
	imgBlock:= take("imgBlock");
	bg_c := reverse(imgBlock);
	cg_c := join(frag_iIdx,bg_c);
	dg_c := reverse(cg_c);
	eg_c := insert(EM_coll,"Ib",dg_c);
#    EM_coll.insert("Ib", frag_iIdx.join(imgBlock.reverse).reverse);
#
	coeffs:= new(int,bat);
#    VAR coeffs := new(int,bat);
	fg_c_cursor := 0:lng;
barrier	fg_c:= batloop(fg_c_cursor,nseq,fg_cH,fg_cT);
#    nseq@batloop(){
	gg_c := str(fg_cT);
	hg_c := +("imgBlockCoeff_",gg_c);
	ig_c := find(collidx,hg_c);
	jg_c := bat(ig_c);
	kg_c := join(frag_iIdx,jg_c);
	lg_c := insert(coeffs,fg_cT,kg_c);
#      coeffs.insert( $t, frag_iIdx.join(bat(collidx.find("imgBlockCoeff_" + str($t)))) );
redo	fg_c;
end	fg_c;
#    }
	mg_c := insert(EM_coll,"Coeffs",coeffs);
#    EM_coll.insert("Coeffs", coeffs);
	coeffs := nil;
#    		coeffs := nil;
	EM_model:= take("EM_model");
	EM_model := initGMM(EM_coll);
#    EM_model := initGMM( EM_coll );
#
	gmm:= EM_globalmodel(30);
#    VAR gmm := EM_globalmodel(30); # 30 iterations for starters
#
#    
##line 2208 "../../../src/gmm/gmm.mx"
#  # Must be paired with a modelBatIds(tmBatIds,X) in the same context
	trainedmodels := new(str,bat);
#  trainedmodels := new(str, bat);
	ng_c := multiplex.bat(tmBatIds);
	og_c := insert(trainedmodels,ng_c);
#  trainedmodels.insert( [bat](tmBatIds) );
	pg_c := multiplex.bat(tmBatIds_Mean);
	qg_c := insert(trainedmodels,"Mean",pg_c);
#  trainedmodels.insert( "Mean", [bat](tmBatIds_Mean) );
	rg_c := multiplex.bat(tmBatIds_Covar);
	sg_c := insert(trainedmodels,"Covar",rg_c);
#  trainedmodels.insert( "Covar", [bat](tmBatIds_Covar) );
#
#
##line 2173 "../../../src/gmm/gmm.mx"
#
	tg_c := find(trainedmodels,"mImgIdx");
	ug_c := count(tg_c);
	lastId:= oid(ug_c);
#    VAR lastId := oid(trainedmodels.find("mImgIdx").count);
	midx:= find(gmm,"mImgIdx");
#    VAR midx := gmm.find("mImgIdx");
#    
##line 611 "../../../src/gmm/gmm.mx"
#{
	vg_c := reverse(midx);
	wg_c := mark(vg_c,lastId);
	fIdx:= reverse(wg_c);
#  VAR fIdx := midx.reverse.mark(lastId).reverse;
#
	xg_c := find(gmm,"mImgIdx");
	yg_c := reverse(xg_c);
	convImgIdx:= join(fIdx,yg_c);
#  VAR convImgIdx     := join( fIdx, gmm.find("mImgIdx").reverse );
	ah_c := find(gmm,"mCIdx");
	bh_c := reverse(ah_c);
	convCIdx:= join(fIdx,bh_c);
#  VAR convCIdx       := join( fIdx, gmm.find("mCIdx").reverse );
#        # implementation of batinsert into empty voidbats causes trouble...
#        debug("<PROPCHECK1 hkey=%s />",     
	ch_c := find(trainedmodels,"mImgIdx");
	dh_c := info(ch_c);
	eh_c := find(dh_c,"hkey");
	fh_c := debug("<PROPCHECK1 hkey=%s />",eh_c);
#          trainedmodels.find("mImgIdx").info.find("hkey"));
	gh_c := reverse(convImgIdx);
	hh_c := find(trainedmodels,"mImgIdx");
	ih_c := insert(hh_c,gh_c);
#  trainedmodels.find("mImgIdx").insert( convImgIdx.reverse );
#        debug("<PROPCHECK2 hkey=%s />",    
	jh_c := find(trainedmodels,"mImgIdx");
	kh_c := info(jh_c);
	lh_c := find(kh_c,"hkey");
	mh_c := debug("<PROPCHECK2 hkey=%s />",lh_c);
#          trainedmodels.find("mImgIdx").info.find("hkey"));
	nh_c := reverse(convCIdx);
	oh_c := find(trainedmodels,"mCIdx");
	ph_c := insert(oh_c,nh_c);
#  trainedmodels.find("mCIdx").insert( convCIdx.reverse );
#
	qh_c := find(gmm,"Prior");
	rh_c := join(fIdx,qh_c);
	sh_c := find(trainedmodels,"Prior");
	th_c := insert(sh_c,rh_c);
#  trainedmodels.find("Prior").insert( join(fIdx, gmm.find("Prior")) );
	uh_c := find(trainedmodels,"Mean");
#  [insert]( trainedmodels.find("Mean"),
	vh_c := find(gmm,"Mean");
	wh_c := multiplex.join(fIdx,vh_c);
	xh_c := multiplex.insert(uh_c,wh_c);
#            [join](const fIdx, gmm.find("Mean")) );
	yh_c := find(trainedmodels,"Covar");
#  [insert]( trainedmodels.find("Covar"),
	ai_c := find(gmm,"Covar");
	bi_c := multiplex.join(fIdx,ai_c);
	ci_c := multiplex.insert(yh_c,bi_c);
#            [join](const fIdx, gmm.find("Covar")) );
#
	di_c := find(gmm,"init_variances");
	ei_c := join(fIdx,di_c);
	fi_c := find(trainedmodels,"init_variances");
	gi_c := insert(fi_c,ei_c);
#  trainedmodels.find("init_variances").insert( join(fIdx, gmm.find("init_variances")) );
#}
#
#
##line 2176 "../../../src/gmm/gmm.mx"
#
#    
##line 2194 "../../../src/gmm/gmm.mx"
#  # Can be paired with modelfromBatIds(X,tmBatIds)
#  
##line 2219 "../../../src/gmm/gmm.mx"
	tmBatIds := new(str,str);
#  tmBatIds       := new(str,str);
	tmBatIds_Mean := new(int,str);
#  tmBatIds_Mean  := new(int,str);
	tmBatIds_Covar := new(int,str);
#  tmBatIds_Covar := new(int,str);
#
#
##line 2195 "../../../src/gmm/gmm.mx"
#
	hi_c := find(trainedmodels,"mCIdx");
	ii_c := info(hi_c);
	ji_c := find(ii_c,"batId");
	ki_c := insert(tmBatIds,"mCIdx",ji_c);
#  tmBatIds.insert( "mCIdx",   trainedmodels.find("mCIdx").info.find("batId") );
	li_c := find(trainedmodels,"mImgIdx");
	mi_c := info(li_c);
	ni_c := find(mi_c,"batId");
	oi_c := insert(tmBatIds,"mImgIdx",ni_c);
#  tmBatIds.insert( "mImgIdx", trainedmodels.find("mImgIdx").info.find("batId") );
	pi_c := find(trainedmodels,"Prior");
	qi_c := info(pi_c);
	ri_c := find(qi_c,"batId");
	si_c := insert(tmBatIds,"Prior",ri_c);
#  tmBatIds.insert( "Prior",   trainedmodels.find("Prior").info.find("batId") );
	ti_c := find(trainedmodels,"init_variances");
	ui_c := info(ti_c);
	vi_c := find(ui_c,"batId");
	wi_c := insert(tmBatIds,"init_variances",vi_c);
#  tmBatIds.insert( "init_variances", trainedmodels.find("init_variances").info.find("batId") );
	xi_c := find(trainedmodels,"Mean");
	yi_c := multiplex.info(xi_c);
	aj_c := multiplex.find(yi_c,"batId");
	bj_c := insert(tmBatIds_Mean,aj_c);
#  tmBatIds_Mean.insert(  [find]([info](trainedmodels.find("Mean")), const "batId") );
	cj_c := find(trainedmodels,"Covar");
	dj_c := multiplex.info(cj_c);
	ej_c := multiplex.find(dj_c,"batId");
	fj_c := insert(tmBatIds_Covar,ej_c);
#  tmBatIds_Covar.insert( [find]([info](trainedmodels.find("Covar")), const "batId") );
#
#
##line 2177 "../../../src/gmm/gmm.mx"
#
#    commit;
#
	trainedmodels := nil;
#    trainedmodels := nil;
	EM_model := nil;
#    EM_model := nil;
	EM_coll := nil;
#    EM_coll  := nil;
#
	gmm := nil;
#    gmm := nil;
	midx := nil;
#    midx := nil;
#
	gj_c := :+=(ii,1);
#    ii :+= 1;
redo	gf_c;
end	hf_c;
end	gf_c;
#  }
#
#
##line 2338 "../../../src/gmm/gmm.mx"
	GMMdebuglog:= take("GMMdebuglog");
	hj_c := fflush(GMMdebuglog);
#  fflush( GMMdebuglog );
#  # enum_drop( TCluster );
#  # fclose( GMMdebuglog );
#  # quit;
#
#
##line 2346 "../../../src/gmm/gmm.mx"
function modelIdx(N:int):bat[str,void];
#PROC modelIdx(int N): BAT[str,void] := {
	ij_c := new(str,void);
	jj_c := oid(0);
	kj_c := reverse(ij_c);
	lj_c := setSequenceBase(kj_c,jj_c);
	modelidx:= reverse(lj_c);
#  VAR modelidx := new(str,void).reverse.setSequenceBase(oid(0)).reverse;
	mj_c := Nseq(N);
	seq:= reverse(mj_c);
#  VAR seq := Nseq(N).reverse;
	nj_c := insert(modelidx,"Prior",nil);
#  modelidx.insert( "Prior", nil );
	oj_c := project(seq,"Mu_");
	pj_c := mirror(seq);
	qj_c := multiplex.+(oj_c,pj_c);
	mu:= _x(qj_c);
#  VAR mu := _x([+](seq.project("Mu_"), seq.mirror));
	rj_c := project(seq,"Sigma_");
	sj_c := mirror(seq);
	tj_c := multiplex.+(rj_c,sj_c);
	covar:= _x(tj_c);
#  VAR covar := _x([+](seq.project("Sigma_"), seq.mirror));
	uj_c := reverse(mu);
	vj_c := insert(modelidx,uj_c);
#  modelidx.insert( mu.reverse );
	wj_c := reverse(covar);
	xj_c := insert(modelidx,wj_c);
#  modelidx.insert( covar.reverse );
	yj_c := reverse(mu);
	ak_c := number(yj_c);
	bk_c := reverse(ak_c);
	mu := join(bk_c,modelidx);
#  mu := mu.reverse.number.reverse.join(modelidx);
	ck_c := reverse(covar);
	dk_c := number(ck_c);
	ek_c := reverse(dk_c);
	covar := join(ek_c,modelidx);
#  covar := covar.reverse.number.reverse.join(modelidx);
	return modelidx;
#  RETURN modelidx;
end function;
#}
#
#
