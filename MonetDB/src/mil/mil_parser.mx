@a M. L. Kersten
@v 2.0

@* Parsing MIL Version 4 
This module contains a small footprint MIL parser for Monet Version 5.0
to assure backward compatibility. Compatibility is only guaranteed
for the code base known May 2000 and excludes the active database component
as well as some exotic constructs.

Furthermore, this parser assumes availability of a complete MIL block upfront
as a string to be parsed. 

The parser produced is not thread safe, which means that parsing
is encapsulated in a critical section. On single cpu systems this
does not cause too much performance degration, on multi-cpu systems
it may affect throughput when many users issue short (simple) commands.
The quantitative effect is yet unknown.

The stand-alone version of this parser (M2M) can be used 
to check any MIL procedure for syntactic errors.
@+ The lexical analyzer
The lexical analyzer is generated using Flex, the preferred tool in Monet.

The implementation of the lexical analyzer is straightforward:
the input is taken from a client message buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
This input buffer may be screwed up in the process, which implies
that front-ends may have to make a copy first.

The lexical analyzer and parser are prefixed with "mil", which ensures that
other language analyzers can safely be added
(provided they run not inparallel). The lexical analyzer should
not maintain a linenumber. This aspect is made explicit in the rules
any way.

The lexical analyser returns simple triples to the parser.
They include the token identifier, the Monet type-id, and a string
representation.

WARNING. This paper performs a single linear scan over the mil code
and immediately produces strings for output. A better solution would have been
to build a parsetree followed by a recursive descend code generation phase.
@h
#ifndef _MIL_PARSER_H
#define _MIL_PARSER_H

#include "gdk.h"


typedef struct YYSRECORD{
	int	token, tpe, len;
	char * 	val;
 } yystype, *yystypeptr;

#define YYSTYPE yystype
extern YYSTYPE yylval;
#define GDKerror(M) 	printf("%s",M) 

extern const char *yylexname(int Y);
extern void mil_parserror(str msg);
extern void mil_flushbuffer();
extern str mil_lastline();
extern int mil_position();
extern int mil_skipcomment();
extern int mil_getch();
extern int yylex();
extern char *newName();
extern str getLastHead();
extern str getLastTail();

#endif /* _MIL_PARSER_H */
@l
/*
%option noyylineno
%option never-interactive
%option nomain
*/

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*+|?<>=/\\]
IDENT	{L}({L}|{D})*
OPER	{P}+
%{

#include "mil_parser.h"
@-
The Bison parser generator will produce the table with token names
needed for tracing the parser.
@l
#include "mil_parser.tab.h"

#define RETURN(Y)       { PARSEDEBUG {\
                                THRprintf(GDKerr, "\n%s %s\n", yylexname(Y), yytext);\
                          } return Y; }


#define YY_INPUT(buf,result,max_size)   { int c = mil_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#define Symbol(X)       { Vector(X,TYPE_void,0,0); }
#define Vector(X,Y,V,L)	{ yylval.token= X;	\
			yylval.tpe  = Y;	\
			if( V != 0 ) \
			yylval.val = GDKstrdup(V);  	\
			yylval.len = L;	\
			RETURN (X); }
%}

%%
"#"                   { return mil_skipcomment();                              }
("nil"|"NIL")         { Vector(TOK_CONSTANT, TYPE_void, "nil", 3);   }
("proc"|"PROC")       { Symbol(TOK_PROCDEF);                                  }
("undef"|"UNDEF")     { Symbol(TOK_UNDEF);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("break"|"BREAK")     { Symbol(TOK_BREAK);                                    }
("while"|"WHILE")     { Symbol(TOK_WHILE);                                    }
("if"|"IF")           { Symbol(TOK_IF);                                       }
("else"|"ELSE")       { Symbol(TOK_ELSE);                                     }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, "0", 1);        }
("var"|"VAR")         { Symbol(TOK_VAR);                                      }
("const"|"CONST")     { Symbol(TOK_OPERATOR);                                    }
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, "1", 1);        }
("module"|"MODULE")   { Symbol(TOK_MODULE);				     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int,  "-1", 2);               }
("bat"|"BAT")         { Symbol(TOK_BAT);				      }
"$("                  { Symbol(TOK_VARTEMP);                                  }
".."                  { Symbol(TOK_RANGETEMP);                                }
"::"                  { Symbol(TOK_ANYNUM);                                   }
("$h"|"$H"|"$head"|"$HEAD") { Vector(TOK_ITERTEMP, TYPE_str, getLastHead(), 1);         }
("$t"|"$T"|"$tail"|"$TAIL") { Vector(TOK_ITERTEMP, TYPE_str, getLastTail(), 1);         }
"$"{D}+               { Vector(TOK_TEMPLATE,TYPE_int,yytext+1,yyleng-1);       }
"(*"                  { Symbol(TOK_DEREF);                                    }
"[*"                  { Symbol(TOK_SETOP);                                    }
"{*"                  { Symbol(TOK_SETAGGR);                                  }
"@"                   { Symbol(TOK_ITERATION);                                }
":="                  { Symbol(TOK_ASSIGNMENT);                               }
("["{OPER}"]")	|
("["{IDENT}"]")	|
("{"{OPER}"}")	|
("{"{IDENT}"}")	|
("[:=]")	|
("[:"{OPER}"=]")	|
("{:=}") 	|
({IDENT})	      { Vector(TOK_IDENT, TYPE_str, yytext,yyleng);	      }
(":"{OPER}"=")	|
({OPER}"="?) 	      { Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng);	      } 
("-")?{D}+"LL"        { Vector(TOK_CONSTANT, TYPE_lng, yytext, yyleng);}
("-")?{D}+            { Vector(TOK_CONSTANT, TYPE_int, yytext, yyleng);}
{D}+"@"{D}+           { Vector(TOK_CONSTANT, TYPE_oid, yytext, yyleng);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { Vector(TOK_CONSTANT, TYPE_dbl,  yytext, yyleng);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { Vector(TOK_CONSTANT, TYPE_flt,  yytext, yyleng);         }
"'"\\0{O}({O})?({O})?"'" {Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);        }
\"[^\n"]*\"		{
                        if (yytext[yyleng-1] != '\\') {
				yytext[yyleng]=0;
                                Vector(TOK_CONSTANT, TYPE_str, yytext, yyleng);
                        } else {
				yymore(); 
			}					                     }
\'[^\n\']*\'            { 
                        if (yytext[yyleng-1] != '\\') {
                                Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);
                        } else {
                                yymore(); 
                        }                                                     }
"{|"                  { Symbol(TOK_PARBLOCK);                                 }
"|}"                  { Symbol(TOK_PAREND);                                   }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int mil_skipcomment() { 
	char c; 
	while ((c=input()) && (c != '\n')); 
	return yylex();
}
int yywrap(){ return 1;}

void mil_flushbuffer() {
        YY_FLUSH_BUFFER;
}

str glue(str l, str r){
	str t;
	t= (str) GDKmalloc(strlen(l)+strlen(r)+1);
	t[0]=0;
	strcpy(t,l);
	strcat(t,r);
	return t;
}
@
@- Input management
The parser reads its input from a string buffer space, organized as a
stack to permit easy escapes to "included" MIL programs (module inits).
After parsing the string buffer space is freed by the parser as well.

[These variables should be local to a parsing thread.]
@c
#include "mil_parser.h"

typedef struct _strstack_t {
	str buf, cptr, prevline, nxtline;
	int listing;		
	struct _strstack_t *up;
} strstack;

static strstack  *mil_stack = NULL;

int mil_push(str s, int l) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
	sp->listing = 1;
	sp->cptr = sp->nxtline= sp->prevline = sp->buf = s;  
	sp->up = mil_stack;
	mil_stack = sp;
	return 1;
}

int mil_pop() {
	strstack *sp = mil_stack;
	if (mil_stack) {
		mil_stack = sp->up;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

@-
The next character is retrieved from the string pool
using the routine mil_getch. The position of the last
newline is retained to gain quick access.
@c
int mil_getch() {
        char ch;
	ch = *mil_stack->cptr;
        if (ch == '\n') {
                if (mil_stack->listing) { 
                        *mil_stack->cptr = 0;
			fputc('#',GDKout);
                        fputs(mil_stack->nxtline, GDKout);
                        fputc('\n', GDKout);
                        fflush(GDKout);
                        /* *mil_stack->cptr = '\n';*/
                }
		mil_stack->prevline= mil_stack->nxtline;
                mil_stack->nxtline = mil_stack->cptr + 1;
        } 
        if (ch) mil_stack->cptr++;
        return ch;
}

@-
For error reporting we have to find the start of the previous line,
which, ofcourse, is easy.
@c
str mil_lastline(){ 
	if( mil_stack->nxtline == 0)
		return mil_stack->prevline;
	return mil_stack->nxtline; 
}
int mil_position()
{
	return (int)(mil_stack->cptr)- (int)mil_stack->nxtline;
}
@-
Long strings are in this version easier to handle, because the input is
already concatenated by the front-end. This means that a string literal may not
extend beyond end-of-line.
REWORKED

@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@c
static int nameId;

int mil_parse(str buf, int listing){
	return 0;
}

#define MAXDEPTH 64
str iterators[MAXDEPTH];
int itop=0;

str getLastIterator(){
	if(itop==0){
		printf("\n#ERROR: no iterators on stack\n");
		return GDKstrdup("unknown");
	}
	return GDKstrdup(iterators[itop-1]);
}
void pushIterator(str nme){
	if( itop== MAXDEPTH){
		GDKfatal("FATAL: iterator depth exceeded\n");
	}
	iterators[itop]= GDKstrdup(nme);
	itop++;
}
void popIterator(){
	if(itop==0){
		printf("\n#ERROR: no iterators on stack\n");
		return;
	}
	itop--;
	GDKfree(iterators[itop]);
}
void resetIterator(){ itop=0;}

str getLast(char c){
	char buf[IDLENGTH];
	if(itop==0){
		printf("\n#ERROR: no iterators on stack\n");
		return GDKstrdup("unknown");
	}
	sprintf(buf,"%s%c",iterators[itop-1],c);
	return GDKstrdup(buf);
}
str getLastHead(){ return getLast('H');}
str getLastTail(){ return getLast('T');}

@- The Bison Grammar
The grammatica should be context free.
@y
%token_table

%{
#include "mil_parser.h"

#undef yyerror
#define yyerror(X)      { mil_parserror(X);  }

#define YYPRINT(file,tpe,val)	mil_print(file,tpe,val)
int yydebug = 0;
void debugParser(int i){ yydebug=i; }

yystype accum;
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_PARBLOCK
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE
%token TOK_BREAK TOK_RETURN TOK_VAR 
%token TOK_CONST TOK_BAT
%token TOK_OPERATOR
%token TOK_SETOP TOK_SETAGGR TOK_PROCDEF
%token TOK_STRING TOK_ITERATION TOK_ELSE
%token TOK_MODULE 
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM

%left TOK_ITERATION
%left TOK_ASSIGNMENT TOK_OPERATOR
%%
program:
        MIL_session
    |   error ';' { yyerrok; yyclearin; return 1; }
    |   /* empty */

MIL_session:
        session
    |   MIL_session session

session:
        proc_definition
    |   TOK_MODULE '(' module_list ')' ';'
    |   statement

statement_seq:
        /* empty */
    |   statement_list

statement_list:
        statement
    |   statement_list statement

statement:
        stmt
    |   varidents ';'
    |   constidents ';'

stmt: ';'
    |   expression ';'
    |   expression TOK_ITERATION '[' expression ']' iterator
	{ $2.val= newName();
	  pushIterator($2.val);
	  printf("\t%s_cursor := 0:lng;\n",$2.val);
	  printf("barrier\t%s:= batloop(%s,%s_cursor);\n",
		$2.val,$4.val,$2.val);
	  printf("\t%sH := fetchHead(%s,%s_cursor);\n", $2.val,$4.val,$2.val);
	  printf("\t%sT := fetchTail(%s,%s_cursor);\n", $2.val,$4.val,$2.val);
	}
	stmt
	{
	  printf("redo\t%s;\n", $2.val);
	  printf("end\t%s;\n",$2.val);
	  popIterator();
	}
    |   expression TOK_ITERATION iterator
	{ $2.val= newName();
	  pushIterator($2.val);
	  printf("\t%s_cursor := 0:lng;\n",$2.val);
	  printf("barrier\t%s:= batloop(%s,%s_cursor);\n",
		$2.val,$1.val,$2.val);
	  printf("\t%sH := fetchHead(%s,%s_cursor);\n", $2.val,$1.val,$2.val);
	  printf("\t%sT := fetchTail(%s,%s_cursor);\n", $2.val,$1.val,$2.val);
	}
	stmt
	{
	  printf("redo\t%s;\n", $2.val);
	  printf("end\t%s;\n",$2.val);
	  popIterator();
	}
    |   blk_expression
    |   TOK_RETURN ret_value ';'
	{ printf("\treturn %s;\n", $2.val);}
	/* expression in the while block could be compound !! */
    |   barrier '(' 
	{ $2.val= newName();
	  printf("barrier\t%s:= true;\n",$1.val);
	}
	 expression ')' 
	{ printf("barrier\t%s:= %s;\n",$2.val,$4.val); }
	stmt
	{ 
	  printf("redo\t%s;\n", $1.val);
	  printf("end\t%s;\n",$2.val);
	  printf("end\t%s;\n",$1.val);
	}

    |   ifhead /* TOK_IF '(' expression 
	{ $1.val = newName();
	   printf("barrier\t%s:= %s;\n",$1.val,$3.val);
	}
	')' */ stmt
	{ printf("end\t%s;\n",$1.val); }
    |   ifhead /* TOK_IF '(' expression 
	{ $1.val = newName();
	   printf("barrier\t%s:= %s;\n",$1.val,$3.val);
	}
	')' */ stmt TOK_ELSE 
	{ printf("end\t%s;\n",$1.val); 
	  $1.val= newName();
	   printf("barrier\t%s:= %s;\n",$1.val,$3.val);
	}
	stmt
	{ printf("end\t%s;\n",$1.val); }
    |   TOK_BREAK ';'
	{ printf("leave\t;\n"); }

ifhead: TOK_IF '(' expression ')'
	{ $1.val = newName();
	   printf("barrier\t%s:= %s;\n",$1.val,$3.val);
	}

barrier:
	TOK_WHILE
	{ $$.val= newName();}

iterator :
	/* fcn_call*/
	TOK_IDENT '(' ')'
    |	TOK_IDENT
        
ret_value:
        expression
    |   /* empty */
	{ $$.val= GDKstrdup("nil");}

sequential_block:
        '{' /* {$1.val= newName(); printf("barrier\t%s:=true;\n",$1.val);}*/
	statement_seq '}'
	/* { printf("end\t %s;\n", $1.val);} */

parallel_block:
        TOK_PARBLOCK 
	{ $1.val= newName(); printf("barrier\t%s:= true;\n",$1.val);}
	statement_seq TOK_PAREND
	{ printf("end all\t%s;\n",$1.val);}

proc_definition:
        TOK_PROCDEF proc_name proc_header stmt
	{ printf("end function;\n"); }
    |   TOK_PROCDEF proc_name {printf(");\n");} stmt
	{ printf("end function;\n"); }
    |   TOK_PROCDEF proc_name {printf(");\n");} TOK_ASSIGNMENT stmt
	{ printf("end function;\n"); }
    |   TOK_PROCDEF proc_name proc_header TOK_ASSIGNMENT stmt
	{ printf("end function;\n"); }
    |   TOK_UNDEF TOK_IDENT';'

proc_name:
        TOK_IDENT
	{ printf("function %s(",$1.val);}
    |   TOK_STRING
	{ printf("function %s(",$1.val);}
    |   TOK_OPERATOR
	{ printf("function %s(",$1.val);}

proc_header:
        '(' mel_header ')' mel_return
    |    '(' ')' mel_return

mel_header:
        mel_params ',' mel_range
    |   mel_params 
    |   mel_range

mel_range:
        TOK_RANGETEMP mel_type TOK_RANGETEMP
	{ printf("unknown range");}

mel_params:
        mel_type TOK_IDENT
	{ printf("%s:%s",$2.val,$1.val);}
    |	TOK_IDENT
	{ printf("%s:any",$1.val);}
    |   mel_params ',' mel_type TOK_IDENT
	{ printf(", %s:%s",$4.val,$3.val);}
    |   mel_params ',' TOK_IDENT
	{ printf("%s:any",$3.val);}

mel_type:
        TOK_IDENT 
    |   TOK_BAT
    |   TOK_BAT '[' mel_atom ',' mel_atom ']'
	{ char buf[PATHLENGTH];
	  sprintf(buf,"bat[%s,%s]",$3.val,$5.val);
	  $$.val= GDKstrdup(buf);
	}
    |   mel_any

mel_atom:
        TOK_IDENT
    | 	TOK_BAT
    |   mel_any

mel_any:
        TOK_ANY TOK_ANYNUM type_var
	{ char buf[PATHLENGTH];
	  sprintf(buf,"any::%s",$3.val);
	  $$.val= GDKstrdup(buf);
	}
    |   TOK_ANY
	{ $$.val = GDKstrdup("any");
	  printf("\n# ERROR: 'any' types should be bound to a type variable\n");
	}

type_var: TOK_CONSTANT
	{
	  if(strlen($1.val)>1){
	  printf("ERROR:type variable should be chosen from [0-9a-zA-Z]\n");
	  }
	}

mel_return:
        ':' mel_type
	{ printf("):%s;\n",$2.val);}
    |   /* empty */ 
	{ printf("):void;\n");}

blk_expression:
        sequential_block
    |   parallel_block

expression:
	term
	{accum = $1;}
	
term :
	factor
    |	factor TOK_OPERATOR term
	{ char *nme= newName();
	  printf("\t%s:= %s(%s,%s);\n",
		nme,$2.val,$1.val,$3.val);
	  $$.val=nme;
	}
    |	TOK_OPERATOR term
	{ char *nme= newName();
	  printf("\t%s:= %s(%s);\n",
		nme,$1.val,$2.val);
	  $$.val=nme;
	}
    |	factor TOK_IDENT term
	{ char *nme= newName();
	  printf("\t%s:= %s(%s,%s);\n",
		nme,$2.val,$1.val,$3.val);
	  $$.val=nme;
	}
    |   template TOK_ASSIGNMENT term
	{ printf("\t%s := %s;\n", $1.val, $3.val);}
    |   TOK_IDENT TOK_ASSIGNMENT term
	{ printf("\t%s := %s;\n", $1.val, $3.val);}

variable_reference:
        template 
    |  	TOK_IDENT

template:
        TOK_TEMPLATE
    |   TOK_ITERTEMP
    |   TOK_VARTEMP factor ')'
	{ char *nme= newName();
	  printf("\t%s := getVarTemp(%s);\n",nme,$2.val);
	  $$.val= nme;
	}
    |   TOK_VARTEMP factor TOK_RANGETEMP ')'
	{ char *nme= newName();
	  printf("\t%s := getVarTempRange(%s);\n",nme,$2.val);
	  $$.val= nme;
	}


factor:
        TOK_CONSTANT
    |   TOK_STRING
    |   TOK_BAT
    |  	variable_reference
    | 	fcn_call
    |   '[' multiplex_expression ']'
    |   '(' expression ')'
	{ $$= $2;}
@-
The separator should be limited to ',' and '~' should be
added back as an operator symbol.
@y
multiplex_comma: ',' |  '~'

multiplex_expression:
      multiplex_term multiplex_comma multiplex_term
	{printf("multiplex expression not supported\n");}

multiplex_term:
        TOK_CONST expression 
    |   bat_expression
    |   expression '?' bat_expression ':' bat_expression

bat_expression:
        expression
     |   /* empty */

fcn_call: 
     	fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$1.val,$3.val); $$.val = nme;}
    |	TOK_OPERATOR '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$1.val,$3.val); $$.val = nme;}
    |	fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s();\n",nme,$1.val); $$.val = nme;}
    | variable_reference '.' fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}
    | variable_reference '.' fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s,%s);\n",nme,$3.val,$1.val,$5.val); $$.val = nme;}
    | variable_reference '.' variable_reference
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}
    | TOK_CONSTANT '.' fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}
    | TOK_CONSTANT '.' fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s,%s);\n",nme,$3.val,$1.val,$5.val); $$.val = nme;}
    | TOK_CONSTANT '.' variable_reference
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}
    | '[' multiplex_expression ']' '.' fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$5.val,$2.val); $$.val = nme;}
    | '[' multiplex_expression ']' '.' fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s,%s);\n",nme,$5.val,$2.val,$7.val); $$.val = nme;}
    | '(' expression ')' '.' fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$5.val,$2.val); $$.val = nme;}
    | '(' expression ')' '.' fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s,%s);\n",nme,$5.val,$2.val,$7.val); $$.val = nme;}
    | fcn_call '.' fcn_hdr '(' ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}
    | fcn_call '.' fcn_hdr '(' expr_list ')'
	{ char *nme=newName();
	printf("\t%s:= %s(%s,%s);\n",nme,$3.val,$1.val,$5.val); $$.val = nme;}
    | fcn_call '.' variable_reference
	{ char *nme=newName();
	printf("\t%s:= %s(%s);\n",nme,$3.val,$1.val); $$.val = nme;}

fcn_hdr: 
       TOK_DEREF factor ')'  
	{ 
	  $$.val= glue("dereference.",$2.val);
	}
    |  TOK_SETOP factor ']' 
	{ 
	  $$.val= glue("setop.",$2.val);
	}
    |  TOK_SETAGGR factor '}'
	{ 
	  $$.val= glue("aggregate.",$2.val);
	}
    |  TOK_BAT
	{ 
	  $$.val="bat";
	}
    |  TOK_IDENT	
	{ 
	  $$.val = $1.val;
	}
 
expr_list:
     	expression
	{$$=$1;}
    |	expr_list ',' expression
	{ $$.val= glue(glue($1.val,","),$3.val);}

module_list:
      modident
	{printf("use %s;\n",$1.val);}
    | module_list ',' modident
	{printf("use %s;\n",$3.val);}

modident:
        TOK_CONSTANT
    |   TOK_IDENT
    |   TOK_BAT

constidents:
        TOK_CONST TOK_IDENT TOK_ASSIGNMENT expression
 	{ printf("\t%s:= %s;\n",$2.val,$4.val); }
   |   constidents ',' TOK_IDENT TOK_ASSIGNMENT expression
 	{ printf("\t%s:= %s;\n",$3.val,$5.val); }

varidents:
        TOK_VAR ident_decl
    |   varidents ',' ident_decl

ident_decl:
        TOK_IDENT 
	{printf("\t%s:= nil;\n",$1.val);}
    |   TOK_IDENT TOK_ASSIGNMENT expression
 	{ printf("\t%s:= %s;\n",$1.val,$3.val); }
%%

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@{
@y
void mil_parserror(str msg){
        static char buf[1024];
        char *s=buf, *t, *l = mil_lastline();
        int i = strlen(GDKERROR);
	strcpy(buf,GDKERROR); s+= i;

        mil_flushbuffer(); /* flush the lexer's buffer */

        *s++ = '"';
        for(t=l; *t && *t!='\n'; t++) {
                /* accidental %s directives in the lastline can
                   crash the vfsprintf later => escape them */
                if (*t == '%') *s++ = '%';
                *s++ = *t;
        }
        *s++ = '"'; *s++ = '\n';

	/* produce the position marker*/
        for(*s++ = '!'; i > 0; i--) *s++ = ' ';
	i = mil_position();
        for(; i > 0; i--) {
                *s++ = (*l != '\t')?' ':'\t';
        }
        *s++ = '^'; *s++ = '\n'; *s = 0;
        if (msg) {
                sprintf(s, "! %s.\n", msg);
        } else {
                sprintf(s, "! "); s += 2;
                if (*s == 0) sprintf(s,"can't help you here, sorry.\n");
        }
        GDKerror(buf);
}

static int mil_print(FILE *f, int tpe, YYSTYPE v)
{
	if( v.len >0) fprintf(f," %s ", v.val);
}
const char *yylexname(int Y)           
{ 	if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
		return yytname[Y-TOK_ITERTEMP];
	} 
	return "char";
}
@- Utilities
Generation of the Mal code block requires
@c
char *newName(){
	char buf[IDLENGTH];
	sprintf(buf,"_v%d", nameId++);
	return GDKstrdup(buf);
}
char *getName(int i){
	char buf[IDLENGTH];
	sprintf(buf,"_v%d", i);
	return GDKstrdup(buf);
}

@}

