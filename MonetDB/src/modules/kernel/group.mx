@f group
@t The group module
@a M.L. Kersten, P. Boncz, A.P. de Vries 
@v 2.3
@* Introduction
@T
This module contains the primitives to construct, derive, and
perform statistical operations on BATs representing groups.
The default scheme in Monet is to assume the head to represent
the group identifier and the tail an element in the group.

Groups play an important role in datamining, where they are used
to construct cross-tables. Such cross tables over a single
BAT are already supported by the histogram function.
This module provides extensions to support identification of groups in a
(multi-)dimensional space.

The module implementation has a long history. The first implementation
provided several alternatives to produce/derive the grouping.
A more complete (and complex) scheme was derived during its
extensive use in the context of the Data Distilleries  product.
The current implementation is partly a cleanup of this code-base,
but also enables provides better access to the intermediate
structures produced in the process, i.e. the histogram and
the sub-group mapping. They can be used for various optimization
schemes at the MAL level.

The prime limitation of the current implementation is that an 
underlying database of {oid->any} BATs is assumed. 
This enables representation of each group using an oid,
and the value representation of the group can be accordingly be
retrieved easily. An optimized implementation in which we use positional
integer id's (as embodied by Monet's void type) is also available.

THis limitation on (v)oid-headers is marginal. The primitive CTsplit
produces for any BAT two copies with both a (v)oid header.
@+ Algorithms
@T
There are several approaches to build a cross table. The one chosen here
is aimed at incremental construction, such that re-use of intermediates
becomes possible. Starting with the first dimension, a BAT is derived to
represent the various groups, called a {\bf CT BAT} or cross-table BAT.

@- Cross Table (CT)
@T
A cross table is an <oid,oid> BAT where the first (head) denotes a tuple in
the cross table and the second (tail) marks all identical lists.
The tail-oids contain group identifiers; that is, {\em this value is equal
{\bf iff} two tuples belong to the same group}. The group identifiers are
chosen from the domain of the tuple-identifiers. This simplifies 
getting back to the original tuples, when talking about a group.
If the tuple-oid of 'John' is chosen as a group-id, you might view this
as saying that each member of the group is 'like John' with respect
to the grouping-criterion.

@- going deeper
@T
Successively the subgroups can be identified by modifying the CT BAT or
to derive a new CT BAT for the subgroups. After all groups have been
identified this way, a BAT histogram operation can be used to obtain
the counts of each data cube. Other aggregation operations using the MIL
set aggregate construct \{X\}(bat) (see the 
@[<a href="../mil.body.html#mod_3_2_0">MIL Reference Manual</a>@)  
can be used as well; note for instance that histogram == \{count\}(b.reverse). 

@* Module Definition
The Monet interface module specification is shown below.
@mal
module group;

command group(attr:bat[oid,any::1] ) 
	:(histo:bat[any::1,int], grp:bat[oid,oid]) = CTgroup
comment "Cross tabulation group initialization.
         Returned head values are identical as in 'attr'. Tail values are from
         the same domain and indicate unique groups in 'attr' tail column.";
command group(attr:bat[oid,any::1] ) 
	:bat[oid,oid] = CTgroup2
 
command group(attr:bat[oid,any::1], N:int, rng:int) 
	:(histo:bat[any::1,int],grp:bat[oid,oid]) = CTgroup_custom 
comment "Cross tabulation group initialization like CTgroup, but with user
         provided #bits in hashmask and #distinct values in range.";
 
command derive(ct:bat[oid,any], attr:bat[oid,any::1]) 
	:(map:bat[any::1,oid],grp:bat[oid,oid]) = CTderive
comment "Cross tabulation group extension step.
         Returned head values are identical as in 'ct'. Tail values are from
         the same domain and indicate further refinement of the groups in 'ct',
         taking into account also the tail-values in 'attr'.";
command derive(ct:bat[oid,any], attr:bat[oid,any::1]) 
	:bat[oid,oid] = CTderive2;

command group(ct:bat[oid,any], attr:bat[oid,any::1]) 
	:(map:bat[any::1,oid],grp:bat[oid,oid]) = CTderive 
comment "binary grouping; a synonym for (map,grp):=CTderive(ct,attr)";

command regroup(ct:bat[oid,oid], attr:bat[oid,any]) : bat[oid,oid] = CTregroup
comment "modifies ct and returns it doing a group";

command refine(b:bat[oid,any], a:bat[oid,any]) : bat[oid,oid] = CTrefine 
comment "refine the ordering of a tail-ordered BAT by sub-ordering on the 
         values of a second bat 'a' (where the heads of a and b match 1-1).  
         The effect of this is similar to (hash-based) CTderive, with the 
	 distinction that the group ids respect the ordering of the group values.";
@-
histogram support. during group computation we already compute histograms
for quick re-use. They are attached to the CT by means of a histolink.
@mal
command subhisto(sel:BAT[void,bit], grp:BAT[void,oid], domain:BAT[oid,any]) 
	: BAT[oid,int] = CTsubhisto
comment "optimized sub-histogram for synced grp[void,oid] and sel[void,bit] 
         bats on a previously known domain ";

command histosum(ct:BAT[oid,oid], histo:BAT[oid,int]) : BAT[oid,int] = CThistosum 
comment "Produce sum over old histogram table";

@+ Group Aggregate operations

This module contains some efficient aggregate functions that compute their 
result in one scan, rather than in the iterative manner of the generic 
MIL aggr_ implementations.

The implementation code is derived from the 
tpcd module and some test scripts were added.
@mal

command sum(b:BAT[oid,sht], e:BAT[oid,any]) : BAT[oid,sht] = CMDgroup_sum_sht 
	comment "grouped tail sum";
command sum(b:BAT[oid,int], e:BAT[oid,any]) : BAT[oid,int] = CMDgroup_sum_int 
	comment "grouped tail sum";
command sum(b:BAT[oid,lng], e:BAT[oid,any]) : BAT[oid,lng] = CMDgroup_sum_lng 
	comment "grouped tail sum";
command sum(b:BAT[oid,flt], e:BAT[oid,any]) : BAT[oid,flt] = CMDgroup_sum_flt 
	comment "grouped tail sum";
command sum(b:BAT[oid,dbl], e:BAT[oid,any]) : BAT[oid,dbl] = CMDgroup_sum_dbl 
	comment "grouped tail sum";

command avg(b:BAT[oid,sht], e:BAT[oid,any]) : BAT[oid,sht] = CMDgroup_avg_sht 
	comment "grouped tail average";
command avg(b:BAT[oid,int], e:BAT[oid,any]) : BAT[oid,int] = CMDgroup_avg_int 
	comment "grouped tail average";
command avg(b:BAT[oid,lng], e:BAT[oid,any]) : BAT[oid,lng] = CMDgroup_avg_lng 
	comment "grouped tail average";
command avg(b:BAT[oid,flt], e:BAT[oid,any]) : BAT[oid,flt] = CMDgroup_avg_flt 
	comment "grouped tail average";
command avg(b:BAT[int,dbl], e:BAT[int,any]) : BAT[int,dbl] = CMDgroup_avg_dbl 
	comment "grouped tail average";

command min(b:BAT[oid,any::1], e:BAT[oid,any]) : BAT[oid,any::1] = CMDgroup_min 
	comment "grouped tail minimum";
command max(b:BAT[oid,any::1], e:BAT[oid,any]) : BAT[oid,any::1] = CMDgroup_max 
	comment "grouped tail maximum";

command count(b:BAT[oid,any], e:BAT[oid,any]) : BAT[oid,int] = CMDgroup_count 
	comment "grouped count";
command size(b:BAT[oid,bit], e:BAT[oid,any]) : BAT[oid,int] = CMDgroup_size
	comment "grouped count of true values";


command prelude()= groupPrelude;
prelude();
@-
old stuff
    proc size(BAT[any,bit] b) : int {
	var h := b.histogram;
	if (h.exist(true)) 
	    return h.find(true);
	return 0;
    }

    proc avg(BAT[any, any::1] b) : any::1 {
	var cnt := count(b);
        if (cnt = 0) 
	    return cast(0,ttype(b));
	return /(sum(b),cast(cnt,ttype(b)));
    }

    proc card(BAT[any,any] b) : int {
	return b.tunique.count;
    }

    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
	return {count}(b.sunique,e);
    }

@- 
multi-group: groupings on different bats that produce the same encodings. these
can be used for multi-attribute join.
FUTURE STUFF
command multigroup(a:BAT[any::1,any]) : BAT[BAT[oid,oid],void] = CTmultigroup 
comment "Group multiple BATs passed in the head of the first parameter.
         Passing is either direct thourgh nested BATs or as string (identified by name); 
         This multi-BAT CTgroup guarantees same group oids for same values";

command multiderive(a:BAT[any::1,any::2]) : BAT[BAT[oid,oid],void] = CTmultiderive 
comment "Group multiple BATs passed in the head (ct) and tail (attr) of the first parameter, 
         Passing is either direct thourgh nested BATs or as string (identified by name); 
         This multi-BAT CTderive guarantees same group oids for same values";

command multiregroup(a:BAT[any::1,any::2]) : BAT[BAT[oid,oid],void] = CTmultiregroup 
comment "Re-group multiple BATs passed in the head (ct) and tail (attr) of the first parameter, 
         Passing is either direct thourgh nested BATs or as string (identified by name); 
         This multi-BAT CTregroup guarantees same group oids for same values";
@- 
Old stuff to be (re)moved
.LOAD
     PROC CTorderby(bat[oid,any] b, bat[oid,any] a) : bat[oid,oid] {
         if (not(b.reverse.ordered)) {
                b := b.reverse.sort.reverse;
         }
         return CTrefine(b,a);
     }

     PROC CTsubgroup(BAT[oid,oid] ct, BAT[oid,any] b, BAT[oid,any] sel) : BAT[oid,oid] 
     		return ct.CTgroup(b.semijoin(sel));

     PROC {count}(BAT[oid,bit] sel, BAT[oid,oid] ct, BAT[oid,int] dom) : BAT[oid,int] 
		return {count}([sel?ct:], dom);

     PROC {count}(BAT[void,bit] sel, BAT[void,oid] ct, BAT[oid,int] dom) : BAT[oid,int] 
		return CTsubhisto(sel, ct, dom);

     proc orderby_table(str fcn, str spec, ..bat[any::1,any]..) {
             var meta := new(str,str,$0);
             var first := int(spec) + 2;
             var b := $(first);
             var s := b.reverse.sort.reverse;
     
             while(true) {   
                     var idx := spec.search(',');
                     if (idx < 0) break;
                     spec := spec.string(idx + 1);   
                     s := s.CTrefine($(int(spec) + 2));
             }
             var bb := s.mirror.outerjoin(b);
             var i := 2;
             meta.insert("int", str(first - 2));
             while((i :+= 1) <= $0) {
                     if (i = first) {
                         meta.insert("BAT", str(bb));
                     } else {
                         meta.insert("BAT", str($(i)));
                     }
             }
             call(fcn, meta);
     }
     
     proc table(str spec, bat[any::1,any] b, ..bat[any::1,any]..) {
             orderby_table("table", $(1..));
     }
     
     proc print(str spec, bat[any::1,any] b, ..bat[any::1,any]..) {
             orderby_table("print", $(1..));
     }

@* Implementation Code
The xtables modules relies on further initialization of the
GDK atom table with the primitives to deal with mapentries en
indxentry.
@c
#include "gdk.h"
static int TYPE_mapentry;
static int TYPE_idxentry;
@+ Core Grouping Algorithms
@T
We use hash-grouping all the way. This implementation employs
a simple sequential scan through the operands, adding group
values to a hash-table. This hash-table gives access to the group
identifiers, which are always OIDs.

This strategy is also followed on binary groupings; here 
we construct a special integer consisting of the XORed hashnumber 
of both columns. In such a way, we can build a hash table on
map\_entries (instead of simple atomic values -- the unary case).

In the unary group case, we optimized processing on 1-byte
and 2-byte values by using direct mapping in an array instead of 
hashing.
@c
#define HASH_chr(p) ((unsigned int) (*(unsigned char*) (p)))
#define HASH_sht(p) ((unsigned int) (*(unsigned short*) (p)))
#define HASH_int(p) (*(unsigned int*) (p))
#define HASH_lng(p) (((unsigned int*)(p))[0]^((unsigned int*)(p))[1])
#define HASH_any(p) ((unsigned int) (*hashfcn)(p))

#define match_sync(b,p,r) r += yy
#define match_hash(b,p,r) BUNfndOID(r,b,p); if (r == NULL) continue;

#define declare_atom int any = b->ttype; unsigned int (*hashfcn)() = BATatoms[any].atomHash;
#define declare_simple /* any and hash would otherwise give unused variable warning */

#define htype_sync(b) BAThdense(b)?TYPE_void:TYPE_oid
#define htype_hash(b) TYPE_oid

#define ttype_simple(b,t) t 
#define ttype_atom(b,t) b->ttype 

#define STANDARD_MASK 1023

/* 
   Note:
     following macros take advantage of clustered property;
     if b is clustered, then we can stop early traversing collision lists.

     BTW, simply stopping possibly breaks chain construction, so the resulting
     map is not directly reuseable as a hash table; the current Monet cannot
     however handle multiple accellerators, so this ain't a real problem for now :)
 */
						    
#define declare_unclustered /* avoid warning */
#define declare_clustered   int samecluster = TRUE;

#define chain_unclustered   for (zz = hash[c]; zz > 0; zz = e->link)
#define chain_clustered     for (zz = hash[c]; (zz > 0) && (samecluster); zz = e->link)

#define tst_grp_unclustered(eq,p,t)    (eq(p, tcur, t))
#define tst_grp_clustered(eq,p,t)      (samecluster = eq(p, tcur, t))

#define tst_derive_unclustered(eq,p,t) (e->hcur == hcur && eq(p, tcur, t))
#define tst_derive_clustered(eq,p,t)   ((samecluster = e->hcur == hcur) && eq(p, tcur, t))

typedef struct {
	oid hcur;		/* old group id */
	int link;		/* hash link */
} idxentry_t;

typedef struct {
	oid hcur;		/* old group id */
	int link;		/* hash link */
	oid gid;		/* new group id */
	int cnt;		/* histogram count */		
} mapentry_t;

typedef struct {
	BAT *map;		/* [mapentry,value] elements */
	int *hash, mask;	/* hash buckets and mask */
	Heap hp;		/* storage for hash buckets */
} map_T;

groupPrelude(){
	/* printf("#init group\n");*/
	TYPE_mapentry = malAtomFixed(16,4);
	TYPE_idxentry = malAtomFixed(8,4);
	return GDK_SUCCEED;
}
@:map_init_def(STANDARD,STANDARD_MASK,4096)@
@:map_init_def(CUSTOM,custom_MASK,custom_rng)@

@= map_init_def
#define map_init_@1(map,hash,mask,entry,mapsize)\
	if (m) {\
		map = m->map; hash = m->hash; mask = m->mask;\
    	} else {\
		map = BATnew(TYPE_mapentry, tailtype(b,TRUE), @3);\
		hash = (int*) alloca(sizeof(int)*((mask=@2)+1));\
		for(xx=0; xx<=@2; xx++) {\
			hash[xx] = 0;\
		}\
    	}entry.hcur=0; entry.link=0;entry.gid=0; entry.cnt = 1;\
	mapsize = BUNindex(map, BUNlast(map));
@c

map_T map_multigroup(int size, int heap, int tt) {
	int xx, yy;
	map_T m;

	/* trick: use idxentry instead of mapentry as multigroup does not use last 2 fields */
	m.map = BATnew(TYPE_idxentry, tt, 100); 

	/* trick: very carefully alloc the map BAT to exactly the right size */
	DELTAsave(m.map);
	HEAPextend(m.map->batBuns, size*BUNsize(m.map));
	if (m.map->theap.base) {
		HEAPextend(&m.map->theap, heap);
	}
	DELTAload(m.map);

	/* init the hash table */
	for(xx=1; (xx+xx) < size; xx+=xx);
	HEAPalloc(&m.hp, xx, sizeof(int));
	m.mask = xx-1;
	m.hash = (int*) m.hp.base;

	for(yy=0; yy<xx; yy++) {
		m.hash[yy] = 0;
	}
	return m;
}

void map_free(map_T m) {
	BBPreclaim(m.map);
	HEAPfree(&m.hp);
}

BAT *map2histo(BAT *map) {
	if (map == NULL || map->htype != TYPE_mapentry || VIEWparent(map) ||
	    map->batSharecnt > 1 || BATgetaccess(map) != BAT_WRITE) 
	{
		if (map) BBPreclaim(map);
		return NULL;
	}
        /* trickily transform a bat[mapentry,any] into bat[oid,int] */
	map->htype = BATmirror(map)->ttype = TYPE_oid;
	map->ttype = BATmirror(map)->htype = TYPE_int;
	strcpy(map->hatom, "oid");
	strcpy(map->tatom, "int");
	if (map->tvarsized && map->theap.base) {
		HEAPfree(&map->theap);
	}
	BATmirror(map)->hvarsized = map->tvarsized = 0;
	BATmirror(map)->dims.tailloc = 
	    map->dims.headloc = map->dims.headloc + 8;
	BATmirror(map)->dims.headloc = 
	    map->dims.tailloc = map->dims.headloc + 4;
	return map;
}
 
@T
The group macro is split along three dimensions:
\begin{description}
\item [type:] Type specific implementation for selecting the right
hash function and data size etc.;
\item [clustered:] The \{clustered and unclustered\} select the
appropriate algorithm, i.e., with or without taking advantage of 
an order of values in the parent groups;
\item [physical properties:] Values \{standard and custom\}, 
chosing between a fixed predefined and a custom hashmask. Custom
allows the user to determine the size of the hashmask (and indirectly 
the estimated size of the result). The hashmask is $2^n - 1$ where $n$ 
is given by the user, or 1023 otherwise, and the derived result
size is $4 \cdot 2^n$.
\end{description}

Further research should point out whether fitting a simple statistical 
model (possibly a simple mixture model) can help choose these parameters 
automatically; the current idea is that the user (which could be a
domain-specific extension of the higher-level language) knows the 
properties of the data, especially for IR in which the standard grouping
settings differ significantly from the original datamining application.
@c

#define group_params_STANDARD /* fixed */
#define group_params_CUSTOM   int custom_MASK, int custom_rng,

@= CTgroup
BAT *CTgroup_@1_@4_@5( group_params_@5 BAT *b, BAT *bn, map_T *m ){
	oid *dst = (oid*) BUNfirst(bn);
	int xx, zz, *hash, mask, mapsize;
	mapentry_t entry, *e;
	BUN p, q, r;
	BAT *map;
	declare_@3
 
	map_init_@5(map,hash,mask,entry,mapsize); 

	/* core hash grouping algorithm */
	BATloopFast(b, p, q, xx) {
		declare_@4
		ptr tcur = BUN@2(b,p);

		/* hash-lookup of 'tcur' in map */
    		unsigned int c = HASH_@1(tcur);
		c = mix_int(c) & mask;
		chain_@4 {
			r = BUNptr(map,zz);
			e = (mapentry_t*) BUNhloc(map,r);
			if (tst_grp_@4(@3_EQ, BUN@2(map,r), @1)) {
				if (m == NULL) e->cnt++; 
				goto found;
			} 
		} 

		/* not found-> insert new element in map (and hash) */ 
		if (m) {
		  	zz = mapsize;
		} else {
			entry.gid = *(oid*) BUNhead(b,p);
		}
		entry.link = hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

found:		/* ultra-fast 'insert' of [oid,gid] into ct */
		if (bn->htype) *dst++ = *(oid*) BUNhead(b,p);
		*dst++ = m?zz:e->gid;
	}
	bn->batBuns->free = ((BUN) dst) - bn->batBuns->base; 
	bn->tsorted = 0;
	ALIGNsetH(bn,b);
	return m?NULL:map2histo(map);
} 
@c
int tailtype(BAT *b, int str_trick) {
	int tpe = ATOMstorage(b->ttype); /* standard type remappings */

	/* more daring remappings possible under simple equality */
	if (tpe == TYPE_flt) {
		return TYPE_int; 
	} else if (tpe == TYPE_dbl) {
		return TYPE_lng; 
	} else if (tpe == TYPE_str && str_trick && GDK_ELIMDOUBLES((&b->theap))) {
		return TYPE_int; /* string offsets are identifying integers */
	}
	return tpe;
}
@-
Generate both 'normal' CTgroup and clustered CTgroups 
@= wrappedgroupinner
@:CTgroup(chr,tloc,simple,@1,@2)@
@:CTgroup(sht,tloc,simple,@1,@2)@
@:CTgroup(int,tloc,simple,@1,@2)@
@:CTgroup(lng,tloc,simple,@1,@2)@
@:CTgroup(any,tail,atom,@1,@2)@

@-
Generate both 'normal' CTgroup and parameterized CTgroups.
@= wrappedgroupouter
@:wrappedgroupinner(unclustered,@1)@
@:wrappedgroupinner(clustered,@1)@

@= returnvalue
        @1 =
@= getBATdescriptor
        if( BBPcheck(*@2,@4)==0) return GDK_FAIL;
        @3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) { *@1 = 0; return GDK_FAIL; } 
	if(*@2 < 0) @3 = BATmirror(@3);
@c

@:wrappedgroupouter(STANDARD)@
@:wrappedgroupouter(CUSTOM)@

#define declare_mask_STANDARD	/* fixed */
#define declare_mask_CUSTOM 	int mask = (1 << *N) - 1;

int
CTgroup(int *rethisto, int *retbid, int *bid)
{
	@:CTgroupbody(STANDARD)@

	bn->tsorted = 0;
	ALIGNsetH(bn, b);

	*retbid = bn->batCacheid;
	BBPfix(*retbid);
	if(histo){
		*rethisto = histo->batCacheid;
		BBPfix(*rethisto);
	}
	return GDK_SUCCEED;
}
int
CTgroup2(int *retbid, int *bid)
{	int histo=0,ret;
	ret=CTgroup(&histo,retbid,bid);
	BBPunfix(histo);
	return ret;
}

int
CTgroup_custom(int *rethisto, int *retbid, int *bid, int *N, int *rng)
{
	@:CTgroupbody(CUSTOM)@
	bn->tsorted = 0;
	ALIGNsetH(bn, b);

	*retbid = bn->batCacheid;
	*rethisto = histo? histo->batCacheid: 0;
	BBPfix(*retbid);
	if(histo) BBPfix(*rethisto);
	return GDK_SUCCEED;
}

@= CTgroupbody
        declare_mask_@1 
	BAT *histo= 0, *bn=0;
	BAT *b;
	@:getBATdescriptor(retbid,bid,b,"CTgroup")@
	bn = BATnew(b->htype, TYPE_oid, BATcount(b));

	/* Poor man's clustered test: sorted & !keyed => clustered  */
	if ( (b->tsorted) && !(b->tkey) ) {
	  @:choosegroup@1(tailtype(b,TRUE),bn,NULL,clustered,histo)@
	} else {
	  @:choosegroup@1(tailtype(b,TRUE),bn,NULL,unclustered,histo)@
	}

@-

@= choosegroupSTANDARD
	/* Choose appropriate @4 CTgroup implementation */
	switch(@1) {
	case TYPE_chr: histo= CTgroup_chr_@4_STANDARD(b,@2,@3); break;
	case TYPE_sht: @?@5:returnvalue(@5)@ CTgroup_sht_@4_STANDARD(b,@2,@3); break;
	case TYPE_int: @?@5:returnvalue(@5)@ CTgroup_int_@4_STANDARD(b,@2,@3); break;
	case TYPE_lng: @?@5:returnvalue(@5)@ CTgroup_lng_@4_STANDARD(b,@2,@3); break;
	default:       @?@5:returnvalue(@5)@ CTgroup_any_@4_STANDARD(b,@2,@3);
	}
@c

@= choosegroupCUSTOM
	/* Choose appropriate @4 CTgroup implementation */
	switch(@1) {
	case TYPE_chr: 
	  @?@5:returnvalue(@5)@ CTgroup_chr_@4_CUSTOM(mask,*rng,b,@2,@3); 
	  break;
	case TYPE_sht: 
	  @?@5:returnvalue(@5)@ CTgroup_sht_@4_CUSTOM(mask,*rng,b,@2,@3);
	  break;
	case TYPE_int: 
	  @?@5:returnvalue(@5)@ CTgroup_int_@4_CUSTOM(mask,*rng,b,@2,@3); 
	  break;
	case TYPE_lng: 
	  @?@5:returnvalue(@5)@ CTgroup_lng_@4_CUSTOM(mask,*rng,b,@2,@3); 
	  break;
	default:       
	  @?@5:returnvalue(@5)@ CTgroup_any_@4_CUSTOM(mask,*rng,b,@2,@3);
	}
@c

static str batsig(BAT *b, str nme) {
	if (b) {
		sprintf(nme, "%s[%s,%s]", b->batId, ATOMname(b->htype), ATOMname(b->ttype)); 
	} else {
		strcpy(nme, "null");
	}
	return nme;
}

int
CTmultigroup(int *retid, int *bmid){
	BAT**        retval; /* put pointer to BAT[oid,oid] record here. */
	BAT*         bm;   /* pointer to BAT[BAT,any] record.*/
	int maxsize = 0, error, attrfix = FALSE, xx, t, tt=-1;
	size_t maxheap = 0;
	char nme[128];
 	BAT *b, *bn, *ct;
	map_T m;
        BUN p,q;
	bat bid;

	@:getBATdescriptor(retid,bmid,bm,"CTmultigroup")@

	if (bm->htype == TYPE_str) {
		attrfix = TRUE;
	} else if (bm->htype != TYPE_bat) {
		GDKerror("CTmultigroup: meta-bat %s should have BAT or str head column.\n", batsig(bm,nme)); 
		return GDK_FAIL;
	}
        BATloopFast(bm, p, q, xx) {
		if (attrfix) {
			bid = BBPindex((str)BUNhead(bm,p));
			BBPfix(bid);
		} else {
			bid = *(bat*)BUNhloc(bm,p);
		}
		b = BATdescriptor(bid);

		error = (b == NULL || ATOMtype(b->htype) != TYPE_oid);
		if (!error) {
			if (b && tt < 0) {
				t = b->ttype;
				tt = tailtype(b, FALSE);
			}
			maxsize = MAX(maxsize,BATcount(b));
			maxheap = MAX(maxheap,b->theap.free);
			error = (b->ttype != t);
		}
		if (attrfix) {
			BBPunfix(bid);
		}
		if (error) {
			GDKerror("CTmultigroup: illegal param %d (%s)\n", 
				1 + BUNindex(bm,p) - BUNindex(bm,BUNfirst(bm)), batsig(b,nme));
			return GDK_FAIL;
		}
        }
        bn = BATnew(TYPE_bat, TYPE_void, BATcount(bm));
	*retid = bn->batCacheid;
	if (tt != ATOMstorage(TYPE_oid)) {
		m = map_multigroup(maxsize+1, maxheap, tt);
	} 
        BATloopFast(bm, p, q, xx) {
		if (attrfix) {
			bid = BBPindex((str)BUNhead(bm,p));
			BBPfix(bid);
		} else {
			bid = *(bat*)BUNhloc(bm,p);
		}
		b = BATdescriptor(bid);
		if (tt != ATOMstorage(TYPE_oid)) {
			BAT *histo;
			ct = BATnew(b->htype, TYPE_oid, BATcount(b));
			/* Poor man's clustered test: sorted & !keyed => clustered  */
			if ( (b->tsorted) && !(b->tkey) ) {
			  @:choosegroupSTANDARD(tt,ct,&m,clustered)@
			} else {
			  @:choosegroupSTANDARD(tt,ct,&m,unclustered)@
			}
		} else {
			if (t < TYPE_int && t > TYPE_oid) {
				ct = VIEWcreate_(b, TRUE);
			} else {
				ct = b; BBPfix(b->batCacheid);
			}
			ct->ttype = BATmirror(ct)->htype = TYPE_oid;
			ct->tvarsized = BATmirror(ct)->hvarsized = FALSE;
			ct->theap.base = NULL;
			strcpy(ct->tatom, "oid");
		}
		BUNins(bn, &ct->batCacheid, NULL);
		BBPunfix(ct->batCacheid);
		if (attrfix) {
			BBPunfix(bid);
		}
	}
	if (tt != ATOMstorage(TYPE_oid)) {
		map_free(m);
	}
	return GDK_SUCCEED;
}

@= derive
BAT* CTderive_@1_@2_@5(BAT* ct, BAT *b, BAT *bn, map_T *m) { 
	oid *dst = (oid*) BUNfirst(bn);
	int zz, xx, yy = BUNsize(ct), *hash, mask, mapsize;
	BUN p, q, r, cp = BUNfirst(ct) - yy;
	mapentry_t entry, *e;
	BAT *map;
	declare_@4
   
	map_init_STANDARD(map,hash,mask,entry,mapsize); 

	/* core hash grouping algorithm */
	BATloopFast(b, p, q, xx) {
		ptr tcur = BUN@3(b,p);
		unsigned int c;
		oid hcur;
		declare_@5

		/* find corresponding value in 'ct' */
		match_@1(ct, BUNhead(b,p), cp); 
		hcur = *(oid*) BUNtloc(ct,cp);

		/* hash-lookup of [hcur,tcur] in map */
		c = (((unsigned int) hcur) ^ HASH_@2(tcur));
		c = mix_int(c) & mask;
		chain_@5 {
			r = BUNptr(map,zz);
			e = (mapentry_t*) BUNhloc(map,r);
			if (tst_derive_@5(@4_EQ, BUN@3(map,r), @2)) {
				if (m == NULL) e->cnt++; 
				goto found;
			} 
		} 
		/* not found-> insert new element in map (and hash) */ 
		if (m) {
			zz = mapsize;
		} else {
			entry.gid = *(oid*) BUNhead(b,p);
		}
		entry.hcur = hcur;
		entry.link =  hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

found:		/* ultra-fast 'insert' of [oid,gid] into ct */
		if (bn->htype) *dst++ = *(oid*) BUNhead(b,p);
		*dst++ = m?zz:e->gid;
	}
	bn->batBuns->free = ((BUN) dst) - bn->batBuns->base; 
	return m?NULL:map2histo(map);
}

@c

/* Generate both 'normal' CTderive and clustered CTderive */
@= wrappedderive
@:derive(sync,chr,tloc,simple,@1)@
@:derive(sync,sht,tloc,simple,@1)@
@:derive(sync,int,tloc,simple,@1)@
@:derive(sync,lng,tloc,simple,@1)@
@:derive(sync,any,tail,atom,@1)@
@:derive(hash,chr,tloc,simple,@1)@
@:derive(hash,sht,tloc,simple,@1)@
@:derive(hash,int,tloc,simple,@1)@
@:derive(hash,lng,tloc,simple,@1)@
@:derive(hash,any,tail,atom,@1)@
@c
@:wrappedderive(unclustered)@
@:wrappedderive(clustered)@

@= choosederive
	/* Choose appropriate (@1 && @2) CTderive implementation */
	switch(tt) {
	case TYPE_chr: histo = CTderive_@1_chr_@2(ct,b,bn,m); break;
	case TYPE_sht: histo = CTderive_@1_sht_@2(ct,b,bn,m); break;
	case TYPE_int: histo = CTderive_@1_int_@2(ct,b,bn,m); break;
	case TYPE_lng: histo = CTderive_@1_lng_@2(ct,b,bn,m); break;
	default:       histo = CTderive_@1_any_@2(ct,b,bn,m);
	}
@c

int derive(BAT** retval, BAT* ct, BAT* b, int tt, map_T *m) {
	BAT *histo, *bn = *retval;
	int synced = ALIGNsynced(ct,b);

	/* preprocess/create the result bat 'bn' */
	if (bn) {
		ACCremoveall(bn);
	} else {
		int ht = (synced&&BAThdense(b))?TYPE_void:TYPE_oid;
		bn = BATnew(ht, TYPE_oid,BATcount(b));
	}

	/* CTderive with correct lookup method (hash,synced) and type */
	if (synced) {
	   if ((ct->tsorted) && !(ct->tkey)) {
		@:choosederive(sync,clustered)@
	   } else {
		@:choosederive(sync,unclustered)@
           }
	} else {
	   if ((ct->tsorted) && !(ct->tkey)) {
		@:choosederive(hash,clustered)@
	   } else {
		@:choosederive(hash,unclustered)@
           }
	}

	/* postprocess the result bat 'bn' */
	bn->tsorted = 0;
	if (BATcount(bn) == BATcount(b)) {
		ALIGNsetH(bn, b);
	} else {
		bn->hsorted = BAThordered(b);
		if (b->hkey) BATkey(bn, TRUE);
	}
@-
	if (histo) {
		CTbuild_hl(&bn->taccelerator, &histo->batCacheid, BATmirror(bn));
	}
@c
	*retval = bn;
	return GDK_SUCCEED;
}

int regroup(BAT** retval, BAT* ct, BAT* b, int tt, map_T *m) {
	*retval = BATsetaccess(ct, BAT_WRITE);
	return derive(retval, ct, b, tt, m);
}

int CTregroup(int* retid, int* ctid, int* bid) {	
	BAT** retval, *dummy, * ct, * b;
	int ret;

	@:getBATdescriptor(retid,ctid,ct,"CTderive")@
	@:getBATdescriptor(retid,bid,b,"CTderive")@
	BBPfix(ct->batCacheid);
	retval= & dummy;
	ret= regroup(retval, ct, b, tailtype(b, TRUE), NULL);
	if( ret== GDK_SUCCEED) *retid= dummy->batCacheid;
	return ret;
}

int CTderive(int* mapid, int* retid, int  *ctid, int* bid) {	
	BAT **retval, *dummy, *ct, *b;
	BAT *bn = NULL;
	int ret;

	@:getBATdescriptor(retid,ctid,ct,"CTderive")@
	@:getBATdescriptor(retid,bid,b,"CTderive")@
	if (tailtype(ct, TRUE) != TYPE_int) {
		/* if (!CTgroup(&bn, ct)) return GDK_FAIL;*/
		int rethisto,retbid, bid= ct->batCacheid;
		if (!CTgroup(&rethisto,&retbid, &bid)) return GDK_FAIL;
		ct = bn;
	} 
	retval= &dummy; *retval = NULL;
	ret = derive(retval, ct, b, tailtype(b, TRUE), NULL);
	if (bn) BBPreclaim(bn);
	if( ret== GDK_SUCCEED) *retid= dummy->batCacheid;
	/* no map yet */
	*mapid=0;
	return ret;
}
int CTderive2(int* retid, int  *ctid, int* bid) {	
	int dummy;
	return CTderive(&dummy,retid,ctid,bid);
}


BAT *multiderive(BAT* bm, int overwrite) {
	int error, ctfix = FALSE, attrfix = FALSE, ctready = TRUE;
	char nme1[128], nme2[128]; 
        int maxsize = 0, xx, yy, t, tt=-1;
	size_t maxheap = 0;
        BAT *tmp, *b, *ct, *ret=NULL;
	map_T m;
        BUN p, q, r;
	bat bid, cid;

	if (bm->htype == TYPE_str) {
		ctfix = TRUE;
	} else if (bm->htype != TYPE_bat) {
		GDKerror("CTmultiderive: meta-bat %s should have BAT or str head column.\n", batsig(bm,nme1));
	}
	if (bm->ttype == TYPE_str) {
		attrfix = TRUE;
	} else if (bm->ttype != TYPE_bat) {
		GDKerror("CTmultiderive: meta-bat %s should have BAT or str tail column.\n", batsig(bm,nme1));
	}
        BATloopFast(bm, p, q, xx) {
		if (ctfix) {
			cid = BBPindex((str)BUNhead(bm,p));
			BBPfix(cid);
		} else {
			cid = *(bat*)BUNhloc(bm,p);
		}
		if (attrfix) {
			bid = BBPindex((str)BUNtail(bm,p));
			BBPfix(bid);
		} else {
			bid = *(bat*)BUNtloc(bm,p);
		}
		ct = BATdescriptor(cid);
		b = BATdescriptor(bid);

		error = (ct == NULL || ATOMtype(ct->htype) != TYPE_oid ||
 		          b == NULL || ATOMtype(b->htype) != TYPE_oid); 
		if (!error) {
			if (b && tt < 0) {
				t = b->ttype;
				tt = tailtype(b, FALSE);
			}
			error = (b->ttype != t);
			if (ATOMstorage(ct->ttype) != ATOMstorage(TYPE_oid)) {
				ctready = FALSE;
			}
			maxsize = MAX(maxsize, MIN(BATcount(b),BATcount(ct)));
			maxheap = MAX(maxheap, b->theap.free);
		}
		if (attrfix) {
			BBPunfix(bid);
		}
		if (ctfix) {
			BBPunfix(cid);
		}
		if (error) {
			GDKerror("CTmultiderive: illegal params %d (%s, %s)\n", 
				1 + BUNindex(bm,p) - BUNindex(bm,BUNfirst(bm)), 
				batsig(ct,nme1), batsig(b,nme2));
			return NULL;
		}
        }

	/* enforce ct tailtype into oid (gratis if already so) */
	if (ctready) {
		tmp = bm;
	} else { int tmpid= tmp->batCacheid, bmid= bm->batCacheid;
		if (CTmultigroup(&tmpid, &bmid) == GDK_FAIL) {
		return NULL;
		}
	} 

	/* perform binary hash grouping on all bats */
        ret = BATnew(TYPE_bat, TYPE_void, BATcount(bm)); 
	m = map_multigroup(maxsize+1, maxheap, tt);
	yy = BUNsize(tmp);
	r = BUNfirst(tmp);

        BATloopFast(bm, p, q, xx) {
		BAT *bn = NULL;
		if (ctready && ctfix) {
			cid = BBPindex((str)BUNhead(bm,p));
			BBPfix(cid);
		} else {
			cid = *(bat*)BUNhloc(tmp,r);
		}
		if (attrfix) {
			bid = BBPindex((str)BUNtail(bm,p));
			BBPfix(bid);
		} else {
			bid = *(bat*)BUNtloc(bm,p);
		}
		ct = BATdescriptor(cid);
		b = BATdescriptor(bid);

		error = !(overwrite?regroup(&bn, ct, b, tt, &m):
			  	    derive(&bn, ct, b, tt, &m)); 
		if (attrfix) {
			BBPunfix(bid);
		}
		if (ctready && ctfix) {
			BBPunfix(cid);
		}
		if (error) {
			BBPreclaim(ret); 
			ret = NULL; 
			break;
		}
		BUNins(ret, &bn->batCacheid, NULL);
		if (!overwrite) {
			BBPunfix(bn->batCacheid);
		}
		r += yy;
	}
	map_free(m);
	if (!ctready) {
		BBPreclaim(tmp);
	}
	return ret;
}

int CTmultiderive(int* retid, int* bmid) {
	BAT *retval, *bm;
	@:getBATdescriptor(retid,bmid,bm,"CTmultiderive")@
	retval = multiderive(bm, FALSE);
	if( retval) *retid= retval->batCacheid;
	return retval?GDK_SUCCEED:GDK_FAIL;
}

int CTmultiregroup(int* retid, int* bmid) {
	BAT *retval, *bm;
	@:getBATdescriptor(retid,bmid,bm,"CTmultiregroup")@
	retval = multiderive(bm, TRUE);
	if( retval) *retid= retval->batCacheid;
	return retval?GDK_SUCCEED:GDK_FAIL;
}

@-
The routine CThistosum takes an grouping and a histogram and produces
a new histogram by summing the old values within the same group.
@c
int
CThistosum(int *retid, int *bid, int *cid){
	BAT *b, *c;
        BAT *res;
        BUN p,q, qb;
        int xx,i,*z;
        oid ot,oh;

	@:getBATdescriptor(retid,bid,b,"CThistosum")@
	@:getBATdescriptor(retid,cid,c,"CThistosum")@

        res = BATnew(TYPE_oid,TYPE_int, BATcount(b));

	BATloopFast(b,p,q,xx) {
		oh = *(oid *) BUNhloc(b,p);
		i  = *(int *) BUNtloc(b,p);

		BUNfndOID(qb, b, &oh);
		if( qb == NULL ) {
			GDKerror("CThistosum:Matching count entry not found\n");
			continue;
		}
		ot = *(oid *) BUNtloc(b,qb);

		BUNfndOID(qb, res, &ot);
		if( qb == NULL) {
			BUNins(res, &ot, &i);
		} else {
			z = (int *) BUNtloc(res,qb);
			*z += i;
		}
	}
	res->hsorted = res->tsorted = 0;
	*retid = res->batCacheid;
	return GDK_SUCCEED;
}



int CTsubhisto(int *retid, int *selid, int *grpid, int *domid) {
	BAT *sel, *grp, *dom;
	bit *filter;
        int mask, size, xx, yy, zz;
	unsigned int *r, *base, *hash;
        BUN p, q;
	BAT *bn;

	@:getBATdescriptor(retid,selid,sel,"CTsubhisto")@
	@:getBATdescriptor(retid,grpid,grp,"CTsubhisto")@
	@:getBATdescriptor(retid,domid,dom,"CTsubhisto")@

	filter = (bit*) BUNtloc(sel,BUNfirst(sel));
        size=BATcount(dom); yy=3; zz=BUNsize(sel);

	/* we know the domain; go for perfect hashing */
	for(mask=1; mask<size; mask<<=1);
	if (mask < 256) mask = 256;
	hash = (unsigned int*) GDKmalloc(sizeof(int)*mask);
        for(xx = 0; xx < mask; xx++) {
        	hash[xx] = 0;
	} mask--;

	/* insert all values in the hash table, and in bn with count zero */
	bn = BATnew(TYPE_idxentry, TYPE_int, size);
	base = (unsigned int*) bn->batHole;
	r = base + yy;
        BATloopFast(dom, p, q, xx) { 
		unsigned int v = *(unsigned int*) BUNhloc(dom,p);
                unsigned int c = v & mask; 
		*r++ = v;
		*r++ = hash[c]; 
		*r++ = 0;
                hash[c] = yy; 
		yy += 3;
	}
	bn->batBuns->free = ((BUN) r) - bn->batBuns->base;
	bn->tsorted = 0;
	bn->htype = BATmirror(bn)->ttype = TYPE_oid;
	strcpy(bn->hatom, "oid");
	ALIGNsetH(bn, dom);

        /* add the counts for this selection using the hash table */
        BATloopFast(grp, p, q, xx) { 
	    if (*filter == TRUE) {
		unsigned int v = *(unsigned int*) BUNtloc(grp,p);
                unsigned int c = v & mask; 
                for(yy = hash[c]; yy > 0; yy = r[1]) {
			r = base + yy;
			if (r[0] == v) {
				r[2]++; break;
                        }
                }
  	    } filter += zz;
     
	}
	GDKfree(hash);
	*retid = bn->batCacheid;
        return GDK_SUCCEED;
}

@+ Support for Order-by
@c
#define DEFAULT_SIZE 10000

static INLINE
oid* sort_flush(int *buf, int size, int tpe, BUN base, oid* dst, oid *idp) {
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	int *end = buf + size; 
	oid id = *idp + 1;
	ptr cur, val;

	/* qsort works fine for small amount of tuples; with few duplicates */
	GDKqsort(buf, base, size/2, 2*sizeof(int), tpe, 0);  
	cur = base + buf[0];
	while(buf < end) {
		val = base + *(int*) buf++;
		if ((*cmp)(cur, val)) { cur=val; id++;}
		*dst++ = *buf++;
		*dst++ = id;
	}
	*idp = id;
	return dst;
}

int CTrefine(int *retid, int *bid, int *aid) {
    BAT *b, *a;
    BAT *bn;

    @:getBATdescriptor(retid,bid,b,"CTrefine")@
    @:getBATdescriptor(retid,aid,a,"CTrefine")@

    if (b->tkey) { /* if key, no further refinements can take place */
	bn = BATmark(b, 0);
    } else {
	int (*cmp)(ptr,ptr) = BATatoms[b->ttype].atomCmp;
	BUN p, q, r, last = BUNfirst(b), base = a->theap.base?NULL:a->batBuns->base;
	int *buf, *cur, *end, xx, size = DEFAULT_SIZE;
	oid *dst, o, id = 0;

	/* create tmp BAT that holds one cluster; estimate required size using sampling */
	if (BATcount(b) > DEFAULT_SIZE) { 
		BAT *sample = BATsample(b, DEFAULT_SIZE);
		BAT *histo = BAThistogram(sample);
		BATmax(histo,&xx);
		if (xx > 1) 
			size = MAX(size, xx*(((float) BATcount(b))/DEFAULT_SIZE));
		BBPreclaim(sample);
		BBPreclaim(histo);
	} 
	/* create a temporary BAT of the estimated size holding pointers to the a tail atoms */
	buf = cur = (int*) GDKmalloc(size*2*sizeof(int));
	end = buf + (size*2);

        /* create result BAT */
	bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
	bn->hsorted = bn->tsorted = FALSE;
	dst = (oid*) BUNfirst(bn);

  	/* merge-scan tail of b, finding chunks with equal values; then sort each chunk on a */
	BATloopFast(b, p, q, xx) {
		if ((*cmp)(BUNtail(b,last), BUNtail(b,p))) {
			dst = sort_flush(buf, cur-buf, a->ttype, base?base:a->theap.base, dst, &id);
		    	last = p; cur = buf;
		}
		o = *(oid*) BUNhead(b,p);
		BUNfndOID(r, a, &o);
		if (r == NULL) {
			*dst++ = o;
			*dst++ = id;
			continue;
		}
		if (cur >= end) {
			int off = cur - buf;
			buf = (int*) GDKrealloc(buf, (size*=2)*2*sizeof(int));
			end = buf + (size*2);
			cur = buf + off;
		}
		r += a->tloc;
		*cur++ = (base)?(r-base):*(int*) r;
		*cur++ = o;
	} 
	dst = sort_flush(buf, cur-buf, a->ttype, base?base:a->theap.base, dst, &id);
	GDKfree(buf);
	bn->batBuns->free = ((BUN) dst) - bn->batBuns->base;
	bn->tsorted = 1;
    } 
    *retid = bn->batCacheid;
    return GDK_SUCCEED;
}
@+ Test Script
@mil
module(aggr,decimal);

proc toset(bat[any,any] b) : str {
        var res := "{ ";
        b@batloop() {
                res :+= str($t) + " ";
        }
        return res + "}";
}

proc aggrtst(int num, int fanout, str aggr) {
	var p := 3;
	while((p :+= 1) <= $0) {
	        var b, e, v := bat(void, int, num);
	        var tpe := $(p);
	        var i := 0;
	        while(i < num) {
	                v.insert(nil, 42);
	                i :+= 1;
	        }
	        e := [oid](v.seqbase(0@0).reverse).reverse;
	        if (fanout = 1) {
	                b := bat(void,(*tpe)()).seqbase(0@0);
	        } else {
	                b := bat(oid,(*tpe)());
	        }
	        var n := 0; 
	        e@batloop() {
	                i := 0; 
	                while(i < fanout) {
	                        if  (($h = 0@0) and (i = 0)) {
	                                b.insert($h, (*tpe)(nil));
	                        } else {
	                                b.insert($h, (*tpe)(n));
                        	} 
                        	n :+= 1; i :+= 1;
                	}
                }
        	print({toset}(b).col_name("test-set"),
        	      (*aggr)(b).col_name(sprintf("%s(b)",aggr)),
        	      (*aggr)(b,v).col_name(sprintf("%s(b,v)",aggr)),
        	      (*aggr)(b,e).col_name(sprintf("%s(b,e)",aggr)));
        }
}

aggrtst(16,160,"{sum}","sht","int","lng","flt","dbl");
aggrtst(16,160,"{avg}","sht","int","lng","flt","dbl");
aggrtst(16,160,"{min}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{max}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{card}","sht","int","lng","flt","dbl","decimal");
aggrtst(16,160,"{count}","sht","int","lng","flt","dbl","decimal");

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates. 
@= getBATdescriptor
        if( BBPcheck(*@2,@4)==0) return GDK_FAIL;
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) {
                *@1 = 0;                                                                        return GDK_FAIL;
        }
@-
@= arithpump
int CMDgroup_sum_@1(int *retval, int *bid,int  *eid){
	BAT *ret, *b, *e;
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	@1 zero = (@1) 0;
	BUN p, q, r;
	int xx;

	@:getBATdescriptor(retval,bid,b,"CMDgroup_sum")@
	@:getBATdescriptor(retval,eid,e,"CMDgroup_sum")@
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add values to sums in-place */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			@1 *dst = (@1*) BUNtloc(bn, r);
			if (*dst != @1_nil) {
				if (*t == @1_nil) {	
					*dst = @1_nil;
				} else {
					*dst += *t;
				}
			} 
		}
	} 
	*retval = bn->batCacheid;
	return GDK_SUCCEED;
}

int CMDgroup_avg_@1(int *retval, int *bid,int  *eid){
	BAT *ret, *b, *e;
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	int xx, yy = 0, off = BUNindex(bn,BUNfirst(bn));
	int *cnt = (int*) GDKmalloc(BATcount(e)*sizeof(int)); 
	@1 zero = (@1) 0;
	BUN p, q, r;

	@:getBATdescriptor(retval,bid,b,"CMDgroup_avg")@
	@:getBATdescriptor(retval,eid,e,"CMDgroup_avg")@
	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	memset(cnt, 0, BATcount(e)*sizeof(int));
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, adding sums, and incrementing counts */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		BUNfndOID(r,bn,h);
		if (r) {
			@1 *dst = (@1*) BUNtloc(bn, r);
			if (*dst != @1_nil) {
				if (*t == @1_nil) {	
					*dst = @1_nil;
				} else {
					*dst += *t;
				}
				cnt[BUNindex(bn,r)-off]++;
			} 
		}
	} 
	/* postprocess by dividing sums by counts */
	BATloopFast(bn, p, q, xx) {
		@1 *dst = (@1*) BUNtail(bn, p);
		if (cnt[yy] == 0) {
			*dst = @1_nil;
		} else if (*dst != @1_nil) {
			*dst /= cnt[yy];
		} yy++;
	} 
	GDKfree(cnt);
	*retval = bn->batCacheid;
	return GDK_SUCCEED;
}
@c
@:arithpump(sht)@
@:arithpump(int)@
@:arithpump(lng)@
@:arithpump(flt)@
@:arithpump(dbl)@

@= extreme
int CMDgroup_@1(int *retval, int *bid,int  *eid){
	BAT *ret, *b, *e;
	BAT *bn;
	int (*cmp)(ptr,ptr);
	ptr nil;
	int xx, yy, off;
	ptr *extremes;
	BUN p, q, r;

	@:getBATdescriptor(retval,bid,b,"CMDgroup_@1")@
	@:getBATdescriptor(retval,eid,e,"CMDgroup_@1")@

	bn = BATnew(e->htype, BATttype(b), BATcount(e));	
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	yy = 0; off = BUNindex(e,BUNfirst(e));
	extremes = (ptr*) GDKmalloc(BATcount(e)*sizeof(ptr)); 

	/* init: set all extremes to the zero pointer */
	memset(extremes, 0, BATcount(e)*sizeof(ptr)); 

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	(void) BATprepareHash(e);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		ptr t =  BUNtail(b,p);

		BUNfndOID(r,e,h);
		if (r) {
			ptr *val = extremes + (BUNindex(e,r) - off);
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @2 0) {
					*val = t;
				}
			}
		}
	} 
	/* insert the extreme values into the result */
	BATloopFast(e, p, q, xx) {
		ptr val = extremes[yy++];
		BUNfastins(bn, BUNhead(e,p), val?val:nil); 
	} 
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	GDKfree(extremes);
	*retval = bn->batCacheid;
	return GDK_SUCCEED;
}
@c
@:extreme(min,<)@
@:extreme(max,>)@

int CMDgroup_count(int *retval, int *bid,int  *eid){
	BAT *ret, *b, *e;
	BAT *bn ;
	int zero = 0;
	BUN p, q, r;
	int xx;

	@:getBATdescriptor(retval,bid,b,"CMDgroup_count")@
	@:getBATdescriptor(retval,eid,e,"CMDgroup_count")@
	/* init: set all sums to zero */
	bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);

		BUNfndOID(r, bn, h);
		if (r) {
			int *dst = (int*) BUNtloc(bn, r);
			(*dst)++;
		}
	} 
	*retval = bn->batCacheid;
	return GDK_SUCCEED;
}

int CMDgroup_size(int *retval, int *bid,int  *eid){
	BAT *ret, *b, *e;
	BAT *bn;
	int zero = 0;
	BUN p, q, r;
	int xx;

	@:getBATdescriptor(retval,bid,b,"CMDgroup_size")@
	@:getBATdescriptor(retval,eid,e,"CMDgroup_size")@
	bn = BATnew(e->htype, TYPE_int, BATcount(e));	
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		BUNfastins(bn, BUNhead(e,p), &zero);
	}
	/* scan b, and add increment totals for true values */
	(void) BATprepareHash(bn);
	BATloopFast(b, p, q, xx) {
		if (*(bit*) BUNtloc(b,p) == TRUE) {
			oid *h = (oid*) BUNhead(b,p);

			BUNfndOID(r, bn, h);
			if (r) {
				int *dst = (int*) BUNtloc(bn, r);
				(*dst)++;
			}
		}
	} 
	*retval = bn->batCacheid;
	return GDK_SUCCEED;
}
