@f bat
@t Binary Association Tables
@v 2.0
@a Peter Boncz, M.L. Kersten
@* Introduction
@T
This module contains the commands and patterns to manage Binary 
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a neat algebra, described in algebra.mx

All commands needed for BAT updates, property management,
search accellerator management, basic I/O, persistency, and storage options
can be found in this module.

BATs are always identified by their reference number in the BAT buffer pool.
We assume that these references are 'safe', i.e. they denote the intended
BAT. This means that front-ends should not destroy/remove temporary BATS
without garbage collection of the references held. The alternative way
is to call for a fresh reference to a BAT using its (hopefully) unique
name with the bind() command. A reference can be released using the
unbind(), but it is up to the buffer pool to actually release the
storage held.

@* Module Definition
Type parameters are represented by short integers. The MAL frontend
defines constants to simplify the mapping from type identifier to value.

Unlike the previous Monet versions, we reduce the number
of functions returning a BAT reference. This was previously needed 
to simplify recursive bat-expression.
In the current version we return only a BAT identifier when a new
bat is being created.

A pattern block may be required to make the proper translation to
the BAT library.
@-
All parameters to the modules are passed by reference.
In particular, this means that
string values are passed to the module layer as (str *)
and we have to de-reference them before entering the gdk library.
This calls for knowlegde on the underlying BAT typs`s
@= derefStr
	if( @1->@2type== TYPE_str) @3 = *(str *)@3;
@-
The code speaks for itself
@mal

module bat;

command bind(nme:str): bat[any,any] = CMDbind
comment "Locates the bat in the current dictionary";

command bind(dictionary:str,nme:str): bat[any,any] = CMDbind2
comment "Locates the bat in a specific dictionary";

command release(b:bat[any,any]):void = CMDrelease
comment "Release the BAT from the client pool";

pattern new(ht:any::1, tt:any::2) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty transient BAT, with head- and tail-types as indicated.";

pattern new(ht:any::1, tt:any::2, size:int) : bat[any::1,any::2] = CMDBATnew
comment "Creates a new empty BAT, directly allocating for 'size' elements.";

command reverse(b:bat[any::1,any::2]) : bat[any::2,any::1] = CMDreverse
comment "Returns the reverse view of a BAT (head is tail and tail is head).
 BEWARE:  no copying is involved; input and output refer to the same object!";

command mirror(b:bat[any::1,any]) : bat[any::1,any::1] = CMDmirror
comment "Returns the head-mirror image of a BAT (two head columns).";

command convert(b:bat[any::1,any::2] ) : int = CMDconvert
comment "Convert the contents of a BAT from little-endian to big-endian and vice versa.
 THIS command SHOULD NOT BE USED FROM MIL! DANGEROUS! DEBUGGING PURPOSES ONLY!";

command order(b:bat[any,any]) : int = CMDorder
comment "Sorts the BAT itself, in place. ";

command revert(b:bat[any,any]) : int = CMDrevert
comment "Puts all BUNs in a BAT in reverse order. (Belongs to the BAT sequence module)";

@- BAT updates
Update commands come in many disguises.  Note that we don;t return
the BAT id, but merely a success/failure code.
@mal
command insert(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: int = CMDinsert_bun
comment "Insert one BUN[h,t] in a BAT.";

command insert(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: int = CMDinsert_bat
comment "Insert all BUNs of the second BAT into the first.";

command replace(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: int = CMDreplace_bun
comment "Replace the tail value of one BUN that has some head value.";

command replace(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: int = CMDreplace_bat
comment "Perform replace for all BUNs of the second BAT into the first.";

command delete(b:bat[any::1, any::2], h:any::1, t:any::2) 
				: int = CMDdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[any::1, any::2], h:any::1) 
				: int = CMDdelete_head
comment "Delete all BUNs with a certain head value.";

command delete(b:bat[any::1, any::2]) 
				: int = CMDdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[any::1, any::2], src:bat[any::1,any]) 
				: int = CMDdelete_bat_head
comment "Delete from the first BAT all BUNs with a head value that is in the second.";

command deleteBuns(b:bat[any::1, any::2], src:bat[any::1,any::2]) 
				: int = CMDdelete_bat_bun
comment "Delete from the first BAT all BUNs with a corresponding BUN in the second.";

@- BAT properties 
Properties of BATs not necessarily require loading the BAT completely.
The BAT identifier can be used to access the descriptors.
RETHINK position of BatID
@mal
command capacity ( bid:int ) : int = CMDcapacity
comment "Returns the current allocation size (in max number of elements) of a BAT.";

command info ( b:BAT) : bat[str,str] = CMDinfo
comment "Produce a BAT containing info about a BAT in [attribute,value] format.
 It contains all properties of the BAT record. See the BAT documentation in
 GDK for more information.";
 
command htype ( bid:int ) : int = CMDhtype
comment "Returns the type of the head column of a BAT, as an integer type number.";
 
command ttype ( bid:int ) : int = CMDttype
comment "Returns the type of the tail column of a BAT, as an integer type number.";

command setKey( b:bat[any,any], mode:bit) :int = CMDsetkey
comment "Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
 the kernel will silently block insertions that cause a duplicate entries
 in the head column. 
 KNOWN BUG: when 'key' is set to TRUE, this function does not automatically 
 eliminate duplicates. Use b := b.kunique;";

command isaKey( b:bat[any,any]) : bit = CMDgetkey
comment "return whether the head column of a BAT is unique (key).";

command setSet( b:bat[any,any], mode:bit) : int = CMDsetset
comment "Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel 
 will silently block insertions that cause a duplicate BUN [head,tail] entries
 in the BAT. 
 KNOWN BUG: when 'set' is set to TRUE, this function does not automatically 
 eliminate duplicates. Use b := b.sunique;
 Returns the BAT itself.";

command isaSet( b:bat[any,any]) : bit = CMDisaSet
comment "return whether the BAT mode is set to unique.";

command setAccess( b:bat[any,any], mode:str) : int = CMDsetAccess
comment "Try to change the update access priviliges to this BAT. Mode:
 r[ead-only]      - allow only read access.
 a[append-only]   - allow reads and insertions of new elements.
 w[riteable]      - allow reads, insertions, and updates.
 BATs are updateable by default. On making a BAT readonly, all 
 subsequent updates fail with an error message.
 Returns the BAT itself.";

command setAccess( b:bat[any,any], mode:chr) : int = CMDsetAccess2
comment "Change access priviliges";

command getAccess( b:bat[any::1,any::2]):chr = CMDgetAccess
comment "return the access mode attached to this BAT as a character.";

command setSequenceBase( b:bat[void,any::1], seqbase:oid):int = CMDseqbase
comment "Set the sequence base for the void vcolumn of a BAT.";

command isOrdered(b:bat[any,any]) : bit = CMDordered
comment "Returns whether a BAT is ordered on head or not.";

command getBATSize(batname:str) : int = CMDbatsize_str
comment "A version of BATsize that does not require loading the BAT.";

command getBATSize(b:bat[any,any]) : int = CMDbatsize
comment "A version of BATsize that does not require loading the BAT.";

@- BUN Access
The BAT-loop iterator contructs take on a different flavour in MAL.
They mimick a for-loop as described in 'iterator.mx'.
The iterator is initialized with a value outside the range 0..BATcount(b).
@mal

command nextElement(i:int,b:bat[any,any]):bit = CMDnextElement
comment "Iterate over the elements of a BAT using an index.";

command nextElement(i:int,b:bat[any,any],low:int,high:int):bit = CMDnextSlice
comment "Iterator over all BUNs of b.slice(low,high)";

command nextHashElement(i:int, p:ptr, b:bat[any,any]):bit = CMDhashloop
comment "Iterate over the elements of a BAT using its hash index.
Each call we set 'i' to denote the next element";

@-
The remainder for the future
pattern getHead(b:bat[any::1,any], i:int):any::1 = CMDgetHead
comment "return the BUN head value using the iterator.";

pattern getTail(b:bat[any::1,any], i:int):any::1 = CMDgetTail
comment "return the BUN tail value using the iterator.";

@- BAT I/O, Persistency
@T
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
either be {\em persistent} or {\em transient}. The BBP also manages
swapping on a BAT level: a BAT is either loaded entirely or not.
MAL variables of type {\tt bat} can either be loaded or not. When 
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically 
loaded.  The BBP applies a simple but effective LRU based swapping 
algorithm. BATs have a {\em heat}, which drops over time, and is 
increased when a BAT is used by some command.  If the size of the 
allocated arena gets to be large, BATs may be swapped out. 

Note, we should move old-fashioned mil operator definitions
into a separate module. 
@mal
command setName ( b:bat[any,any] , s:str) : BIT = CMDrename;
command rename ( b:bat[any,any] , s:str) : BIT = CMDrename;
command bbpname ( b:bat[any,any] , s:str) : BIT = CMDrename
comment "Give a logical name to a BAT. This can fail if a BAT with 
name 's' already exists. The command then returns FALSE, ales TRUE.";

command bbpname ( b:bat[any,any]) : STR = CMDname
comment "Gives back the logical name of a BAT.";

command setRoles ( b:bat[any::1,any::2] , h:str, t:str):int = CMDroles
comment "Give a logical name to the columns of a BAT.";
command roles ( b:bat[any::1,any::2] , h:str, t:str):int = CMDroles
comment "Give a logical name to the columns of a BAT.";

command setTransient( b:BAT) :bit = CMDsetTransient
comment "Make the BAT transient.  Returns boolean which indicates if the
BAT administration has indeed changed.";

command setPersistent( b:BAT) : bit = CMDsetPersistence
comment "Make the BAT persistent.  Returns boolean which indicates if the
BAT administration has indeed changed.";

command save(nme:bat[any,any]) : bit = CMDsave2;

command save(nme:str) : bit = CMDsave
comment "Save a BAT to storage, if it was loaded and dirty. 
Returns whether IO was necessary.
Please realize that calling this function violates 
the atomic commit protocol!!";

command load(name:str) : bat[any,any] = CMDload
comment "Load a particylar bat from disk";

command unload(name:str) : bit = CMDunload
comment "Swapout a BAT to disk. Transient BATs can also be swapped out.
 Returns whether the unload indeed happened. ";

command hot(name:str) : void = CMDhot
comment "Makes a BAT very hot for the BBP. The chance of being chosen 
for swapout is small, afterwards.  Returns the BAT itself.";

command cold(nme:str) : void = CMDcold
comment "Makes a BAT very cold for the BBP. The chance of being choses 
for swapout is big, afterwards.  Returns the BAT itself.";

@- Heap Specific Commands
@T
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible 
to either load an image into an alloced range of memory (STORE\_MEM), or 
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/} 
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into 
the heap. String values themself are stored in this the X.hheap. 
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent accelerator
structures}. Monet has two builtin accelerators (index and hash), but they
are normally constructed on the fly. They are transient. Only hash-tables
you can be made persistent. User-defined accelerators are always persistent.
Only one persistent accelerator can exist per head column. It is stored in 
the X.hacc heap.
\item[X.tacc] similar to X.hacc, but for the tail column. 
\end{description}

Each of these heaps can be {\bf compressed} using the unix {\tt compress}
utility forming a X.ext.Z file. Monet wil automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the 
@[<a href="http://www.cwi.nl/~monet/www/scw/gdk/470_pseudo.html">GDK</a>@
documentation.
@mal
command mmap(b:BAT, buns_mode:int, hheap_mode:int, theap_mode:int, 
		hacc_mode:int, tacc_mode:int) : bit = CMDmmap
comment "For each individual heap, you can change the allocation mode to 
 either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.
 Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save 
 (this has to happen before the heap can be mapped into virtual memory). 
 These modes are persistent. ";

command madvise(b:BAT, buns_mode:int, hheap_mode:int, theap_mode:int, 
		hacc_mode:int, tacc_mode:int) : bit = CMDmadvise
comment "Modern Operating Systems allow users to influence the buffer management
 policy of virtual memory. This is a crucial feature for database systems,
 and eliminates the need to reimplement the OS in a database buffer manager.
 The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),
 BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),
 BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).
 These buffer management modes are not persistent.
 Returns the BAT operated upon.";

@- ASCII import, export
The below commands load and save a BAT from/to an ASCII dump. These
functions are efficient but work only for binary tables. For printing
ASCII n-ary tables you can use the @#print@(bat1,bat2,..) command
from the system.mx module.
@mal
command export(b:BAT, filepath:str):bit  = CMDexport
comment "Export a BAT as ASCII to a file. If the 'filepath' is not absolute, it
 is put into the .../dbfarm/$DB directory. Success of failure is indicated.";

command import(b:BAT, filepath:str) : bit = CMDimport
comment "Import a BAT from an ASCII dump. The new tuples are *inserted* into the
 parameter BAT. You have to create it! Its signature must match the dump, 
 else parsing errors will occur and FALSE is returned.";

@- BAT Accelerators
@T
Search accelerators are datastructures that are used to speed up 
access to data in BATs. Monet comes with the builtin accelerators
{\tt index}, meaning binary tree index, and {\tt hash} meaning 
bucket-chained hash table. The extension facilities of Monet allow
more accelerators to be defined by users. Exanples are the {\tt rtree}
and {\tt datavector}. The system variable {\tt monet\_acctbl} contains 
a list of all currently known accelarator types.

\begin{verbatim}
>monet_acctbl.print;
#-------------------------#
# h             | t       #
#-------------------------#
[ "hash",         1       ]
[ "index",        2       ]
[ "datavector",   3       ]
\end{verbatim}
@
More info on how to write new search accelerators can be found in the
@[<a href="../mel.html">MEL documentation</a>@.
@mal
command accbuild(b:bat[any,any], acctype:int):bit = CMDaccbuild_std
comment "Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent." ;

command accbuild(b:bat[any,any], acctype:int, param:ptr):int = CMDaccbuild
comment "like accbuild(bat[any,any] b, int acctype), but with a parameter that
 is provide to the specific accelerator build routine.";

command accdestroy(b:bat[any,any], acctype:int) = CMDaccdestroy
comment "Destroy the accelerator of type 'acctype'  that is present on
 the head-type of b.";

command accpresent(b:bat[any,any] ) : int = CMDaccpresent
comment "Returns the accelerator type of the *persistent* accelerator present 
 on the head column of b. Note that index and hash accelerators are
 generally *not* persistent, and will not be returned by this function!";
  

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large 
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@mal
command isSynced (b1:bat[any,any], b2:bat[any,any]) : bit = CMDsynced
comment "Tests whether two BATs are synced or not. ";

@- constants for mmap()
@mil
    CONST STORE_MEM   := 0;     # load into GDKmalloced memory
    CONST STORE_MMAP  := 1;     # mmap() into virtual memory
    CONST STORE_COMPR := 2;     # currently not implemented this way

    PROC mmap(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
        return mmap(b, memmode, memmode, memmode, memmode, memmode);
    }

    # overload madvise to pass the same memory mode for all heaps
    PROC madvise(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
        return madvise(b, memmode, memmode, memmode, memmode, memmode);
    }

@- constants for madvise()
@mil
    CONST BUF_NORMAL    := 0;   # No further special treatment
    CONST BUF_RANDOM    := 1;   # Expect random page references
    CONST BUF_SEQUENTIAL:= 2;   # Expect sequential page references
    CONST BUF_WILLNEED  := 3;   # Will need these pages
    CONST BUF_DONTNEED  := 4;   # Don't need these pages
@- constants for readonly()
@mil
    CONST BAT_READ   := 1;      # allow only read access.
    CONST BAT_APPEND := 2;      # allow reads and insertions of new elements.
    CONST BAT_WRITE  := 0;      # allow reads, insertions, and updates.

    PROC destroy(bat[any,any] b) : any {
        b.persists(false);
        return nil;
    }

    PROC destroy(str s) : any {
        var b := bat(s);
        return b.destroy;
    }

    PROC capacity(bat[any,any] b) : int 
	return capacity(int(b));

    PROC save(bat[any::1,any::2] b) : bat[any::1,any::2] {
	save(b.bbpname);
	return b;
    }

    PROC load(str batname) : bat[any,any] 
	return bat(batname);

    PROC cold(bat[any::1,any::2] b) : void
	cold(b.bbpname);

    PROC hot(bat[any::1,any::2] b) : void
	hot(b.bbpname);

    PROC htype(bat[any,any] b) : int 
	return htype(int(b));

    PROC ttype(bat[any,any] b) : int 
	return ttype(int(b));

    PROC new(int ht, int tt) : bat[any,any]
	return bat(ht,tt);

    PROC new(int ht, int tt, int cnt) : bat[any,any]
	return bat(ht,tt,cnt);
.END;

.END bat;
@
@{
@{
@* Implementation Code
In Version 5, we are not going to support recursive BATs.
It is up to the programmer to translate a bat into a
bat-name or batCacheid

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?&((BAT*)@2)->batCacheid:@2

@+ Information Functions
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@= batcheck
	if( BBPcheck(*@2,@4)==0) return GDK_FAIL;
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) {
		*@1 = 0;
		return GDK_FAIL;
	}
@= batcheck2
	if( BBPcheck(*@2,@4)== 0 ) {
		return *@1 = GDK_FAIL;
	}
	@3= (BAT*) BBPgetdesc(*@2);
	if( @3 == NULL) return *@1 = GDK_FAIL;
@-
At this stage of the game, we should translate
the arguments of BATnew into types.
@c
#include "monet.h"

int CMDbind(int *ret, str *nme){
	GDKerror("bind() not yet implemented\n");
	return GDK_SUCCEED;
}
int CMDbind2(int *ret, str *dict, str *nme){
	GDKerror("bind() not yet implemented\n");
	return GDK_SUCCEED;
}
int CMDrelease(int *ret, str *nme){
	GDKerror("release() not yet implemented\n");
	return GDK_SUCCEED;
}
int CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	int ht, tt, cap=0;
	str hn,tn;
	BAT *b;

	hn= getArgName(m,p,1);
	tn= getArgName(m,p,2);
	ht = ATOMindex(hn);
	tt = ATOMindex(tn);
	if( p->argc>3)
		cap= *(int *) getArgReference(s,p,3);
	b = BATnew(ht,tt,cap);
	if( b){
		int *i;
		i= (int *) getArgReference(s,p,0);
		*i= b->batCacheid;
		return GDK_SUCCEED;
	}
	return  GDK_FAIL;
}

int CMDreverse(int *ret, int *bid){
	BAT *b;
	@:batcheck(ret,bid,b,"CMDreverse")@
	*ret= -b->batCacheid;
	return GDK_SUCCEED;
} 

int CMDmirror(int *ret, int *bid){
	BAT *b, *v;
	@:batcheck(ret,bid,b,"CMDmirror")@
	v = VIEWcombine(b);
	if (b->batRestricted == BAT_WRITE) {
		BAT *bc = BATrcopy(v);
		BBPreclaim(v);
		v = bc;
	}
	if(v) {
		*ret = v->batCacheid;
		return GDK_SUCCEED;
	}
	*ret = 0;
	return GDK_FAIL;
}

int CMDconvert(int *ret, int *bid){
	BAT *b;
	@:batcheck(ret,bid,b,"CMDconvert")@
	BATconvert(b,CONV_HTON);
	BBPfix(b->batCacheid);
	return *ret = GDK_SUCCEED;
}

int CMDrevert(int *ret, int *bid){
	BAT *b;
	@:batcheck(ret,bid,b,"CMDrevert")@
	BATrevert(b);
	BBPfix(b->batCacheid);
	return *ret= GDK_SUCCEED;
}

int CMDorder(int *ret, int *bid){
	BAT *b;
	@:batcheck(ret,bid,b,"CMDorder")@
	BATorder(b);
	BBPfix(b->batCacheid);
	return *ret= GDK_SUCCEED;
}
@-
Insertions into the BAT may involve void types (=no storage required)
These cases should actually be captured during BUNins, because they
may emerge internally as well.
@= void_insertbun
if (b->@1type == TYPE_void && *(oid*) @1 != oid_nil &&
    *(oid*) @1 != (b->@1seqbase + BUNgetpos(b, BUNlast(b))))
{
      GDKerror("CMDinsert: cannot insert non-nil values in a void column.\n");
      return GDK_FAIL;
}
@c
int CMDinsert_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:batcheck2(r,bid,b,"CMDinsert_bun")@
	@:void_insertbun(h)@
	@:void_insertbun(t)@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, @:batconvert(b,h)@, @:batconvert(b,t)@); 
	return *r= GDK_SUCCEED;
} 

int CMDinsert_bat(int *r, int *bid, int *sid){
	BAT *b, *s;
	@:batcheck2(r,bid,b,"CMDinsert_bat")@
	@:batcheck2(r,sid,s,"CMDinsert_bat")@
	BATins(b,s);
	return *r= GDK_SUCCEED;
} 

@= void_append_only
	if ((b->hseqbase != oid_nil && b->htype == TYPE_void) ||
	    (b->tseqbase != oid_nil && b->ttype == TYPE_void))
	{
		GDKerror("@1: %s[%s,%s] is append-only.\n", 
			BBPname(b->batCacheid), 
			ATOMname(b->htype), ATOMname(b->ttype));
		return GDK_FAIL;
	}
@c
int CMDreplace_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:batcheck2(r,bid,b,"CMDreplace_bat")@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	@:void_append_only(CMDreplace_bun)@
	BUNreplace(b, @:batconvert(b,h)@, @:batconvert(b,t)@);
	return *r= GDK_SUCCEED;
} 

int CMDreplace_bat(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:batcheck2(r,bid,b,"CMDreplace_bat")@
	@:batcheck2(r,sid,s,"CMDreplace_bat")@
	@:void_append_only(CMDreplace_bat)@
	BATreplace(b,s);
	return *r= GDK_SUCCEED;
} 

int CMDdelete_bun(int *r, int *bid, ptr h, ptr t) {
	BAT *b;
	@:batcheck2(r,bid,b,"CMDdelete_bun")@
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	@:void_append_only(CMDdelete_bun)@
	BUNdel(b,h,t);
	return *r= GDK_SUCCEED;
} 

int CMDdelete_head(int *r, int *bid, ptr h) {
	BAT *b;
	@:batcheck2(r,bid,b,"CMDdelete_head")@
	@:derefStr(b,h,h)@
	@:void_append_only(CMDdelete_head)@
	BUNdelHead(b, @:batconvert(b,h)@);
	return *r= GDK_SUCCEED;
} 

int CMDdelete_all(int *r, int *bid) {
	BAT *b;
	@:batcheck2(r,bid,b,"CMDdelete_all")@
	BATclear(b);
	return *r= GDK_SUCCEED;
} 

int CMDdelete_bat_bun(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:batcheck2(r,bid,b,"CMDdelete_bat_bun")@
	@:batcheck2(r,sid,s,"CMDdelete_bat_bun")@
	@:void_append_only(CMDdelete_bat_bun)@
	BATdel(b,s);
	return *r= GDK_SUCCEED;
} 

int CMDdelete_bat_head(int *r, int *bid, int *sid){
	BAT *b,*s;
	@:batcheck2(r,bid,b,"CMDdelete_bat_head")@
	@:batcheck2(r,sid,s,"CMDdelete_bat_head")@
	@:void_append_only(CMDdelete_bat_head)@
	BATdelHead(b,s);
	return *r= GDK_SUCCEED;
} 

@- Property management
@c
int CMDcapacity(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDcapacity")@
	*res = BATcapacity(b);
	return GDK_SUCCEED;
}

int CMDhtype(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDhtype")@
	*res = (*bid > 0)?BAThtype(b):BATttype(b);
	return GDK_SUCCEED;
}

int CMDttype(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDttype")@
	*res = (*bid > 0)?BATttype(b):BAThtype(b);
	return GDK_SUCCEED;
}

int CMDsetkey(int *res, int *bid, bit *param) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDsetkey")@
	BATkey(b, *param?BOUND2BTRUE:FALSE);
        return *res= GDK_SUCCEED;
}

int CMDsetset(int *res, int *bid, bit *param) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDsetset")@
	BATset(b, *param?BOUND2BTRUE:FALSE);
        return *res= GDK_SUCCEED;
}
int CMDisaSet(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDsetset")@
	*res = b->batSet;
        return GDK_SUCCEED;
}

int CMDordered(bit *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDordered")@
        *res = BATordered(b)?1:0;
        return GDK_SUCCEED;
}
@-
We must take care of the special case of a nil column (TYPE_void,seqbase=nil) 
such nil columns never set hkey (and BUNins will never invalidate it if set) yet
a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
@c

int CMDgetkey(bit *ret, int *bid) {
	BAT *b;
	@:batcheck(ret,bid,b,"CMDgetkey")@
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b);
		}
		*ret = b->hkey?TRUE:FALSE;
	}
	return GDK_SUCCEED;
}

int CMDsetPersistence(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDsetPersistence")@
	BATpropcheck(b);
	BATpropcheck(BATmirror(b));
	BATmode(b, PERSISTENT);
        return *res= GDK_SUCCEED;
}
int CMDsetTransient(int *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDsetTransient")@
	BATmode(b, TRANSIENT);
        return *res= GDK_SUCCEED;
}

int CMDsetAccess(int *res, int *bid, str *param) {
	BAT *b;
	int m;
	@:batcheck(res,bid,b,"CMDsetAccess")@
	switch(*param[0]){
	case 'r': m= 1; break;
	case 'a': m= 2; break;
	case 'w': m= 0; break;
	default: GDKwarning("CMDsetAccess: illegal access mode\n");
		*res = 0;
		return GDK_FAIL;
	}
	BATsetaccess(b, m);
        return *res = GDK_SUCCEED;
}

int CMDsetAccess2(int *res, int *bid, char *param) {
	BAT *b;
	int m;
	@:batcheck(res,bid,b,"CMDsetAccess2")@
	switch(*param){
	case 'r': m= 1; break;
	case 'a': m= 2; break;
	case 'w': m= 0; break;
	default: GDKwarning("CMDsetAccess: illegal access mode\n");
		*res = 0;
		return GDK_FAIL;
	}
	BATsetaccess(b, m);
        return *res = GDK_SUCCEED;
}

int CMDgetAccess(char *res, int *bid) {
	BAT *b;
	@:batcheck(res,bid,b,"CMDgetAccess")@
	switch(BATgetaccess(b)){
	case 1: *res= 'r'; break;
	case 2: *res= 'a'; break;
	case 0: *res= 'w'; break;
	}
        return GDK_SUCCEED;
}

char* pre(str s1,str s2){
	static char buf[64];
	if( strlen(s1)+strlen(s2) >=64){
		GDKerror("pre: buffer space (64) too small\n");
		buf[0]=0;
	} else { strcpy(buf,s1); strcat(buf,s2); }
	return buf;
}
static char* local_itoa(int i){
	static char buf[32];
	sprintf(buf,"%d",i);
	return buf;
}

#define COLLISION 6
extern int HASHlist (Hash* h, int i);

void HASHinfo(BAT *bn, Hash *h, str s){
	unsigned int i;
	int     j;
	int     cnt[COLLISION + 2];
	int     largebuckets = 0;
	int     largetot = 0;
	char    buf[32];
 
	BUNins(bn, pre(s,"type"), ATOMname(h->type));
	BUNins(bn, pre(s,"mask"), local_itoa(h->mask));
	BUNins(bn, pre(s,"lim"), local_itoa(h->lim));
 
	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == 0) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION +1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}
 
	for (i = 0; i <= COLLISION+1; i++)
	if( cnt[i]) {
		BUNins(bn, pre(s,local_itoa(i)), local_itoa(cnt[i]));
	}
	sprintf(buf, "%d on %d", largetot, largebuckets);
	BUNins(bn, pre(s,"collision"), buf);
}

static void infoHeap(BAT *bn, Heap *hp, str nme){
	char buf[1024], *p = buf;

	while(*nme) *p++ = *nme++;
	strcpy(p, "free");
        BUNins(bn, buf, local_itoa(hp->free ));
	strcpy(p, "size");
        BUNins(bn, buf, local_itoa(hp->size));
	strcpy(p, "maxsize");
        BUNins(bn, buf, local_itoa(hp->maxsize));
	strcpy(p, "storage");
        BUNins(bn, buf, (hp->base==NULL)?"absent":(hp->storage==STORE_MMAP)?
		(hp->filename?"memory mapped":"anonymous vm"):
		(hp->storage==STORE_PRIV)?"private map":"malloced");
	strcpy(p, "filename");
        BUNins(bn, buf, hp->filename?hp->filename:"no file");
	strcpy(p, "offset");
        BUNins(bn, buf, local_itoa(hp->offset));
}

int CMDinfo(int *retval, int *bid){
	BAT *bn,*b;
	char mode[1024], *access;
 
	if (!(bn = BATnew(TYPE_str,TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn->batCacheid;
 
	b= BATdescriptor(*bid);
	if (b->batPersistence & PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence & SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence & TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	} 

	switch(b->batRestricted) {
	case BAT_READ:         access="read-only";      break;
	case BAT_WRITE:        access="writable";      break;
	case BAT_APPEND:       access="append-only";      break;
	default:               access="unknown";
	}
 
        BUNins(bn, "version", local_itoa(b->GDKversion));
        BUNins(bn, "batId", b->batId );
        BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
        BUNins(bn, "batParentid", local_itoa(b->batParentid));
        BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
        BUNins(bn, "head", ATOMname(b->htype));
        BUNins(bn, "tail", ATOMname(b->ttype));
        BUNins(bn, "batPersistence", mode);
        BUNins(bn, "batRestricted", access);
        BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
        BUNins(bn, "batDirty", BATdirty(b)?"dirty":"clean");
        BUNins(bn, "batSet", local_itoa(b->batSet));
        BUNins(bn, "void_tid", local_itoa(b->void_tid));
        BUNins(bn, "void_cnt", local_itoa(b->void_cnt));
 
        BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
        BUNins(bn, "hident",  b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", local_itoa(b->hseqbase));
        BUNins(bn, "hkey", local_itoa(b->hkey));
        BUNins(bn, "hloc", local_itoa(b->hloc));
        BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
        BUNins(bn, "halign", local_itoa(b->halign));
        BUNins(bn, "halignflushed", local_itoa(b->halignflushed));
 
        BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", local_itoa(b->tseqbase));
        BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
        BUNins(bn, "tkey", local_itoa(b->tkey));
        BUNins(bn, "tloc", local_itoa(b->tloc));
        BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
        BUNins(bn, "talign", local_itoa(b->talign));
        BUNins(bn, "talignflushed", local_itoa(b->talignflushed));
 
        BUNins(bn, "batInserted", local_itoa(BUNindex(b, b->batInserted)));
        BUNins(bn, "batDeleted", local_itoa(BUNindex(b, b->batDeleted)));
        BUNins(bn, "batHole", local_itoa(BUNindex(b, b->batHole)));
        BUNins(bn, "top", local_itoa(BUNindex(b, (Bunbase(b) + b->batBuns->free))));
	BUNins(bn, "batStamp", local_itoa(b->batStamp));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
        BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
        BUNins(bn, "batDirtydesc", b->batDirtydesc?"dirty":"clean");
 
        BUNins(bn, "batDirtybuns", b->batDirtybuns?"dirty":"clean");
	infoHeap(bn, b->batBuns, "batBuns.");

        BUNins(bn, "hheapdirty", b->hheapdirty?"dirty":"clean");
	infoHeap(bn, &b->hheap, "hheap.");

        BUNins(bn, "theapdirty", b->theapdirty?"dirty":"clean");
	infoHeap(bn, &b->theap, "theap.");

        BUNins(bn, "hacctype", ACCname(b->hacctype));
        BUNins(bn, "haccdirty", b->haccdirty?"dirty":"clean");
        BUNins(bn, "haccCopiedtodisk", local_itoa(b->haccCopiedtodisk));
	infoHeap(bn, &b->haccelerator, "haccelerator.");

        BUNins(bn, "tacctype", ACCname(b->tacctype));
        BUNins(bn, "taccdirty", b->taccdirty?"dirty":"clean");
        BUNins(bn, "taccCopiedtodisk", local_itoa(b->taccCopiedtodisk));
	infoHeap(bn, &b->taccelerator, "taccelerator.");
 
        /* dump index information */
        if (b->hhash_heap) {
                HASHinfo(bn, &b->hhash, "hhash->");
        }
        if (b->thash_heap) {
                HASHinfo(bn, &b->thash, "thash->");
        }
        BUNins(bn, "head_index", b->hidx_heap?"present":"absent");
        BUNins(bn, "tail_index", b->tidx_heap?"present":"absent");
 
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int CMDbatsize(int *tot, int *bid){
	BAT *b;
	int blksize = MT_pagesize();
	int size = ROUND_UP(sizeof(BATstore),blksize);

	@:batcheck(tot,bid,b,"CMDbatsize")@
	if (!VIEWparent(b)) {
		int cnt = BATcapacity(b);
		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap.base) size += ROUND_UP(b->hheap.size, blksize);
		if (b->theap.base) size += ROUND_UP(b->theap.size, blksize);
		if (b->haccelerator.base) size += ROUND_UP(b->haccelerator.size, blksize);
		if (b->taccelerator.base) size += ROUND_UP(b->taccelerator.size, blksize);
		if (b->hhash_heap) size += ROUND_UP(sizeof(int) * cnt, blksize);
		if (b->thash_heap) size += ROUND_UP(sizeof(int) * cnt, blksize);
		if (b->hidx_heap) size += ROUND_UP(sizeof(int) * cnt, blksize);
		if (b->tidx_heap) size += ROUND_UP(sizeof(int) * cnt, blksize); 
	}
	*tot = size;
	return GDK_SUCCEED;
}

int CMDbatsize_str(int *tot, str *batname){
	int bid = BBPindex(*batname);
	BAT *b = bid?(BAT*) BBPgetdesc(bid):NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize(%s): no such bat.\n", *batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, &bid);
}

@+ Synced BATs
@c
int CMDsynced(bit *ret, int *bid1, int *bid2){
	BAT *b1, *b2;
	@:batcheck(ret,bid1,b1,"CMDsynced")@
	@:batcheck(ret,bid2,b2,"CMDsynced")@
	*ret = ALIGNsynced(b1,b2)?1:0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int CMDroles(int *r, int *bid, str *hname, str *tname){
	BAT *b;
	@:batcheck(r,bid,b,"CMDroles")@
	BATroles(b, *hname, *tname);
	return *r= GDK_SUCCEED;
}

int CMDrename(bit *retval, int *bid, str *s){
	BAT *b;
	int ret;
	@:batcheck(retval,bid,b,"CMDrename")@
	ret = BATname(b,*s);
	*retval = FALSE;
        if (ret == 1) {
                GDKerror("CMDrename: identifier expected: %s\n",*s);
		return GDK_FAIL;
        } else if (ret == BBPRENAME_ILLEGAL) {
                GDKerror("CMDrename: illegal temporary name: '%s'\n", *s);
		return GDK_FAIL;
        } else if (ret == BBPRENAME_LONG) {
                GDKerror("CMDrename: name too long: '%s'\n", *s);
		return GDK_FAIL;
        } else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int CMDname(str *retval, int *bid){
	BAT *b;
	@:batcheck(retval,bid,b,"CMDname")@
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int CMDunload(bit *res, str *input) {
        int bid = ABS(BBPindex(*input));
	*res = FALSE;
        if (bid > 0) {
		BBPfix(bid);
		*res = BBPunload(bid);
	}
        return GDK_SUCCEED;
}
int CMDload(int *res, str *input) {
	int bid= BBPindex(*input);
	*res = bid;
        return bid?GDK_SUCCEED:GDK_FAIL;
}

int CMDhot(str *input) {
	BBPhot(BBPindex(*input));
	return GDK_SUCCEED;
}

int CMDcold(str *input) {
	BBPcold(BBPindex(*input));
	return GDK_SUCCEED;
}

int CMDsave(bit *res, str *input) {
	int bid = BBPindex(*input);
	BAT *b;
	*res = FALSE;
	if (bid ) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) { 
			if (BBPsave(b) == 0) *res = TRUE;
		}
		BBPunfix(bid);
	}
        return GDK_SUCCEED;
}
int CMDsave2(bit *res, int *bid) {
	BAT *b;
	@:batcheck2(res,bid,b,"CMDsave")@
	if (b && BATdirty(b)) { 
		if (BBPsave(b) == 0) *res = TRUE;
	}
	BBPunfix(*bid);
        return GDK_SUCCEED;
}


@= change_heap
{	int mode = (@2).storage;
	if (mode == STORE_MMAP && (@2).filename == NULL) 
		mode = STORE_MEM;  
	if ((@2).base == NULL || *@1 == int_nil || *@1 == mode) {
		*@1 = -1;
	}
}
@c
int CMDmmap(int *res, int *bid, int *bns, int *hhp, int *thp,
			int *hacc, int *tacc)
{	BAT *b;
	@:batcheck(res,bid,b,"CMDmmap")@
	@:change_heap(bns,(*b->batBuns))@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	@:change_heap(hacc,b->haccelerator)@
	@:change_heap(tacc,b->taccelerator)@
	if (BATmmap(b, *bns, *hhp, *thp, *hacc, *tacc) == 0) {
		return *res= GDK_SUCCEED;
	}
	return *res= GDK_FAIL;
}

int CMDmadvise(int *res, int *bid, int *bns, int *hhp, int *thp, 
		 	        int *hacc, int *tacc)
{	BAT *b;
	@:batcheck(res,bid,b,"CMDmadvice")@
	return *res= BATmadvise(b, (*bns==int_nil)?-1:*bns, 
		(*hhp==int_nil)?-1:*hhp, (*thp==int_nil)?-1:*thp, 
		(*hacc==int_nil)?-1:*hacc, 
		(*tacc==int_nil)?-1:*tacc)?GDK_FAIL:GDK_SUCCEED;
}

@+ Bulk export/loading
To simplify conversion between versions and to interface with other 
applications, we use a simple import/export operation.

The conversion routine assumes space in the buffer for storing the result.
@{
@c
@-
A BAT can be saved in Monet format using the export command.
It is of particular use in preparing an ascii version for migration.
The exported file is saved in the context of the directory
where the server was started unless an absolute file name was
presented.
@c
int CMDexport(int *ret, int *bid, str *fnme) {
	BAT *b;
	FILE	*f = fopen(*fnme, "w");
	@:batcheck(ret,bid,b,"CMDexport")@
	if (f == NULL) {
		GDKsyserror("CMDexport: could not open file %s\n",*fnme);
		return *ret= GDK_FAIL;
	}
	BATprintf(f,b);
	fclose(f);
	return *ret= GDK_SUCCEED;
}

@
The import command reads a single BAT from an ascii file. It assumes
a layout compatible with that produced by print or export.
@c
int CMDimport(int *ret, int *bid, str *fnme) {
	BAT *b;
	int	(*hconvert)(), (*tconvert)();
	int	bufsize = 2048; /* NIELS: tmp change used to be 1024 */
	char	*base, *cur, *end;
	char	*buf = (char *) GDKmalloc(bufsize);
	ptr	*h = 0, *t = 0;
	int	lh = 0,	lt = 0;
	FILE	*fp = fopen(*fnme, "r");

	@:batcheck(ret,bid,b,"CMDimport")@
	hconvert = BATatoms[BAThtype(b)].atomFromStr;
	tconvert = BATatoms[BATttype(b)].atomFromStr;
@-
Open the file. Memory map it to minimize buffering problems.
@c
        if (fp == NULL) {
		GDKsyserror("CMDimport: could not open file %s\n",fnme);
		return GDK_FAIL;
	} else {
	    	struct stat st;
            	fstat(fileno(fp), &st);
		(void)fclose(fp); 
            	base = cur = (char*)MT_mmap(*fnme, 0, 0, st.st_size, NULL);
		end = cur + st.st_size;
	}
@-
Parse a line. Copy it into a buffer. Concat broken lines with a slash. 
@c
	while(cur < end) {
		str dst = buf, src = cur, p = strchr(cur, '\n');
		int l = p - cur;

		if (!p) {
			p = end;
		} else while(src[l-1] == '\\') {
			@:memcpy@
			dst += l-1; src += l+1;
			if ((p = strchr(src, '\n')) == 0) {
				p = end; break;
			}
			l = p - src;
		} 
		@:memcpy@
@= memcpy
		if (buf+bufsize < dst+l) {
		        int len = dst - buf;
			int inc = (dst+l) - buf;
			buf = (char*) GDKrealloc((void*) buf, bufsize = MAX(inc,bufsize)*2);
			dst = buf + len;
		}
		memcpy(dst, src, l-1);
@c
		dst[l] = 0;
		cur = p+1;
@-
Parse the line, and insert a BUN.
@c
		for(p = buf; *p && GDKisspace(*p); p++);
		if (*p == '#') continue;
@= parsevalue
	       	for (;*p && ((int) *p) != @2; p++);
		if (*p) for (p++; *p && GDKisspace(*p); p++);
       		if (*p == 0){
		       	GDKerror("CMDimport: error in %s\n",buf);
			return *ret = GDK_FAIL;
       		}
       		p += @1(p, @3, @4);			
@c
		@:parsevalue(hconvert, '[', &lh, &h)@
		@:parsevalue(tconvert, 44, &lt, &t)@
		BUNins(b, h, t);
		
@-
Unmap already parsed memory, to keep the memory usage low. 
@c
#define MAXBUF 40*MT_pagesize()
		if (cur - base > MAXBUF) {
			MT_munmap(base, MAXBUF);
			base += MAXBUF;
		} 
	}
@-
Cleanup and exit. Return the filled BAT.
@c
	if (h) GDKfree(h);
	if (t) GDKfree(t);
	GDKfree(buf);
	MT_munmap(base, end-base);
	BBPfix(b->batCacheid);
	return *ret= GDK_SUCCEED;
}

@+ Accelerator Control
@c
int CMDaccbuild(int *ret, int *bid, int* acc, ptr *param){
	BAT *b;
	@:batcheck(ret,bid,b,"CMDaccbuild")@
	ACCbuild(*acc, b, &b->haccelerator, *param); 
	return *ret = GDK_SUCCEED;
}
int CMDaccbuild_std(int *ret, int *bid, int* acc){
	ptr n= NULL;
	return CMDaccbuild(ret,bid, acc, &n);	
}

int CMDaccdestroy(int *ret, int *bid, int *acc) {
	BAT *b;
	@:batcheck(ret,bid,b,"CMDaccdestroy")@
	ACCdestroy(*acc, b, &b->haccelerator);
	return *ret = GDK_SUCCEED;
}

int CMDaccpresent(int *ret, int *bid) {
	BAT *b;
	@:batcheck(ret,bid,b,"CMDaccpresent")@
	*ret = 0;
	if (b->hacctype) {
	    int (*check)() = BATaccelerators[b->hacctype].accRepair;
	    if (check == NULL || (*check)(&b->haccelerator,b) == GDK_SUCCEED) {
		*ret = b->hacctype;
 	    }
	}
	return GDK_SUCCEED;
}


@+ Iterators
This section should still be upgraded to V 5.0, because iterators
are handled in a completely different manner.
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0) return i;
	} else {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0) return i;
	} break;
@c
int CMDhashloop(int *ret, int *cursor, int *bid)
{
	BAT *b;
	@:batcheck(ret,bid,b,"CMDnextElement")@
	GDKerror("not yet implemented\n");
	return GDK_SUCCEED;
}

int CMDnextElement(int *ret, int *cursor, int *bid)
{
	BAT *b;
	@:batcheck(ret,bid,b,"CMDnextElement")@
	if( *cursor > BUNindex(b,BUNlast(b)) ){
		*ret = FALSE;
	} else
	if( *cursor <0){
		*ret = TRUE;
		*cursor = BUNindex(b,BUNfirst(b));
	} else
		*cursor = *cursor+1;
	return GDK_SUCCEED;
}
int CMDnextSlice(int *ret, int *cursor, int *bid, int *low, int *high)
{
	BAT *b;
	@:batcheck(ret,bid,b,"CMDnextElement")@
	if( *cursor > *high){
		*ret = FALSE;
	} else 
	if( *cursor < *low){
		*ret = TRUE;
		*cursor = BUNindex(b,BUNfirst(b));
	} else
		*cursor = *cursor+1;
	return GDK_SUCCEED;
}


int CMDseqbase(int *r, int *bid, oid* o){
	BAT *b;
	@:batcheck(r,bid,b,"CMDseqbase")@
	BATseqbase(b, *o);
	return *r= GDK_SUCCEED;
}
@}
@}
