@f arith
@a N.J. Nes, P. Boncz, M. Kersten
@v 2.0
@t The Arithmetics Module
@* Introduction
@T
This module implements the arithmetic operations on the built-in types,
{\tt chr}, {\tt sht}, {\tt int}, {\tt flt}, {\tt dbl} and {\tt lng}.
All combinations are implemented. Limited combinations are implemented
for {\tt bit}, {\tt oid} and {\tt str}. 

\begin{description}
\item[binary operators]
The implemented operators are first of all all comparison that return a 
TRUE/FALSE value ({\tt bit} values), i.e. 
{\tt $<=$}, {\tt $<$}, {\tt $=$}, {\tt $!=$}, {\tt $>=$}, and {\tt $>=$}.

The module also implements the operators {\tt +}, {\tt -}, {\tt *} and {\tt /}. 
The rules for the return types operators is as follows.

\begin{enumerate}
\item If one of the input types is a floating point the result will be a
floating point. 
\item The largest type of the input types is taken. 
\end{enumerate}

The {\tt max} and {\tt min} functions return the maximum and minimum of 
the two input parameters.

\item[unary operators]
This module also implements the unary {\tt abs}() function, which calculates 
the absolute value of the given input parameter, as well as the {\tt -} unary
operator. 

The {\tt inv} unary operation calculates the inverse of the input value. 
An error message is given when the input value is zero.

\item[bitwise operators]
For integers there are some additional operations. The {\tt $%$} operator
implements the congruent modulo operation. The {\tt $<<$} and {\tt $>>$} 
are the left and right bit shift. The {\tt or}, {\tt and}, {\tt xor} and 
{\tt not} for integers are implemented as bitwise boolean operations. 

\item[boolean operators]
The {\tt or}, {\tt and}, {\tt xor} and {\tt not} for the bit atomic type 
in MIL (this corresponds to what is normally called boolean)
are implemented as the logic operations.

\item[random numbers]
This module also contains the rand and srand functions. The {\tt srand}() 
function initializes the random number generator using a seed value. The 
subsequent calls to {\tt rand}() are pseudo random numbers (with the same 
seed the sequence can be repeated).
\end{description}

{\bf The general interpretation for the NIL value is "unknown".
This semantics mean that any operation that receives at least one NIL 
value, will produce a NIL value in the output for sure.} 

The only exception to this rule are the "==" and "!=" equality 
test routines (it would otherwise become rather difficult to test 
whether a value is nil). 

@* Module Definition
Most of the primitives are defined here. 
A heuristic is to organize the routines along the types 
(int,lng,sht,bit,oid,flt,...) to reduce number of checks
at function resoluton.
@= mal_isnil
	command isnil(v:@1) : bit = @2_isnil
	comment "is a value nil?";
@-
[Mx bug, space required here]

@mal
module arith;

	@:mal_isnil(any,any)@
	@:mal_isnil(chr,chr)@
	@:mal_isnil(bit,chr)@
	@:mal_isnil(sht,sht)@
	@:mal_isnil(int,int)@
	@:mal_isnil(oid,oid)@
	@:mal_isnil(flt,flt)@
	@:mal_isnil(lng,lng)@
	@:mal_isnil(dbl,dbl)@
	@:mal_isnil(str,str)@

@- comparisons { <, <=, =, !=, >=, > } 
@T 
The {\tt mel\_comp\_ops} Mx macro implements the mel interface to the
arithmetic operations. Note that comparison operators with unequal
operands are already supported in the kernel, but are not nearly as fast,
(because they have to convert values on the fly).  
A heuristic is to organize the routines along the types 
(int,lng,sht,bit,oid,flt,...) to reduce number of checks
at function resoluton. The least interesting one is pushed
first onto the symbol table stack.
@= mal_eq_ops
	command =(left:@1, right:@1) : bit = @2_comp_EQ
		comment "left equal to right?";
	command !=(left:@1, right:@1) : bit = @2_comp_NEQ
		comment "left unequal to right?";
@= mal_comp_ops
	@:mal_eq_ops(@1,@2)@
	command <(left:@1, right:@1) : bit = @2_comp_LT
		comment "left smaller than right?";
	command <=(left:@1, right:@1) : bit = @2_comp_LE
		comment "left smaller than right or equal?";
	command >=(left:@1, right:@1) : bit = @2_comp_GE
		comment "left greater than right or equal?)";
	command >(left:@1, right:@1) : bit = @2_comp_GT
		comment "left greater than right?";
	command between(val:@1, low:@1, high:@1) : bit = @2_comp_between
		comment "checks (low <= val <= high)";
@mal
        @:mal_comp_ops(any::1,any)@

        @:mal_comp_ops(oid,oid)@
        @:mal_comp_ops(flt,flt)@
        @:mal_comp_ops(flt,dbl)@
        @:mal_comp_ops(dbl,dbl)@

        @:mal_comp_ops(chr,chr)@
        @:mal_comp_ops(chr,sht)@
        @:mal_comp_ops(chr,int)@
        @:mal_comp_ops(chr,lng)@

        @:mal_eq_ops(bit,chr)@
        @:mal_eq_ops(bit,sht)@
        @:mal_eq_ops(bit,int)@
        @:mal_eq_ops(bit,lng)@

        @:mal_comp_ops(sht,chr)@
        @:mal_comp_ops(sht,sht)@
        @:mal_comp_ops(sht,int)@
        @:mal_comp_ops(sht,lng)@

        @:mal_comp_ops(int,chr)@
        @:mal_comp_ops(int,sht)@
        @:mal_comp_ops(int,int)@
        @:mal_comp_ops(int,lng)@

        @:mal_comp_ops(lng,chr)@
        @:mal_comp_ops(lng,sht)@
        @:mal_comp_ops(lng,int)@
        @:mal_comp_ops(lng,lng)@

        @:mal_comp_ops(str,str)@

@- computation of { +, -, *, /, % }
@T 
The {\tt mel\_arith\_ops} Mx macro implements the mel interface to the
arithmetic operations.  The macro expects three parameters, two input
atomic types and a result type. 
@mal
	command %(left:chr, right:int) : int = chrint_binary_MOD;
	command %(left:sht, right:int) : int = shtint_binary_MOD;
	command %(left:int, right:int) : int = intint_binary_MOD;
	command %(left:lng, right:int) : int = lngint_binary_MOD;
	command %(left:int, right:chr) : chr = intchr_binary_MOD;
	command %(left:int, right:sht) : sht = intsht_binary_MOD;
@= mal_arith_ops
	command +(left:@1, right:@2) : @3 = @1@2_binary_ADD; 
	command -(left:@1, right:@2) : @3 = @1@2_binary_SUB;
	command *(left:@1, right:@2) : @3 = @1@2_binary_MUL;
	command /(left:@1, right:@2) : @3 = @1@2_checkbinary_DIV;
@-
The coercions described below ensure that there is never an information loss.
@mal

	@:mal_arith_ops(flt,chr,flt)@
	@:mal_arith_ops(flt,sht,flt)@
	@:mal_arith_ops(flt,int,flt)@
	@:mal_arith_ops(flt,lng,flt)@
	@:mal_arith_ops(flt,flt,flt)@
	@:mal_arith_ops(flt,dbl,dbl)@

	@:mal_arith_ops(dbl,chr,dbl)@
	@:mal_arith_ops(dbl,sht,dbl)@
	@:mal_arith_ops(dbl,int,dbl)@
	@:mal_arith_ops(dbl,lng,dbl)@
	@:mal_arith_ops(dbl,flt,dbl)@
	@:mal_arith_ops(dbl,dbl,dbl)@

	@:mal_arith_ops(oid,oid,oid)@

	@:mal_arith_ops(chr,chr,chr)@
	@:mal_arith_ops(chr,sht,sht)@
	@:mal_arith_ops(chr,int,int)@
	@:mal_arith_ops(chr,lng,lng)@
	@:mal_arith_ops(chr,flt,flt)@
	@:mal_arith_ops(chr,dbl,dbl)@

	@:mal_arith_ops(sht,chr,sht)@
	@:mal_arith_ops(sht,sht,sht)@
	@:mal_arith_ops(sht,int,int)@
	@:mal_arith_ops(sht,lng,lng)@
	@:mal_arith_ops(sht,flt,flt)@
	@:mal_arith_ops(sht,dbl,dbl)@

	@:mal_arith_ops(int,chr,int)@
	@:mal_arith_ops(int,sht,int)@
	@:mal_arith_ops(int,int,int)@
	@:mal_arith_ops(int,lng,lng)@
	@:mal_arith_ops(int,flt,flt)@
	@:mal_arith_ops(int,dbl,dbl)@

	@:mal_arith_ops(lng,chr,lng)@
	@:mal_arith_ops(lng,sht,lng)@
	@:mal_arith_ops(lng,int,lng)@
	@:mal_arith_ops(lng,lng,lng)@
	@:mal_arith_ops(lng,flt,flt)@
	@:mal_arith_ops(lng,dbl,dbl)@

@- binary  operations { max, min, }
@= mal_binary_ops
   	command max(l:@1, r:@1) : @1 = @2_binary_MAX; 
   	command min(l:@1, r:@1) : @1 = @2_binary_MIN;
@-
@mal
	@:mal_binary_ops(chr,chr)@
	@:mal_binary_ops(sht,sht)@
	@:mal_binary_ops(int,int)@
	@:mal_binary_ops(oid,oid)@
	@:mal_binary_ops(flt,flt)@
	@:mal_binary_ops(lng,lng)@
	@:mal_binary_ops(dbl,dbl)@

@- unary operations { abs, inv }
@= mal_unary_ops
   	command abs(x:@1) : @1 = @1_unary_ABS comment "absolute value";
   	command inv(x:@1) : @1 = @1_unary_INV comment "inverse value (1/x)";
   	command -(x:@1) : @1 = @1_unary_NEG comment "negative value";
@-
@mal
	@:mal_unary_ops(dbl)@
	@:mal_unary_ops(flt)@
	@:mal_unary_ops(chr)@
	@:mal_unary_ops(sht)@
	@:mal_unary_ops(int)@
	@:mal_unary_ops(lng)@

@- boolean { or, xor, and, not }
@mal
	command or(left:bit, right:bit) : bit = bit_binary_OR 
	comment "boolean or";
	command and(left:bit, right:bit) : bit = bit_binary_AND 
	comment "boolean and";
	command xor(left:bit, right:bit) : bit = bit_binary_XOR 
	comment "boolean xor";
	command not(left:bit) : bit = bit_unary_NOT 
	comment "boolean negation";
	command ifthenelse(b:bit, t:any::1, f:any::1) : any::1 = bit_switch 
	comment "boolean switch: returns b?t:f";

@- bitwise operations
Cardinal numerical types (inclusing {\tt chr} can be regarded as a bit
array. Specific operations work with this interpretation.
@= mal_bitwise_ops
	command or(left:@1, right:@1) : @1 = @1@1_binary_OR 
	comment "bitwise or";
	command and(left:@1, right:@1) : @1 = @1@1_binary_AND 
	comment "bitwise and";
	command xor(left:@1, right:@1) : @1 = @1@1_binary_XOR 
	comment "bitwise xor";
	command not(left:@1) : @1 = @1_unary_NOT 
	comment "bitwise negation";
	command <<(left:@1,right:int) : @1 = @1int_binary_LSH 
	comment "shift left" ;
	command >>(left:@1, right:int) : @1 = @1int_binary_RSH 
	comment "shift right" ;
@mal
	@:mal_bitwise_ops(chr)@
	@:mal_bitwise_ops(sht)@
	@:mal_bitwise_ops(int)@
	@:mal_bitwise_ops(lng)@

@- random numbers
@mal
	command rand () : int = int_rand
	comment "return a random number";
	command srand(seed:int) : void = int_srand
	comment "initialize the rand() function with a seed";

@+ Example script 
The following example MIL script will do each operation in the
arith module. It can be used for testing and the M2m compiler.

@mil
setoid(oid(20000000));
chr1 := 'a';
chr2 := 'c';
sht1 := sht(2);
sht2 := sht(5);
int1 := 5;
int2 := 2;
flt1 := 2.5;
flt2 := 5.4;
dbl1 := dbl(-2.500001);	       # may also need string since float is default
dbl2 := dbl(54.00456789);      # real and is less significant	
lng1 := lng("-9000000000000"); # string needed because lng doesn't fit in an
lng2 := lng("5400456789");     # int
oid1 := oid(int1);
oid2 := oid(int2);

@:mil_comp_ops('a','z')@
@:mil_comp_ops(sht1,sht2)@
@:mil_comp_ops(int1,int2)@
@:mil_comp_ops(flt1,flt2)@
@:mil_comp_ops(dbl1,dbl2)@
@:mil_comp_ops("abcde","abcdf")@

@:mil_arith_ops(chr1,chr2)@
@:mil_arith_ops(chr1,sht2)@
@:mil_arith_ops(chr1,int2)@
@:mil_arith_ops(chr1,lng2)@
@:mil_arith_ops(chr1,flt2)@
@:mil_arith_ops(chr1,dbl2)@

@:mil_arith_ops(sht1,chr2)@
@:mil_arith_ops(sht1,sht2)@
@:mil_arith_ops(sht1,int2)@
@:mil_arith_ops(sht1,lng2)@
@:mil_arith_ops(sht1,flt2)@
@:mil_arith_ops(sht1,dbl2)@

@:mil_arith_ops(int1,chr2)@
@:mil_arith_ops(int1,sht2)@
@:mil_arith_ops(int1,int2)@
@:mil_arith_ops(int1,lng2)@
@:mil_arith_ops(int1,flt2)@
@:mil_arith_ops(int1,dbl2)@

@:mil_arith_ops(lng1,chr2)@
@:mil_arith_ops(lng1,sht2)@
@:mil_arith_ops(lng1,int2)@
@:mil_arith_ops(lng1,lng2)@
@:mil_arith_ops(lng1,flt2)@
@:mil_arith_ops(lng1,dbl2)@

@:mil_arith_ops(flt1,chr2)@
@:mil_arith_ops(flt1,sht2)@
@:mil_arith_ops(flt1,int2)@
@:mil_arith_ops(flt1,lng2)@
@:mil_arith_ops(flt1,flt2)@
@:mil_arith_ops(flt1,dbl2)@

@:mil_arith_ops(dbl1,chr2)@
@:mil_arith_ops(dbl1,sht2)@
@:mil_arith_ops(dbl1,int2)@
@:mil_arith_ops(dbl1,lng2)@
@:mil_arith_ops(dbl1,flt2)@
@:mil_arith_ops(dbl1,dbl2)@

@:mil_arith_ops(oid1,oid2)@

max(sht1,sht2).print;
max(int1,int2).print;
max(lng1,lng2).print;
max(flt1,flt2).print;
max(dbl1,dbl2).print;

min(sht1,sht2).print;
min(int1,int2).print;
min(flt1,flt2).print;
min(dbl1,dbl2).print;
min(lng1,lng2).print;

abs(sht2).print;
abs(int2).print;
abs(flt2).print;
abs(dbl2).print;
abs(lng2).print;

@:mil_arith_ops(oid1,oid2)@
max(oid1,oid2).print;
min(oid1,oid2).print;

inv(sht2).print;
inv(int2).print;
inv(flt2).print;
inv(dbl2).print;
inv(lng2).print;

(int1% int2).print;
(int1<<int2).print;
(int1>>int2).print;

(int1 or  int2).print;
(int1 and int2).print;
(int1 xor int2).print;
not(int2).print;

bit1 := true;
bit2 := false;
(bit1 or  bit2).print;
(bit1 and bit2).print;
(bit1 xor bit2).print;
not(bit2).print;

srand( 1234 );
rand().print;
quit;

@T
The {\tt mil\_comp\_ops} implements the mil example script comparison 
operations.  It gets two parameters which are the operants for the operations.

@= mil_comp_ops
 (@1 < @2).print;  (@2 < @1).print;  (@1 < @1).print;
(@1 <= @2).print; (@2 <= @1).print; (@1 <= @1).print;
 (@1 = @2).print;  (@2 = @1).print;  (@1 = @1).print;
(@1 >= @2).print; (@2 >= @1).print; (@1 >= @1).print;
 (@1 > @2).print;  (@2 > @1).print;  (@1 > @1).print;
@

@T
The {\tt mil\_arith\_ops} implements the mil example script arithmetic 
operations.  It gets two parameters which are the operants for the operations.

@= mil_arith_ops
(@1 + @2).print;
(@1 - @2).print;
(@1 * @2).print;
(@1 / @2).print;
@

@{
@* Implementation
The implementation below differs from the pre-V5 implementation in
that all strings and pointers are passed by reference, rather than
by value. Since it is unclear in the module implementation whether
such references are static or refer to dynamic allocated space,
we have to be conservative. All deallocation calls should be prepared
and handled by the environment.
For this module this won't be a problem, because we do not change
the string representations.
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#ifndef __arith_H__
#define __arith_H__

#include "gdk.h"
/* DEBUG phase.  #include "arith.proto.h" */

#endif /* __arith_H__ */
@}

@{
@c
#include "arith.h"
#include "stdlib.h"

/* third param indicates return value if one of the params is nil */ 
@:c_comp_ops(<,LT)@
@:c_comp_ops(<=,LE)@
@:c_comp_ops(==,EQ)@
@:c_comp_ops(!=,NEQ)@
@:c_comp_ops(>=,GE)@
@:c_comp_ops(>,GT)@

@:c_arith_ops(chr,chr,chr)@
@:c_arith_ops(chr,sht,sht)@
@:c_arith_ops(chr,int,int)@
@:c_arith_ops(chr,lng,lng)@
@:c_arith_ops(chr,flt,flt)@
@:c_arith_ops(chr,dbl,dbl)@

@:c_arith_ops(sht,chr,sht)@
@:c_arith_ops(sht,sht,sht)@
@:c_arith_ops(sht,int,int)@
@:c_arith_ops(sht,lng,lng)@
@:c_arith_ops(sht,flt,flt)@
@:c_arith_ops(sht,dbl,dbl)@

@:c_arith_ops(int,chr,int)@
@:c_arith_ops(int,sht,int)@
@:c_arith_ops(int,int,int)@
@:c_arith_ops(int,lng,lng)@
@:c_arith_ops(int,flt,flt)@
@:c_arith_ops(int,dbl,dbl)@

@:c_arith_ops(lng,chr,lng)@
@:c_arith_ops(lng,sht,lng)@
@:c_arith_ops(lng,int,lng)@
@:c_arith_ops(lng,lng,lng)@
@:c_arith_ops(lng,flt,flt)@
@:c_arith_ops(lng,dbl,dbl)@

@:c_arith_ops(flt,chr,flt)@
@:c_arith_ops(flt,sht,flt)@
@:c_arith_ops(flt,int,flt)@
@:c_arith_ops(flt,lng,flt)@
@:c_arith_ops(flt,flt,flt)@
@:c_arith_ops(flt,dbl,dbl)@

@:c_arith_ops(dbl,chr,dbl)@
@:c_arith_ops(dbl,sht,dbl)@
@:c_arith_ops(dbl,int,dbl)@
@:c_arith_ops(dbl,lng,dbl)@
@:c_arith_ops(dbl,flt,dbl)@
@:c_arith_ops(dbl,dbl,dbl)@

@:c_arith_ops(oid,oid,oid)@

#define arith_abs(s) ((s)>0)?(s):-(s)
@:arith_unop(_ABS,arith_abs,chr)@
@:arith_unop(_ABS,arith_abs,sht)@
@:arith_unop(_ABS,arith_abs,int)@
@:arith_unop(_ABS,arith_abs,flt)@
@:arith_unop(_ABS,arith_abs,dbl)@
@:arith_unop(_ABS,arith_abs,lng)@

#define arith_inv(s) (1/(s))
@:check_unop(_INV,arith_inv,chr)@
@:check_unop(_INV,arith_inv,sht)@
@:check_unop(_INV,arith_inv,int)@
@:check_unop(_INV,arith_inv,flt)@
@:check_unop(_INV,arith_inv,dbl)@
@:check_unop(_INV,arith_inv,lng)@

#define arith_neg(s) (-(s))
@:arith_unop(_NEG,arith_neg,chr)@
@:arith_unop(_NEG,arith_neg,sht)@
@:arith_unop(_NEG,arith_neg,int)@
@:arith_unop(_NEG,arith_neg,flt)@
@:arith_unop(_NEG,arith_neg,dbl)@
@:arith_unop(_NEG,arith_neg,lng)@

@:any_binary_minmax(MIN,<=)@
@:any_binary_minmax(MAX,>)@

#define arith_max(s1,s2) ((s1)>(s2))?(s1):(s2)
@:arith_macrobinop(_MAX,arith_max,chr)@
@:arith_macrobinop(_MAX,arith_max,sht)@
@:arith_macrobinop(_MAX,arith_max,int)@
@:arith_macrobinop(_MAX,arith_max,oid)@
@:arith_macrobinop(_MAX,arith_max,flt)@
@:arith_macrobinop(_MAX,arith_max,dbl)@
@:arith_macrobinop(_MAX,arith_max,lng)@

#define arith_min(s1,s2) ((s1)<(s2))?(s1):(s2)
@:arith_macrobinop(_MIN,arith_min,chr)@
@:arith_macrobinop(_MIN,arith_min,sht)@
@:arith_macrobinop(_MIN,arith_min,int)@
@:arith_macrobinop(_MIN,arith_min,oid)@
@:arith_macrobinop(_MIN,arith_min,flt)@
@:arith_macrobinop(_MIN,arith_min,dbl)@
@:arith_macrobinop(_MIN,arith_min,lng)@

@:arith_binop(_MOD,%,chr,int,int)@
@:arith_binop(_MOD,%,sht,int,int)@
@:arith_binop(_MOD,%,int,int,int)@
@:arith_binop(_MOD,%,lng,int,int)@
@:arith_binop(_MOD,%,int,chr,chr)@
@:arith_binop(_MOD,%,int,sht,sht)@

@:c_bitwise_ops(chr)@
@:c_bitwise_ops(sht)@
@:c_bitwise_ops(int)@
@:c_bitwise_ops(lng)@

@:c_shift_ops(chr)@
@:c_shift_ops(sht)@
@:c_shift_ops(int)@

int lngint_binary_RSH(lng *ret, lng *val, int *shift) {
    if (*val == lng_nil || *shift == int_nil) {
	*ret = lng_nil;
    } else {
	*ret = *val >> *shift; 
    }
    return GDK_SUCCEED;
}
int lngint_binary_LSH(lng *ret, lng *val, int *shift) {
    if (*val == lng_nil || *shift == int_nil) {
	*ret = lng_nil;
    } else {
	*ret = *val << *shift;
    }
    return GDK_SUCCEED;
}
int bit_binary_AND(bit *retval, bit *v1, bit *v2){
    if (*v1 == FALSE || *v2 == FALSE) {
	*retval = FALSE;
    } else if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = TRUE;
    }
    return GDK_SUCCEED;
}
int bit_binary_OR(bit *retval, bit *v1, bit *v2){
    if (*v1 && *v1 != bit_nil) {
	*retval = TRUE;
    } else if (*v2 && *v2 != bit_nil) {
	*retval = TRUE;
    } else if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = *v1 || *v2;
    }
    return GDK_SUCCEED;
}
int bit_binary_XOR(bit *retval, bit *v1, bit *v2){
    if (*v1 == bit_nil || *v2 == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = ((*v1 && *v2 == FALSE) || (*v1 == FALSE && *v2));
    }
    return GDK_SUCCEED;
}
int bit_unary_NOT(bit *retval, bit *value){
    if (*value == bit_nil) {
	*retval = bit_nil;
    } else {
	*retval = (*value)?FALSE:TRUE;
    }
    return GDK_SUCCEED;
}
int bit_switch(ptr retval, bit *b, ptr v1, int tpe, ptr v2) {
    register ptr p;
    if (*b == bit_nil) {
	p = ATOMnilptr(tpe);
    } else if (*b) {
	p = v1;
    } else {
	p = v2;
    }
    if (ATOMextern(tpe)) {
	*(ptr**) retval = ATOMdup(tpe, p);
    } else {
	memcpy(retval, p, ATOMsize(tpe)); 
    }
    return GDK_SUCCEED;
}

int int_rand( int *res ){
    *res = rand();
    return GDK_SUCCEED;
}

int int_srand( int *seed ){
    srand( *seed );
    return GDK_SUCCEED;
}

@T
The {\tt c\_comp} and {\tt c\_comp_ops} macros implement the mil comparison 
operations.

@= any_binary_minmax
int any_binary_@1(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)() = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0 || (*cmp)(v2, nil) == 0) {
		src = nil;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return GDK_SUCCEED;
}

@= c_comp_op
int @2_comp_@3(bit *retval, @2 *v1, @2 *v2){
	if (*v1 == @2_nil || *v2 == @2_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 @1 *v2;	
	}
	return GDK_SUCCEED;
}
@= c_comp_ops
@:c_comp_op(@1,chr,@2)@
@:c_comp_op(@1,sht,@2)@
@:c_comp_op(@1,int,@2)@
@:c_comp_op(@1,oid,@2)@
@:c_comp_op(@1,flt,@2)@
@:c_comp_op(@1,dbl,@2)@
@:c_comp_op(@1,lng,@2)@
int str_comp_@2(bit *retval, str *s1, str *s2){
	if (strNil(*s1) || strNil(*s2)) {
		*retval = bit_nil; 
	} else {
		*retval = (strcmp(*s1,*s2) @1 0);
	}
	return GDK_SUCCEED;
}
int any_comp_@2(bit *retval, ptr *v1, int tpe, ptr *v2){
	int (*cmp)() = BATatoms[tpe].atomCmp;
	ptr nil = ATOMnilptr(tpe);

	if ((*cmp)(*v1, nil) == 0 || (*cmp)(*v2, nil) == 0) {
		*retval = bit_nil; 
	} else {
		*retval = ((*cmp)( *v1, *v2) @1 0);
	}
	return GDK_SUCCEED;
}
@c
@:c_between_op(chr)@
@:c_between_op(sht)@
@:c_between_op(int)@
@:c_between_op(oid)@
@:c_between_op(flt)@
@:c_between_op(dbl)@
@:c_between_op(lng)@
int str_comp_between(bit *retval, str *val, str *low, str *high){
	int val_nil = strNil(*val);
	int low_nil = strNil(*low);
	int high_nil = strNil(*high);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = (strcmp(*val,*high) <= 0);
	} else if (high_nil) {
		*retval = (strcmp(*low,*val) <= 0);
	} else {
		*retval = (strcmp(*low,*val) <= 0 && strcmp(*val,*high) <= 0);
	}
	return GDK_SUCCEED;
}
int any_comp_between(bit *retval, ptr *val, int tpe, ptr *low, ptr *high){
	int (*cmp)() = BATatoms[tpe].atomCmp;
	ptr nilptr = ATOMnilptr(tpe);
	int val_nil = ((*cmp)(*val,nilptr) == 0);
	int low_nil = ((*cmp)(*low,nilptr) == 0);
	int high_nil = ((*cmp)(*high,nilptr) == 0);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = ((*cmp)(*val,*high) <= 0);
	} else if (high_nil) {
		*retval = ((*cmp)(*low,*val) <= 0);
	} else {
		*retval = ((*cmp)(*low,*val) <= 0 && (*cmp)(*val,*high) <= 0);
	}
	return GDK_SUCCEED;
}

@= c_isnil
int @1_isnil(bit *retval, @1 val) {
	*retval = (val == @1_nil);
	return GDK_SUCCEED;
}
/*
int @1_tonil(@1 *retval, ptr val){
	memcpy(retval, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return GDK_SUCCEED;
}
*/
@c
@:c_isnil(chr)@
@:c_isnil(sht)@
@:c_isnil(int)@
@:c_isnil(oid)@
@:c_isnil(flt)@
@:c_isnil(lng)@
@:c_isnil(dbl)@
@:c_isnil(str)@

int any_isnil(bit *retval, ptr *val, int tpe) {
	ptr nilval = ATOMnilptr(tpe);
	*retval = (ATOMcmp(tpe, nilval, *val) == 0);
	return GDK_SUCCEED;
}
@= c_between_op
int @1_comp_between(bit *retval, @1 *v, @1 *low, @1 *high){
	if (*v == @1_nil || (*low == @1_nil && *high == @1_nil)) {
		*retval = bit_nil;
	} else if (*low == @1_nil) {
		*retval = (*v <= *high);
	} else if (*high == @1_nil) {
		*retval = (*low <= *v);
	} else {
		*retval = (*low <= *v) && (*v <= *high);	
	}
	return GDK_SUCCEED;
}
@T
The {\tt c\_arith\_ops} implement the arithmetic operations on the given type.
The {\tt c\_arith\_ops} macro gets three arguments, two input types and a 
result type. 

@= c_arith_ops
@:arith_binop(_ADD,+,@1,@2,@3)@
@:arith_binop(_SUB,-,@1,@2,@3)@
@:arith_binop(_MUL,*,@1,@2,@3)@
@:check_binop(_DIV,/,@1,@2,@3)@
@

@= arith_unop
int @3_unary@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "@3_unary@1\n");
#endif
   if (*a == @3_nil) {
       *res = @3_nil;
   } else {   
       *res = @2 (*a);
   }
   return(GDK_SUCCEED);
}
@

@= check_unop
int @3_unary@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "@3_unary@1\n");
#endif
   if (*a == 0 || *a == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a);
   }
   return(GDK_SUCCEED);
}
@

@= arith_binop
int @3@4_binary@1(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "@3_binary@1\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(GDK_SUCCEED);
}
@

@= check_binop
int @3@4_checkbinary@1(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "@3_binary@1\n");
#endif
   if (*a == @3_nil || *b == 0 || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(GDK_SUCCEED);
}
@


@= c_bitwise_ops
@:arith_binop(_OR,|,@1,@1,@1)@
@:arith_binop(_AND,&,@1,@1,@1)@
@:arith_binop(_XOR,^,@1,@1,@1)@
@:arith_unop(_NOT,~,@1)@

@= c_shift_ops
@:arith_binop(_LSH,<<,@1,int,@1)@
@:arith_binop(_RSH,>>,@1,int,@1)@

@= arith_macrobinop
int @3_binary@1(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "@3_binary@1\n");
#endif
   if (*a == @3_nil || *b == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a,*b);
   }
   return(GDK_SUCCEED);
}
@
@}
