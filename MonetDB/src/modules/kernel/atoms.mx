@t The Atom Module
@a M.L. Kersten
@v 1.0
@* Introduction
Monet supports definitions of user-defined types. 
This feature is of particular interest to system experts. 
It is not meant for end-users trying to intruduce record- or 
struct-like objects in the database. They better decompose
the complex object structure and represent the components in
different BATs.

For the courageous at heart, you may enter the difficult world
of extending the kernel library. This calls for studying the
documentation associated with the atom structures (gdk_atoms),
because you have to develop routines complying with the
signatures required in the GDK library.

Once you have assembled these primitive, you can introduce them
in a running server using a ATOM MODULE definition, which contains
a MAL specification of their signature and calls to the routines
below to register the atom in the kernel.

Each ruler dealing with registering a function performs the necessary
type check, but relies on the user to comply with this signature in
its C-implementation. The ruler calls are part of a module
initialization routine.

A concrete example is the 'blob' datatype (see blob.mx)

@mal
module atoms;

pattern tostr(nme:str):int   = atoms_tostr;
pattern fromstr(nme:str):int = atoms_fromstr;
pattern nequal(nme:str):int  = atoms_nequal;
pattern hash(nme:str):int    = atoms_hash;
pattern null(nme:str):int    = atoms_null;
pattern convert(nme:str):int = atoms_convert;
pattern put(nme:str):int     = atoms_put;
pattern del(nme:str):int     = atoms_del;
pattern length(nme:str):int  = atoms_length;
pattern heap(nme:str):int    = atoms_heap;

@-
The Monet kernel contains a few built-in atomic types together
with useful functions. 
Those accessible at the MAL command level are introduced below.

@= convertCmd
COMMAND @1(v:str):@1 = @1FromStrImpl;
COMMAND str(v:@1):str = @1ToStrImpl;

@mal
@:convertCmd(oid)@
@:convertCmd(void)@
@:convertCmd(sht)@
@:convertCmd(int)@
@:convertCmd(lng)@
@:convertCmd(flt)@
@:convertCmd(dbl)@
@:convertCmd(bit)@
@:convertCmd(ptr)@
@:convertCmd(bat)@
@:convertCmd(chr)@

COMMAND setoid(v:int)= intSetoidImpl;
COMMAND setoid(v:lng)= lngSetoidImpl;
COMMAND setoid(v:oid)= oidSetoidImpl;
@-
We might also support a number of common coercion routines.
Note, we do not support automatic coercion at the MIL level.
@mal
COMMAND lng(v:oid):lng = lngFromoidImpl;
COMMAND lng(v:int):lng = lngFromintImpl;
COMMAND lng(v:sht):lng = lngFromshtImpl;
COMMAND lng(v:bit):lng = lngFrombitImpl;
COMMAND int(v:sht):int = intFromshtImpl;
COMMAND int(v:bit):int = intFromintImpl;
COMMAND dbl(v:flt):dbl = dblFromfltImpl;
COMMAND oid(v:lng):oid = oidFromlngImpl;
COMMAND oid(v:int):oid = oidFromintImpl;
COMMAND sht(v:int):sht = shtFromintImpl;
COMMAND sht(v:lng):sht = shtFromlngImpl;

COMMAND bit(v:bit):bit = bitFrombitImpl;
COMMAND sht(v:sht):sht = shtFromshtImpl;
COMMAND int(v:int):int = intFromintImpl;
COMMAND lng(v:lng):lng = lngFromlngImpl;
COMMAND flt(v:flt):flt = fltFromfltImpl;
COMMAND dbl(v:dbl):dbl = dblFromdblImpl;
COMMAND ptr(v:ptr):ptr = ptrFromptrImpl;
COMMAND oid(v:oid):oid = oidFromoidImpl;

COMMAND void(v:void):void = voidFromvoidImpl;
COMMAND bit(v:void):bit = bitFromvoidImpl;
COMMAND sht(v:void):sht = shtFromvoidImpl;
COMMAND int(v:void):int = intFromvoidImpl;
COMMAND lng(v:void):lng = lngFromvoidImpl;
COMMAND bat(v:void):bat = batFromvoidImpl;
COMMAND flt(v:void):flt = fltFromvoidImpl;
COMMAND dbl(v:void):dbl = dblFromvoidImpl;
COMMAND oid(v:void):oid = oidFromvoidImpl;
COMMAND ptr(v:void):ptr = ptrFromvoidImpl;
@-
We should also deal with superflous operations, such as int(v:int).
This is a noop operation that should ideally be filtered out with
the code squeezer. [TODO]
@c
@+ The Module implementation
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#ifndef _MAL_ATOMS
#define _MAL_ATOMS
#include "mal_stack.h"
#include "mal_resolve.h"

#include "gdk.h"
#define DEBUG_MAL_ATOMS 1
#endif /*  _MAL_ATOMS*/

@c
#include "atoms.h"
@-
The pattern for conversion routines is relatively easy to define.
@= convertImpl

int @1FromStrImpl(@1 *ret, str *val){
	int l = sizeof(@1);
	(void) @1FromStr(*val, &l, &ret);
	return GDK_SUCCEED;
}
int @1ToStrImpl(str *ret, @1 *val){
	int l=strlen(*ret);
	(void) @1ToStr(ret,&l,val);
	return GDK_SUCCEED;
}
int @1From@1Impl(@1 *ret, @1 *val){
	*ret= *val;
	return GDK_SUCCEED;
}
int @1FromvoidImpl(@1 *ret, void *val){
	memcpy(ret, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return GDK_SUCCEED;
}
@-
Strings have to be dealt with differently, because
we recieve a pointer to the string directly.
To make it work properly, we need a call be reference
in those places where we leave a result behind.
@c
int voidFromStrImpl(void *ret, str val){
	memcpy(ret, ATOMnilptr(TYPE_void), ATOMsize(TYPE_void));
	return GDK_SUCCEED;
}
int voidToStrImpl(str *ret, void *val){
	*ret = ATOMnilptr(TYPE_str);
	return GDK_SUCCEED;
}
int oidFromStrImpl(oid *ret, str *val){
	int l = strlen(*val);
	(void) OIDfromStr(*val, &l, (ptr) ret);
	return GDK_SUCCEED;
}
int oidToStrImpl(str *ret, oid *val){
	int l= sizeof(oid);
	(void) OIDtoStr(ret,&l, val);
	return GDK_SUCCEED;
}
int voidFromvoidImpl(oid *ret, ptr *val){
	*ret = oid_nil;
	return GDK_SUCCEED;
}
int oidFromoidImpl(oid *ret, oid *val){
	*ret= *val;
	return GDK_SUCCEED;
}
int oidFromvoidImpl(oid *ret, void *val){
	memcpy(ret, ATOMnilptr(TYPE_oid), ATOMsize(TYPE_oid));
	return GDK_SUCCEED;
}
@:convertImpl(sht)@
@:convertImpl(int)@
@:convertImpl(lng)@
@:convertImpl(flt)@
@:convertImpl(dbl)@
@:convertImpl(bit)@
@:convertImpl(ptr)@
@:convertImpl(bat)@
@:convertImpl(chr)@
@-
@= setoidCode
int @1SetoidImpl(str *ret, @1 *v){
	OIDbase(*v);
	return GDK_SUCCEED;
}
@c
@:setoidCode(oid)@
@:setoidCode(lng)@
@:setoidCode(int)@
@-
Type conversion template. Only allowed then no information is lost.

@= coercionImpl
int @1From@2Impl(@1 *res, @2 *val){
	*res = *val;
	return GDK_SUCCEED;
}
@c
@:coercionImpl(lng,oid)@
@:coercionImpl(lng,int)@
@:coercionImpl(lng,sht)@
@:coercionImpl(lng,bit)@
@:coercionImpl(int,sht)@
@:coercionImpl(int,bit)@
@:coercionImpl(dbl,flt)@
@:coercionImpl(oid,lng)@
@:coercionImpl(oid,int)@
@:coercionImpl(oid,sht)@

int shtFromlngImpl(sht *res, lng *val){
	/* perform a range check !! */
	if( *val<0 ||*val >255){
		raiseException(0,0,"ERROR","coercion error lng->sht\n");
		return GDK_FAIL;
	}
	*res = *val;
	return GDK_SUCCEED;
}
int shtFromintImpl(sht *res, int *val){
	/* perform a range check !! */
	if( *val<0 ||*val >255){
		raiseException(0,0,"ERROR","coercion error int->sht\n");
		return GDK_FAIL;
	}
	*res = *val;
	return GDK_SUCCEED;
}
int atoms_tostr(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_tostr:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_fromstr(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_fromstr:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_nequal(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_nequal:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_hash(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_hash:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_null(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_null:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_convert(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_convert:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_put(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_put:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_del(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_del:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_heap(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_heap:not yet implemented\n");
	return GDK_SUCCEED;
}
int atoms_length(MalBlkPtr m, MalStkPtr s, InstrPtr p){
	GDKerror("ERROR:atoms_length:not yet implemented\n");
	return GDK_SUCCEED;
}
