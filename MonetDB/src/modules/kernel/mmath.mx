@f mmath
@a N.J. Nes, M.Kersten
@d 07/01/1996, 4/9/2001
@t The math module

@* Introduction
This module contains the math commands. The implementation is very simply,
the c math library functions are called. See for documentation the
ANSI-C/POSIX manuals of the equaly named functions.

@* Module Definition
@mal
module mmath;

command acos(x:dbl) 	  : dbl = math_unary_ACOS
comment "The acos(x) function calculates the arc cosine of x;
that is the value whose cosine is x. The value is returned in radians
and is mathematically defined to be between 0 and PI (inclusive).";

command asin(x:dbl)     : dbl = math_unary_ASIN
comment "The asin(x) function calculates the arc sine of x;
that is the value whose sine is x. The value is returned in radians
and is mathematically defined to be between -PI/20 and -PI/2 (inclusive).";

command atan(x:dbl)     : dbl = math_unary_ATAN
comment "The atan(x) function calculates the arc tangent of x;
that is the value whose tangent is x. The value is returned in radians
and is mathematically defined to be between -PI/2 and PI/2 (inclusive).";

command atan2(x:dbl,y:dbl): dbl = math_binary_ATAN2
comment "The atan2(x,y) function calculates the arc tangent of the two
variables x and y. It is similar to calculating the arc
tangent of y / x, except that the signs of both arguments
are used to determine the quadrant of the result.
The value is returned in radians and is mathematically defined
to be between -PI/2 and PI/2 (inclusive).";

command cos(x:dbl)   	  : dbl = math_unary_COS
comment "The cos(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1.";

command sin(x:dbl)   	  : dbl = math_unary_SIN
comment "The sin(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1.";

command tan(x:dbl)   	  : dbl = math_unary_TAN
comment "The tan(x) function returns the tangent of x,
where x is given in radians";

command cosh(x:dbl)     : dbl = math_unary_COSH
comment "The cosh() function  returns the hyperbolic cosine of x,
which is defined mathematically as (exp(x) + exp(-x)) / 2.";

command sinh(x:dbl)     : dbl = math_unary_SINH
comment "The sinh() function  returns  the  hyperbolic sine of x,
which is defined mathematically as (exp(x) - exp(-x)) / 2.";

command tanh(x:dbl)     : dbl = math_unary_TANH
comment "The tanh() function returns the hyperbolic tangent of x,
which is defined mathematically as sinh(x) / cosh(x).";

command exp(x:dbl)   	  : dbl = math_unary_EXP
comment "The exp(x) function returns the value of e
(the base of natural logarithms) raised to the power of x.";

command log(x:dbl)   	  : dbl = math_unary_LOG
comment "The log(x) function returns the natural logarithm of x."

command log10(dbl)    : dbl = math_unary_LOG10
comment "The log10(x) function returns the base-10 logarithm of x.";

command pow(x:dbl,y:dbl)  : dbl = math_binary_POW
comment "The pow(x,y) function  returns the value of x raised to the power of y.";

command sqrt(x:dbl)  	  : dbl = math_unary_SQRT
comment "The sqrt(x) function returns the non-negative square root of x.";

command ceil(x:dbl)     : dbl = math_unary_CEIL
comment "The ceil(x) function rounds x upwards to the nearest integer.";

command fabs(x:dbl)     : dbl = math_unary_FABS
comment "The fabs(x) function  returns  the  absolute value of the 
floating-point number x.";

command floor(x:dbl)    : dbl = math_unary_FLOOR
comment "The floor(x) function rounds x downwards to the nearest integer.";

command fmod(x:dbl,y:dbl) : dbl = math_binary_FMOD
comment "The fmod(x,y) function computes the remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y,
rounded towards zero to an integer.";

command round(x:dbl,y:int)     : dbl = math_binary_ROUND
comment "The round(n, m) returns n rounded to m places to the right of the
decimal point; if m is omitted, to 0 places. m can be negative to
round off digits left of the decimal point. m must be an integer.";

@
The constants defined in math.h are defined using the following mil code.
@mil
	const M_E 	:= 2.7182818284590452354LL;
	const M_LOG2E 	:= 1.4426950408889634074LL;
	const M_LOG10E 	:= 0.43429448190325182765LL;
	const M_LN2 	:= 0.69314718055994530942LL;
	const M_LN10 	:= 2.30258509299404568402LL;
	const M_PI	:= 3.14159265358979323846LL;
	const M_PI_2	:= 1.57079632679489661923LL;
	const M_PI_4	:= 0.78539816339744830962LL;
	const M_1_PI	:= 0.31830988618379067154LL;
	const M_2_PI	:= 0.63661977236758134308LL;
	const M_2_SQRTPI:= 1.12837916709551257390LL;
	const M_SQRT2	:= 1.41421356237309504880LL;
	const M_SQRT1_2	:= 0.70710678118654752440LL;

@* Example Script
@mil
module(mmath);
setoid(oid(20000000));
asin(sin(M_PI)).print;
acos(cos(M_PI)).print;
atan(tan(M_PI_2)).print;
atan(tan(M_PI_4)).print;
tan(atan2(dbl(0.1),dbl(1.0))).print;
sqrt(pow(dbl(2),dbl(2))).print;

exp(dbl(10)).print;
log(dbl(10)).print;
log10(dbl(10)).print;

ceil(dbl(1.2)).print;
fabs(dbl(1.2)).print;
floor(dbl(1.2)).print;
fmod(dbl(15.2),dbl(2.5)).print;

quit;
@{
@h
#ifndef __MMATH_H__
#define __MMATH_H__

#include <gdk.h>
#include "mmath.h"

#endif /* __MMATH_H__ */
@}

@{
@* Implementation Code
@c

/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#include "mmath.h"
#include <math.h>

extern double sqrt(double x);
extern double cbrt(double x);
extern double sin(double x);
extern double cos(double x);
extern double fabs(double x);

#define acos_unary(x, z)      *z = acos(*x)
#define asin_unary(x, z)      *z = asin(*x)
#define atan_unary(x, z)      *z = atan(*x)
#define atan2_binary(x, y, z) *z = atan2(*x,*y)
#define cos_unary(x, z)       *z = cos(*x)
#define sin_unary(x, z)       *z = sin(*x)
#define tan_unary(x, z)       *z = tan(*x)

#define cosh_unary(x, z)       *z = cosh(*x)
#define sinh_unary(x, z)       *z = sinh(*x)
#define tanh_unary(x, z)       *z = tanh(*x)

#define exp_unary(x, z)       *z = exp(*x)
#define log_unary(x, z)       *z = log(*x)
#define log10_unary(x, z)     *z = log10(*x)

#define pow_binary(x, y, z)   *z = pow(*x,*y)
#define sqrt_unary(x, z)      *z = sqrt(*x)

#define ceil_unary(x, z)      *z = ceil(*x)
#define fabs_unary(x, z)      *z = fabs(*x)
#define floor_unary(x, z)     *z = floor(*x)
#define fmod_binary(x, y, z)  *z = fmod(*x,*y)

@:unop(_ACOS,acos)@
@:unop(_ASIN,asin)@
@:unop(_ATAN,atan)@
@:binop(_ATAN2,atan2)@
@:unop(_COS,cos)@
@:unop(_SIN,sin)@
@:unop(_TAN,tan)@

@:unop(_COSH,cosh)@
@:unop(_SINH,sinh)@
@:unop(_TANH,tanh)@

@:unop(_EXP,exp)@
@:unop(_LOG,log)@
@:unop(_LOG10,log10)@

@:binop(_POW,pow)@
@:unop(_SQRT,sqrt)@

@:unop(_CEIL,ceil)@
@:unop(_FABS,fabs)@
@:unop(_FLOOR,floor)@
@:binop(_FMOD,fmod)@

@= unop
int math_unary@1(dbl *res , dbl *a ) {
#ifdef DEBUG
	printf( "math_unary@1\n");
#endif
   if (*a == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_unary( a, res );
   }
   return(GDK_SUCCEED);
}
@

@= binop
int math_binary@1(dbl *res, dbl *a, dbl *b ) {
#ifdef DEBUG
	printf( "math_binary@1\n");
#endif
   if (*a == dbl_nil || *b == dbl_nil) {
	*res = dbl_nil;
   } else {
	@2_binary( a, b, res);
   }
   return(GDK_SUCCEED);
}
@

@c
int math_binary_ROUND(dbl *res, dbl *x, int *y) {
  if(*x == dbl_nil || *y == int_nil) {
    *res = dbl_nil;
  } else {
    double factor = pow(10,*y), integral;
    double tmp = *y>0?modf(*x,&integral):*x;

    tmp *= factor;
    if(tmp>=0)
      tmp = floor(tmp+0.5);
    else
      tmp = ceil(tmp-0.5);
    tmp /= factor;

    if(*y>0)
      tmp += integral;

    *res = tmp;
  }

  return(GDK_SUCCEED);
}
@}
