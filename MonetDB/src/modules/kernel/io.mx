@f io
@t The io Module
@a N.J. Nes, M.L. Kersten
@d 01/07/1996, 31/01/2002

@+ Introduction
@T
This module contains all the file access commands. The implementation
is very simple. All function call the stdio library function.

This module is seperated from the database kernel since some 
servers are not allowed to do file accesses.

{\tt fopen()} opens the file named by filename  and  associates  a
fstream  with  it. {\tt fopen()}  returns  a  pointer to the FILE
structure associated with the fstream. The resulting pointer is needed
by all other io function. So fopen should be called before any other 
function. 

The {\tt fclose()} command closes the associated fstream. The FILE pointer 
given can not be used after calling this function. 

Pipes can be created with {\tt popen()}. This function returns the
identifier to a bidirectional pipe. You can then for instance {\tt fork()}
a new Monet session, passing this identifier.

Both sessions can then use the pipe to open a fstream with {\tt fdpipe()}.
The one end should pass {\tt true} as the {\tt up} parameter, the other
{\tt down}. This function returns a fstream, and can be used in combination
with any of the functions of this module.

The {\tt fflush()} command flushes the buffer of the associated fstream.

{\tt feof()} returns non-zero when EOF has previously been
detected reading the named input fstream, otherwise zero.

{\tt freopen()} substitutes the named file in place  of  the  open
fstream. A flush is first attempted, and then the original
fstream is closed, regardless of whether the open ultimately
succeeds. Failure to flush or close fstream successfully is
ignored. It returns the new FILE pointer.

The {\tt fread()} and {\tt fwrite()} commands read/write a number of bytes 
to or from a associated fstream. The read function returns a string 
containing the result. The write function returns the number of written bytes. 

The {\tt fseek()} function seeks an offset number of bytes form the start, the 
current position, or the end of the fstream.
\footnote{See the mil script file for the correct constants.}
This function returns the number of bytes moved. 

The {\tt fprintf()} function print a variable number of 
arguments using the format string. They return the number of arguments 
printed. 

The {\tt fputs()} places a string on the given output fstream. 
{\tt fgets()} reads a string until an end of line is found form the 
given input fstream. 

Look at the related ANSI-C/POSIX manual pages to get the needed information.
This module uses the blob atom.
@* Module Definition
@mal
atom module fstream : ptr;
atom module bipipe : lng;

module io;

command stdin() : fstream = io_stdin 
comment "return the input fstream to the database client";
command stderr() : fstream = io_stderr 
comment "return the error fstream for the database console";
command stdout() : fstream = io_stdout 
comment "return the output fstream for the database client";

command fopen ( filename:str, mode:str ) : fstream = io_fopen 
comment "See: man fopen. Returns fstream, or fstream(nil) on failure.";
command freopen ( filename:str, mode:str, f:fstream ) : fstream = io_freopen 
comment "See: man freopen. Returns fstream, or fstream(nil) on failure.";
command popen( ) : bipipe = io_popen 
comment "Open a bidirectional pipe. See: man pipe" ;
command fdpipe(b:bipipe, up:bit, mode:str) : fstream = io_fdpipe 
comment "Open a fstream in one direction through a pipe." ;
command ferror() : str = io_ferror 
comment "returns last error message. str(nil) if none. ";

command fclose( f:fstream ):void = io_fclose comment "See: man fclose";
command fflush( f:fstream ):void = io_fflush comment "See: man fflush";
command feof( f:fstream ) : bit = io_feof comment "See: man feof";

command fread( filep:fstream, nbytes:int ) : blob = io_fread 
comment "See: man fread";
command fwrite( filep:fstream, buf:str, nbytes:int ):void = io_fwrite_str 
comment "See: man fwrite";
command fwrite( filep:fstream, buf:blob, nbytes:int ):void = io_fwrite 
comment "See: man fwrite";
command fseek( filep:fstream, pos:int, offset:int ) : int = io_fseek 
comment "See: man fseek";
command ftell( filep:fstream ) : int = io_ftell 
comment "See: man ftell";

command fsize( filename:str ) : int = io_fsize 
comment "Return the filesize, or -1 when there was some error";

pattern fprint( filep:fstream , arg:any[] ):void = io_fprint 
comment "Print a (comma seperated) list of arguments";

pattern fprintf( filep:fstream, format:str, arg:any[] ):void = io_fprintf 
comment "See: man fprintf";

command fputs( s:str, filep:fstream):voidd = io_fputs comment "See: man fputs";
command fgets( filep:fstream ): str = io_fgets comment "See: man fgets";

command fputc( c:int, filep:fstream ):void = io_fputc comment "See: man fputs";
command fgetc( filep:fstream ): chr = io_fgetc comment "See: man fgetc";

pattern ftable( filep:fstream, b:BAT[any::1,any][] ) = io_ftable_default 
comment "Print an n-ary table to a file.";

command ftable( filep:fstream, orderspec:int,b:BAT[any::1,any][] ) = io_ftable 
comment "Print an n-ary table to a file, using order of BAT [1..argc].";

@- MIL initializations 
The constants for the seek function.
@* Example Script
@mil
        const EOF      := -1;
        const SEEK_SET := 0;
        const SEEK_CUR := 1;
        const SEEK_END := 2;
setoid(oid(20000000));
module(io);

fp := fopen ( "test", "w+" );
fwrite( fp, "Dit is een test\n", 17 );
fp := freopen ( "test", "r+", fp );
fread( fp, 17 ).tostr.print;

fseek( fp, 0, 0);
fprintf( fp, "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );

s := "testing again and again\n";

fseek( fp, 0, 0);
fputs( s, fp );
fseek( fp, 0, 0);
s := fgets( fp );

fflush( fp );
fclose( fp );
printf( "%s %d %c %d %f\n", "test", 10, 'c', 10, 7.0 );
printf( "%s\n", s );

quit;
@{
@* Implementation Code
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2002 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 */

#ifndef _IO_H_
#define _IO_H_

#include <stdio.h>
#include <stdarg.h>
#include <blob.h>

typedef struct {
	int up, down;
} bipipe;

typedef FILE* fstream;

#define FILEP_CHECK(fp) \
	if (!fp){ \
		GDKerror( "Incorrect file pointer\n"); \
		return(GDK_FAIL); \
	}


#endif /* _IO_H_ */

@c
#include "io.h"
#include "monet.h"

int io_stdin (fstream *ret) { *ret = GDKin;  return GDK_SUCCEED; }
int io_stdout(fstream *ret) { *ret = GDKout; return GDK_SUCCEED; }
int io_stderr(fstream *ret) { *ret = stderr; return GDK_SUCCEED; }

int io_fclose(int *ret, fstream* filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   if (fclose(fp) < 0) {
	GDKsyserror("io_fclose:");
	return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fflush(int *ret, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   (void)fflush(fp);
   return(GDK_SUCCEED);
}

int io_popen(bipipe **retval){
   if(*retval) GDKfree(*retval);
   *retval= (bipipe*) GDKmalloc(sizeof(bipipe));
   if (pipe((int*) *retval) < 0) {
	GDKsyserror("io_popen:");
	return GDK_FAIL;
   }
   return GDK_SUCCEED;
}
int io_fdpipe(fstream *retval, bipipe* p, bit *up, str *mode){
   *retval = (fstream) fdopen(up?p->up:p->down, *mode);
   if (*retval == 0) return GDK_SUCCEED;
   GDKsyserror("io_fdpipe:");
   return GDK_FAIL;
}

int io_feof( bit *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = feof(fp)?TRUE:FALSE;
   return(GDK_SUCCEED);
}

int io_fopen( fstream *res, str *name, str *mode ){
   *res = fopen(*name,*mode);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return GDK_SUCCEED;
}

int io_freopen( fstream *res, str *name, str *mode, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = freopen(*name,*mode,fp);
   if (!*res) *res = *(fstream*) ATOMnilptr(TYPE_ptr);
   return GDK_SUCCEED;
}

int io_ferror( str *msg) {
   int r = MT_geterrno();
   if (r) {
    	*msg = GDKstrdup(strerror(r));
   } else { 
	*msg = str_nil;
   }
   return GDK_SUCCEED;
}

int io_fread( blob **res, fstream *filepp, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int err = -1;
   str buf;
   FILEP_CHECK(fp);
   buf = (str) GDKmalloc( sizeof(int) + *nbytes );
   if ((*res = (blob*) buf) != NULL){
   	err = fread(buf+sizeof(int),1,*nbytes,fp);
   }
   if (err<0){
      GDKsyserror("io_fread:");
      if (*res) GDKfree(*res);
      return(GDK_FAIL);
   }
   (**res).nitems= err;
   return(GDK_SUCCEED);
}

int io_fwrite_str(int *ret, fstream *filepp, str *buf, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = strlen(*buf); 
   FILEP_CHECK(fp);
   if (*nbytes < n) n = *nbytes;
   if (fwrite(*buf,1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite_str:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fwrite(int *ret, fstream *filepp, blob **b, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   int n = *nbytes;
   str buf = (str*) *b;
   FILEP_CHECK(fp);
   if (n> (**b).nitems) {
	n = MAX(0,(**b).nitems);
	GDKerror("io_fwrite: blob contains only %d bytes.\n", (**b).nitems);
   }
   if (fwrite(buf+sizeof(int),1,n,fp) < (size_t) n) {
      GDKsyserror("io_fwrite:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fseek(int *res, fstream *filepp, int *pos, int *nbytes ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = fseek(fp, (long)*pos, *nbytes);
   if (*res < 0) {
      GDKsyserror("io_fseek:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_ftell(int *res, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *res = ftell(fp);
   if (*res < 0) {
      GDKsyserror("io_ftell:");
      return(GDK_FAIL);
   }
   return(GDK_SUCCEED);
}

int io_fsize(int* res, str *filename){
#ifdef HAVE_FSTAT
	struct stat buf;
	if (stat(*filename,&buf))
		*res = -1;
	else
		*res = (int)buf.st_size;
#else
        *res = -1;
#endif
	return(GDK_SUCCEED);
}


int io_fprintf(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	GDKwarning("io_fprintf: not defined in version-5\n");
        return GDK_SUCCEED;
}
/*
int io_fprintf(fstream *filepp, str format,  ...){
        va_list ap;
        int ret;
        str s;
 
	FILEP_CHECK(*filepp);
        va_start(ap,format);
        ret = monet_sprintf(&s, format, ap);
        va_end(ap);
        if (ret == GDK_FAIL) {
                return GDK_FAIL;
        }
        if (fputs(s, *filepp) < 0) {
                GDKsyserror("io_fprintf():");
                GDKfree(s);
                return GDK_FAIL;
        }
	GDKfree(s);
        return GDK_SUCCEED;
}
*/

int io_fprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	GDKwarning("io_fprint: not defined in version-5\n");
        return GDK_SUCCEED;
}
/*
int io_fprint(fstream *filepp, ...){
        va_list ap;
        ptr val; 
	int type;
 
	FILEP_CHECK(*filepp);
        va_start(ap,filepp);

	val = va_arg (ap,ptr);
        if(val){
		type = va_arg(ap,int);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "%s(\"", ATOMname(type) );
		ATOMprint(type, val, *filepp);
		if (ATOMstorage(type) != TYPE_str)
			fprintf( *filepp, "\")" );
		val = va_arg (ap,ptr);
        	while(val){
			type = va_arg(ap,int);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, ", %s(\"", ATOMname(type) );
			else
				fprintf( *filepp, ", ");
			ATOMprint(type, val, *filepp);
			if (ATOMstorage(type) != TYPE_str)
				fprintf( *filepp, "\")" );
			val = va_arg (ap,ptr);
		}
	}
        va_end(ap);
        return GDK_SUCCEED;
}
*/


int io_fputs(int *ret, str *s, fstream *filepp ){
   FILEP_CHECK(*filepp);
   if (fputs(*s,*(FILE**)filepp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fputc(int *ret,int *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   if (fputc(*c, fp) < 0) {
      GDKsyserror("io_fputs: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgets( str *s, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   FILEP_CHECK(fp);
   *s = GDKmalloc( BUFSIZ );
   **s = 0;
   if (fgets(*s, BUFSIZ, fp) <= (char *) 0) {
      if (feof(fp)){
        **s = 0;
      	return(GDK_SUCCEED);
      }
      GDKsyserror("io_fgets: ");
      return GDK_FAIL;
   }
   return(GDK_SUCCEED);
}

int io_fgetc( chr *c, fstream *filepp ){
   FILE *fp = *(FILE**) filepp; 
   int ret;
   FILEP_CHECK(fp);
   ret = (int)fgetc(fp);
   if (ret <= 0) {
      GDKsyserror("io_fgetc: ");
      return GDK_FAIL;
   }
   *c = ret;
   return(GDK_SUCCEED);
}

int io_ftable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	GDKwarning("io_ftable: not defined in version-5\n");
        return GDK_SUCCEED;
}
/*
typedef BAT* batptr;

int io_ftable( fstream* filepp, int *orderspec, ...){
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	FILEP_CHECK(*filepp);
        va_start (ap, orderspec);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(*filepp, argc, piv, FALSE, *orderspec);
        return GDK_SUCCEED;
}

*/
int io_ftable_default(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	GDKwarning("io_ftable_default: not defined in version-5\n");
        return GDK_SUCCEED;
}
/*
int io_ftable_default(fstream *filepp, ...) {
        BAT *piv[MAXPARAMS];
        int argc = 0;
        va_list ap;

   	FILEP_CHECK(*filepp);
        va_start (ap,filepp);
        do {
                piv[argc] = va_arg (ap,BAT*) ;
        } while(piv[argc++]);
        va_end (ap);
        BATmultiprintf(*filepp, argc, piv, FALSE, 0);
        return GDK_SUCCEED;
}
*/
@}
