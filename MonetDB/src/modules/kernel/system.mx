@f system
@t System Information BATs and basic IO
@a M.L. Kersten, P. Boncz, N.Nes
@v 1.0
@* Introduction
This document introduces a series of pseudo bats that provide access
to information stored within the Monet internal data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

In addition, this module contains the primitives for printing on the
client stdout channel. Additional file-directed IO is maintained in
the io module.

@* Module Definition 
@mal
module system;

@- Performance Stats
@mal
command view_gdk_cpu() : bat[str,int] = view_gdk_cpu
	comment "Global cpu usage info";
command view_gdk_memory(): bat[str,int] = view_gdk_mem
	comment "Global memory usage info";
command view_gdk_io(): bat[str,int] = view_gdk_io
	comment "Global IO activityinfo";
command view_gdk_bbp(): bat[str,int] = view_gdk_bbp
	comment "Global BBP usage info";

command mem_printmap() : void = print_mem_map
        comment "print a map of all memory that is in use";
command mem_cursize() : lng = get_mem_cursize
 	comment "the amount of physical swapspace in KB that is currently in use";
command mem_maxsize() : lng = get_mem_maxsize
 	comment "the maximum usable amount of physical swapspace in KB (target only)";
command mem_maxsize(v:lng) : void = set_mem_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
command vm_cursize() : lng = get_vm_cursize
 	comment "the amount of logical VM space in KB that is currently in use";
command vm_maxsize() : lng = get_vm_maxsize
 	comment "the maximum usable amount of logical VM space in KB (target only)";
command vm_maxsize(v:lng) : void = set_vm_maxsize
 	comment "set the maximum usable amount of physical swapspace in KB";
command mem_usage(minsize:lng) : bat[str,lng] = get_mem_usage
	comment "get a split-up of how much memory blocks are in use.";
command vm_usage(minsize:lng) : bat[str,lng] = get_vm_usage
	comment "get a split-up of how much virtual memory blocks are in use.";

@- BAT Buffer Pool
@mal
command view_bbp_name(): bat[int,str] = view_bbp_name
	comment "Pseudo bat to map a BAT id into its name";
command view_bbp_refcnt(): bat[int,int] = view_bbp_refcnt
	comment "Pseudo bat to map a BAT id into its reference count";
command view_bbp_location(): bat[int,str] = view_bbp_location
	comment "Pseudo bat to map a BAT id into its disk location";
command view_bbp_heat(): bat[int,int] = view_bbp_heat
	comment "Pseudo bat to map a BAT id into its name";
command view_bbp_dirty(): bat[int,str] = view_bbp_dirty
	comment "Pseudo bat to map a BAT id into its dirty/diffs/clean status";
command view_bbp_status(): bat[int,str] = view_bbp_status
	comment "Pseudo bat to map a BAT id into its disk/load status";
command view_bbp_kind(): bat[int,str] = view_bbp_kind
	comment "Pseudo bat to map a BAT id into its type";

command check_bbp_size() : lng = check_bbp_size
	comment "Walk the BBP directories, delete leftovers and return total size";

@- GDK status 
@mal
command view_gdk_env( ): bat[str,str] = view_gdk_env
	comment "Pseudo bat to map thread to name";
command view_gdk_thread( ): bat[int,str] = view_gdk_thread
	comment "Pseudo bat to map thread to name";

@- Monet Client Data
Depricated routines. The client structure is changed
@mal
command view_client_name( ): bat[int,str] = view_client_name
	comment "Pseudo bat to map client identifier to its name";
command view_client_login( ): bat[int,str] = view_client_login
	comment "Pseudo bat to map client identifier to its login time";
command view_client_tree( ): bat[int,str] = view_client_tree
	comment "Pseudo bat to map client identifier to its current active tree";

@- Monet Variables
The Monet Variable commands are depreciated, because here we
convert it to Mal. This has a different structure.
command view_var_type() : bat[int,str] = view_var_type
	comment "Pseudo bat to gain access to all visible variables";
command view_var_kind() : bat[int,str] = view_var_kind
	comment "Pseudo bat to map variable name to frozen/liquid";
command view_var_constant() : bat[int,str] = view_var_constant
	comment "Pseudo bat to map variable name to constant/changeable";
command view_var_value() : bat[int,str] = view_var_value
	comment "Pseudo bat to map variable name to its value (as a string).";

@- Monet Modules
The monet modules are stored differently in V5. Several of the
old dictionary tables are retained and turned into a view.

@mal
command view_modules() : bat[int,str] = view_module
	comment "Pseudo bat with all currently available modules" ;
command module_name(nme:str) : str = get_mod_name
	comment "extract module name from module string" ;
command module_db(nme:str) : str = get_mod_db
	comment "extract database name from module string" ;
command format_fcn_sig(nme:str) : str = format_fcn_sig
	comment "print a function signature";


@- Printing 
The polymorphic print commands are collected here.
Watch out, the order of definitions is crucial, because the most
specific should be introduced last.
@mal

pattern print(b1:bat[ANY::1,ANY], b2:bat[ANY::1,ANY][]):int = CMDprint_table
 comment "BATs are printed with '#' for legend lines, and the BUNs on seperate
 lines between brackets, containing each to comma separated values
 (head and tail).
 If multiple BATs are passed for printing, print() performs an implicit
 natural join, producing a multiattribute table.";

pattern print(order:int,b:bat[ANY::1,ANY], b2:bat[ANY::1,ANY][]):int
                                                = CMDprint_otable
 comment "The same as normal table print, but enforces to use the order of
  BAT number [1..argc] to do the printing.";

pattern table(b1:bat[any::1,any], b2:bat[any::1,any][]):int = CMDprint_table_default
	comment "Print an n-ary table. Like print(n-ary) but does not print oid column";

pattern table(order:int, b1:bat[any::1,any], b2:bat[any::1,any][]):int = CMDprint_otable
	comment "Print an n-ary table. Use the ordering of param [1..argc]";

command printf(format:str,val:bit):int = CMDprint_bit;
command printf(format:str,val:chr):int = CMDprint_chr;
command printf(format:str,val:int):int = CMDprint_int;
command printf(format:str,val:sht):int = CMDprint_sht;
command printf(format:str,val:oid):int = CMDprint_oid;
command printf(format:str,val:lng):int = CMDprint_lng;
command printf(format:str,val:flt):int = CMDprint_flt;
command printf(format:str,val:dbl):int = CMDprint_dbl;
command printf(val:str):int = CMDprint_str;
command printf(format:str,val:str):int = CMDprint_formatted_str;

pattern print(val:any):int = CMDprint_val
comment "Print a MIL value between square brackets.";

@mil
LOAD


    # self help 
    ADDHELP("help", "boncz", "Feb  6 1996",
         "provide help for a MIL construct.", "sys");

    PROC col_name(bat[any::1,any::2] b, str name) : bat[any::1,any::2] := {
	b.bbpname(name);
	return b;
    }
    PROC rename(bat[any::1,any::2] b, str name) : bat[any::1,any::2] := {
	if (not(b.bbpname(name))) 
		ERROR("rename(%s,%s): operation failed", str(b), name);
	return b;
    }
    ADDHELP("rename", "boncz", "Feb  6 1996",
         "try to name a BAT and fail if it is not possible.", "sys");

    PROC modules() : void := {
	var b := view_modules.reverse.kunique.reverse;
	table(1,[module_name](b).reverse.sort.reverse.col_name("name"), 
		[module_db](b).col_name("database"));
	
    }
    ADDHELP("modules", "boncz", "Aug 14 1997",
	"list all installed modules", "sys"); 

    PROC loaded() : void := table(1,monet_mod_nme.reverse.sort.reverse.col_name("module"));
    ADDHELP("loaded", "boncz", "Feb  6 1996", 
	"list all loaded modules, and the number of active users.", "sys"); 

    PROC sigs(str modname) : void := {
	if (monet_mod_nme.reverse.exist(modname)) {
	    var o := monet_mod_nme.reverse.find(modname);
	    #var b := [format_fcn_sig](monet_fcn_mid.uselect(o).reverse);
	    #table(1,b.reverse.sort.reverse.col_name("signature"));
	} else if ([module_name](view_modules).reverse.exist(modname)) {
  	    ERROR("sigs: must load module first.\n");
	} else {
  	    ERROR("sigs: module does not exist.\n");
	}
    }
    ADDHELP("sigs", "boncz", "Aug  2 1996",  
	"Show all signatures of the functions in a module.", "sys");

    proc dir(bat[int,str] b) {
        var nme := view_bbp_name;
	var atm := adm_atomtbl.copy.access(BAT_WRITE).delete("BAT"); #doubly present
	
	table(1, b.reverse.sort.reverse.col_name("name"),
		[htype](b.join(nme.reverse)).outerjoin(atm.reverse).col_name("htype"),	
		[ttype](b.join(nme.reverse)).outerjoin(atm.reverse).col_name("ttype"),	
		[count](b.mirror).col_name("count"),	
		view_bbp_heat.col_name("heat"),
		view_bbp_dirty.col_name("dirty"),
		view_bbp_status.col_name("status"),
		view_bbp_kind.col_name("kind"), 
		view_bbp_refcnt.col_name("refcnt"));
    }

    PROC dir() : void := {
        var nme := view_bbp_name.copy.access(BAT_WRITE).col_name("name");
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(nme.replace(rev));
    }
    PROC dir(str substr) : void := {
        var nme := view_bbp_name.like(substr).access(BAT_WRITE).col_name("name");
        var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
        dir(nme.replace(rev));
    }
    ADDHELP("dir", "boncz", "Feb  6 1996", 
	"list all bats, including system bats. Optionally filter on name with a certain substring", "sys"); 

    proc dir_leaks() {
	var b0 := view_bbp_name.access(BAT_WRITE);
	b0.replace([*](b0.reverse.select(int(nil),-1),-1).reverse);
        var b1 := [[startsWith](b0,"tmp_")?b0:].access(BAT_WRITE);
        var b2 := like(view_var_value, "tmp_");
        var b3 := bat(int,str,b1.count);
        b1.delete(int(b0));
        b1@batloop() { 
            var pat := "tmp_" + $h;
            if (like(b2,pat).count = 0) b3.insert($h,$t);
        }
        dir(b3);
    }

    PROC ls() : void := {
	var nme := view_bbp_name;
	var prs := nme.semijoin(view_bbp_kind.select("pers"));
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(prs.access(BAT_WRITE).col_name("name").replace(rev));
    }
    PROC ls(str substr) : void := {
        var nme := view_bbp_name.like(substr);
	var prs := nme.semijoin(view_bbp_kind.select("pers"));
	var rev := [*](nme.reverse.select(int(nil),-1),-1).reverse;
	dir(prs.access(BAT_WRITE).col_name("name").replace(rev));
    }
    ADDHELP("ls", "boncz", "Feb  6 1996", 
	"list all data bats. Optionally filter on name with a certain substring", "sys"); 

    PROC exit() : void := {
	quit;
    }
    ADDHELP("exit", "boncz", "Jan 9 1998", "quit for consultants", "sys"); 

    PROC procs() : void := {
	print("To be implemented")
    }
    ADDHELP("procs", "boncz", "Feb  6 1996", "list all defined procs.", "sys"); 

    PROC clients() : void :=  { 
	var tree := view_client_tree.access(BAT_WRITE);
	tree.replace(clientid, "clients()");
	table(view_client_name,view_client_login,tree.col_name("mil"));
    } 
    ADDHELP("clients", "boncz", "Feb  6 1996", 
	"list all active clients by their number.", "sys"); 

    PROC vars() : void := 
	print(view_var_type, view_var_kind, view_var_constant, view_var_value);
    ADDHELP("vars", "boncz", "Feb  6 1996", 
        	"list all Monet variables and their values.", "sys"); 

    PROC threads() : void := print(view_gdk_thread); 
    ADDHELP("threads", "boncz", "Feb  6 1996", 
		"list all system threads and their function.", "sys"); 

    PROC env() : void := print(view_gdk_env);
    ADDHELP("env", "boncz", "Feb  6 1996", 
		"list the values of all environment variables", "sys"); 

    PROC environment() : bat[str,str] := return view_gdk_env;
    ADDHELP("environment", "boncz", "Mar 22 1998", "deprecated", "sys");

    PROC cpu() : bat[str,int] := RETURN view_gdk_cpu;
    ADDHELP("cpu", "boncz", "Mar 22 1998", "Global cpu usage info", "sys");

    PROC memory() : bat[str,int] := RETURN view_gdk_memory;
    ADDHELP("memory", "boncz", "Mar 22 1998", "Global memory usage info","sys");

    PROC io() : bat[str,int] := RETURN view_gdk_io;
    ADDHELP("io", "boncz", "Mar 22 1998", "Global IO activity info", "sys");

    PROC bbp() : bat[str,int] := RETURN view_gdk_bbp;
    ADDHELP("bbp", "boncz", "Mar 22 1998", "Global BBP usage info", "sys");

    PROC tail(bat[any,any] b) : int := 
         return adm_atomtbl.reverse.find(b.ttype);
    ADDHELP("tail","boncz","Mar 22 1998","Get tail-type as an int","sys");

    PROC head(bat[any,any] b) : int:= 
         return adm_atomtbl.reverse.find(b.htype);
    ADDHELP("head","boncz","Mar 22 1998","Get head-type as an int","sys");

    PROC readonly( bat[any::1,any::2] b, int mode) : bat[any::1,any::2]
        := return access(b,mode);
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'b.access' instead.", "sys");
 
    PROC readonly( bat[any::1,any::2] b) : int := {
        var s := b.info.find("batRestricted");
        if (s = "updatable") {
                return BAT_WRITE;
        } else if (s = "read-only") {
                return BAT_READ;
        } else if (s = "append-only") {
                return BAT_APPEND;
        } 
        ERROR("readonly: unknown mode.");
    }
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'info.find(batRestricted)' instead.", "sys");

    PROC mem_usage() : bat[str,lng] return mem_usage(lng(100000));
    PROC vm_usage() : bat[str,lng] return vm_usage(lng(100000));
    PROC mem_usage(int minsize) : bat[str,lng] return mem_usage(lng(minsize));
    PROC vm_usage(int minsize) : bat[str,lng] return vm_usage(lng(minsize));

END;

@{
@* Implementation Code
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 *		   Peter Boncz <Peter.Boncz@cwi.nl>
 *		   Niels Nes <Niels.Nes@cwi.nl>
 *		   Stefan Manegold  <Stefan.Manegold@cwi.nl>
 */

#ifndef _SYS_H_
#define _SYS_H_
#endif
@c
#include <stdarg.h>
#include <time.h>
#include "gdk.h"
#include "mal_stack.h"
#include "mal_resolve.h"
#include "mal_squeezer.h"
#include "mal_client.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
 
#define PARAM(x)        (argv+x)
#define RETVAL          (argv)

static char* local_itoa(int i){
        static char buf[32];
        sprintf(buf,"%d",i);
        return buf;
}

@+ BBP status
The BAT buffer pool datastructures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection. 

The most interesting sysbat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
@= Pseudo
	if (BBPindex("view_@1_@2") <= 0)
        	BATname(b, "@2");
        BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;
	
@c
int
view_bbp_name( int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_name");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i)) { 
			BUNins(b, &i, BBP_logical(i));
        		if (BBP_logical(-i)) {
				int j = -i;
				BUNins(b, &j, BBP_logical(j));
			}
		}
	}
	BBPunlock("view_bbp_name");
	@:Pseudo(bbp,name)@
        return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int
view_bbp_location(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_location");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        	if (BBP_logical(i))
                BUNins(b, &i, BBP_physical(i));
	}
	BBPunlock("view_bbp_location");
	@:Pseudo(bbp,location)@
        return GDK_SUCCEED;
}


#define monet_modulesilent (GDKdebug&4096)

int view_bbp_heat(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_heat");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
            if (BBP_cache(i) && !monet_modulesilent) {
		int heat = BBPheat(i);
                BUNins(b, &i, &heat);
	    } else if (BBP_logical(i)) { 
		int zero = 0;
                BUNins(b, &i, &zero);
	    }
	}
	BBPunlock("view_bbp_heat");
	@:Pseudo(bbp,heat)@
        return GDK_SUCCEED;
}

@-
The BAT dirty status: dirty => (mem != disk); diffs = not-committed
@c
int view_bbp_dirty(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_dirty");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		BAT *bn = BBP_cache(i);
                BUNins(b, &i, bn?
				BATdirty(bn)?
					"dirty":
					DELTAdirty(bn)?
						"diffs":
						"clean":
				(BBP_status(i)&BBPSWAPPED)?
					"diffs": 
					"clean");
	}}
	BBPunlock("view_bbp_dirty");
	@:Pseudo(bbp,status)@
        return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int view_bbp_status(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_status");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
        if (BBP_logical(i)){
		char *loc = BBP_cache(i)?"load":"disk";
                BUNins(b, &i,loc );
	}}
	BBPunlock("view_bbp_status");
	@:Pseudo(bbp,status)@
        return GDK_SUCCEED;
}

int view_bbp_kind(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_kind");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
	    char *mode = NULL;
	    if ((BBP_status(i)&BBPDELETED) || !(BBP_status(i)&BBPPERSISTENT)) {
		mode = "tran";
	    } else {
		mode = "pers";
	    }
	    if (mode) BUNins(b, &i, mode);
	}}
	BBPunlock("view_bbp_kind");
	@:Pseudo(bbp,kind)@
        return GDK_SUCCEED;
}

int view_bbp_refcnt(int *ret){       
	BAT	 *b;
        int     i;

        b= BATnew(TYPE_int,TYPE_int,BBPsize);
        if (b == 0) return GDK_FAIL;

	BBPlock("view_bbp_refcnt");
        for(i=1; i < BBPsize; i++) if (i != b->batCacheid) {
	if (BBP_logical(i)) {
		int refs = BBP_refs(i);
		BUNins(b, &i, &refs);
	}}
	BBPunlock("view_bbp_refcnt");
	@:Pseudo(bbp,group)@
        return GDK_SUCCEED;
}

@+ GDK
The old-fashioned BATdump command is replaced by the sys.
@c
int view_gdk_thread(int *ret){       
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,THREADS);
        if (b == 0) return GDK_FAIL;

        for(i=0; i < THREADS; i++)
	if( GDKthreads[i].pid) {
                BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name);
	}
	@:Pseudo(gdk,thread)@
        return GDK_SUCCEED;
}

int view_gdk_env(int *ret){
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
	char prefix[128];
	if (b == 0) return GDK_FAIL;
	if( GDKdbfarmStr[0])
		BUNins(b, "gdk_dbfarm", GDKdbfarmStr);
	if( GDKdbnameStr[0])
		BUNins(b, "gdk_dbname", GDKdbnameStr);
	if( GDKdirStr[0])
		BUNins(b, "gdk_dbdir", GDKdirStr);
	if( GDKdistrStr[0])
		BUNins(b, "gdk_distr", GDKdistrStr);
        sprintf(prefix, "%dbit%s", sizeof(ptr)*8, GDKarchStr);
	if(GDKversionStr[0])
		BUNins(b, "gdk_version", GDKversionStr);
	if( GDKmonetrcStr[0])
		BUNins(b, "gdk_monetrc", GDKmonetrcStr); 
	BUNins(b, "gdk_processid", local_itoa(getpid()));
	@:Pseudo(gdk,env)@
	return GDK_SUCCEED;
}

int check_bbp_size(lng *ret) {
	*ret = BBPdiskscan(NULL);
	return GDK_SUCCEED;
}

@+ Monet sys variables
The Monet system variables are depreciated. They may be revived for Mal though.
@c
int
view_client_name(int *retval){       

	return GDK_FAIL;
}
int view_client_login(int *retval){       
	return GDK_FAIL;
}

int view_client_tree(int *retval){
	return GDK_FAIL;
}

@+ Variables
The variable information can be turned into a BAT for inspection as well.

@+ Modules
@c
static char any_str[] = "any";

int view_modules(int *res){
	return GDK_SUCCEED;
}

int get_mod_name(str* res, str src){
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');
	if (s) *s = 0;	
	*res = entry;
	return GDK_SUCCEED;	
}

int get_mod_db(str *res, str src){
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');
	if (s == NULL) {
		s = any_str;
	}
	*res = GDKstrdup(s);
	GDKfree(entry);
	return GDK_SUCCEED;	
}


@- Performance
To obtain a good impression of the Monet performance we need timing information.
The most detailed information is best obtained with the system profiler.
 
However, the direct approach is to enable the user to read the timers maintained
internally. This is done with the CPU, IO, MEMORY, and BBP command which 
displays the elapsed time in seconds, user- and system-cpu time in milliseconds
since its last invocation and the amount of space in use.  The process 
identifier is used to differentiate among the possible processes.
 
Note that in multi threaded mode the routine prints the elapsed
time since the beginning of each process.
@{
@c
static int clk = 0;
static struct tms state;

int view_gdk_cpu(int *ret) {
	int     i;
	struct tms newst;
	BAT *b;
 
 
	b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return GDK_FAIL;
	if( clk == 0) {
		clk= time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = time(0) - clk;
	b = BUNins(b, "elapsed", &i);
	i= newst.tms_utime *1000/HZ ;
	b = BUNins(b, "user", &i);
	i= (newst.tms_utime - state.tms_utime)*1000/HZ;
	b = BUNins(b, "elapuser", &i);
	i = newst.tms_stime *1000/HZ;
	b = BUNins(b, "system", &i);
	i = (newst.tms_stime - state.tms_stime)*1000/HZ;
	b = BUNins(b, "elapsystem", &i);

	state = newst; 
	@:Pseudo(gdk,cpu)@
	return GDK_SUCCEED;
}
@-
Same observations as to view_gdk_cpu()
@c
static void *memincr=NULL;
int view_gdk_mem(int *ret) {
	struct mallinfo m;
	BAT *b;
	int i;
	m = MT_mallinfo();
 
	b = BATnew(TYPE_str, TYPE_int, 32);
	if ( b == 0) return GDK_FAIL;

	/* store counters, ignore errors */
	if (memincr == NULL) {
		memincr = GDK_mem_start;
	}
	i= ((char*) sbrk(0) -  (char*) memincr);
 
	memincr = (char*) sbrk(0);
	b = BUNins(b, "memincr", &i);
	b = BUNins(b, "arena", &m.arena);
	b = BUNins(b, "ordblks", &m.ordblks);
	b = BUNins(b, "smblks", &m.smblks);
	b = BUNins(b, "hblkhd", &m.hblkhd);
	b = BUNins(b, "hblks", &m.hblks);
	b = BUNins(b, "usmblks", &m.usmblks);
	b = BUNins(b, "fsmblks", &m.fsmblks);
	b = BUNins(b, "uordblks", &m.uordblks);
	b = BUNins(b, "fordblks", &m.fordblks);
	@:Pseudo(gdk,mem)@
	return GDK_SUCCEED;
}

int get_mem_cursize(lng *num) {
	*num = GDKmem_cursize();
	return GDK_SUCCEED;
}
int get_mem_maxsize(lng *num) {
	*num = GDKmem_maxsize();
	return GDK_SUCCEED;
}
int set_mem_maxsize(lng *num) {
	GDK_mem_maxsize = *num;
	return GDK_SUCCEED;
}
int get_vm_cursize(lng *num) {
	*num = GDKvm_cursize();
	return GDK_SUCCEED;
}
int get_vm_maxsize(lng *num) {
	*num = GDKvm_maxsize();
	return GDK_SUCCEED;
}
int set_vm_maxsize(lng *num) {
	GDK_vm_maxsize = *num;
	return GDK_SUCCEED;
}

@= heap
sz = HEAP@1size(@2);
if (sz > *minsize) {
	sprintf(buf, "@3/%s", s); 
	BUNins(bn, buf, &sz);
} @3 += sz; tot += sz;
@c

int get_mem_usage(int *ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, n=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	int i;

	BBPlock("get_mem_usage");
	for(i=1; i <BBPsize; i++) { 
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL) {
			continue;
		}
		sz = 0;
		if (BBP[i].cache)  sz += sizeof(BATstore);
		if (BBP[i].nme[0]) n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1]) n += strLen(BBP[i].nme[1]);
		if (BBP[i].path) n += strLen(BBP[i].path);
		if (b) sz += sizeof(BAT); /* mirror */
			
		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s); 
			BUNins(bn, buf, &sz);
		} tot += (lng) sz;

		if (b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(mem,b->batBuns,buns)@
		@:heap(mem,b->hhash_heap,hhsh)@
		@:heap(mem,b->thash_heap,thsh)@
		@:heap(mem,b->hidx_heap,hind)@
		@:heap(mem,b->tidx_heap,tind)@
		@:heap(mem,&b->hheap,head)@
		@:heap(mem,&b->theap,tail)@
		@:heap(mem,&b->haccelerator,hacc)@
		@:heap(mem,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPlimit*sizeof(BBPrec) + n;
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

/* special area 2: monet context records 
	DEPRICATED
	sz = monet_cntxtmax*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
*/
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);
	sz = GDKmem_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &sz);
/*	compilation errors !
	if (GDK_mem_cursize) BUNins(bn, "_tot/valloc", &GDK_mem_cursize);

*/
	sz = GDKmem_heapinuse();
	if (sz) BUNins(bn, "_tot/malloc", &sz);
	sz = sz + GDK_mem_cursize - tot;
	if (sz) BUNins(bn, "_tot/malloc_unknown", &sz);
	sz = GDKmem_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	BBPunlock("get_mem_usage");

	*ret = bn->batCacheid;
	return GDK_SUCCEED;
}

int get_vm_usage(int *ret, lng *minsize) {
	lng buns=0, hhsh=0, thsh=0, hind=0, tind=0, head=0, tail=0, hacc=0, tacc=0, tot=0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2*BBPsize);
	char buf[1024];
	int i;

	BBPlock("get_vm_usage");
	for(i=1; i <BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s = BBP_logical(i);
		if (s == NULL || b == NULL || VIEWparent(b)) {
			continue;
		}
		@:heap(vm,b->batBuns,buns)@
		@:heap(vm,b->hhash_heap,hhsh)@
		@:heap(vm,b->thash_heap,thsh)@
		@:heap(vm,b->hidx_heap,hind)@
		@:heap(vm,b->tidx_heap,tind)@
		@:heap(vm,&b->hheap,head)@
		@:heap(vm,&b->theap,tail)@
		@:heap(vm,&b->haccelerator,hacc)@
		@:heap(vm,&b->taccelerator,tacc)@
	} 
	/* totals per category */
	if (buns) BUNins(bn, "_tot/buns", &buns);
	if (head) BUNins(bn, "_tot/head", &head);
	if (tail) BUNins(bn, "_tot/tail", &tail);
	if (hhsh) BUNins(bn, "_tot/hhsh", &hhsh);
	if (thsh) BUNins(bn, "_tot/thsh", &thsh);
	if (hind) BUNins(bn, "_tot/hind", &hind);
	if (tind) BUNins(bn, "_tot/tind", &tind);
	if (hacc) BUNins(bn, "_tot/hacc", &hacc);
	if (tacc) BUNins(bn, "_tot/tacc", &tacc);

	/* special area 1: BBP rec */
	sz = BBPmaxsize*sizeof(BBPrec);
	if (sz) BUNins(bn, "_tot/bbp", &sz);
	tot += sz;

	/* special area 2: monet context records  DEPRICATE
	sz = monet_cntxtlim*sizeof(CntxtRec);
	if (sz) BUNins(bn, "_tot/mil", &sz);
	tot += sz;
	if (tot) BUNins(bn, "_tot/found", &tot);
	*/

	/* look at sbkr() to determine how much we missed */
	sz = GDKvm_cursize();
	if (sz) BUNins(bn, "_tot/all", &sz);
	sz -= tot;
	tot = GDKvm_heapsize();
	if (sz) BUNins(bn, "_tot/sbrk", &tot);
	BBPunlock("get_vm_usage");

	*ret = bn->batCacheid;
	return GDK_SUCCEED;
}

@-
Additional information on the process utilization is given by
the io command. The following information is obtained.
 
@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\
 
	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)
 
The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif
 
int view_gdk_io(int *ret) {
	struct rusage ru;
	int i;
	BAT *b;
 
	getrusage(RUSAGE_SELF, &ru);
	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return GDK_FAIL;
 
	/* store counters, ignore errors */
	i = ru.ru_maxrss; BUNins(b, "maxrss", &i); 
	i = ru.ru_minflt; BUNins(b, "minflt", &i);
	i = ru.ru_majflt; BUNins(b, "majflt", &i);
	i = ru.ru_nswap; BUNins(b, "nswap", &i);
	i = ru.ru_inblock; BUNins(b, "inblock", &i);
	i = ru.ru_oublock; BUNins(b, "oublock", &i);
	i = ru.ru_nvcsw; BUNins(b, "nvcsw", &i);
	i = ru.ru_nivcsw; BUNins(b, "ninvcsw", &i);

	@:Pseudo(gdk,io)@
	return GDK_SUCCEED;
}

int view_gdk_bbp(int *ret) {
	int 	pbat = 0;
	int	pdisk = 0;
	int	pheat = 0; 
	int	i,tmp=0,per=0; 
	BAT	*b;

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0) return GDK_FAIL;

	for (i = 1; i < BBPsize; i++) {
		if (BBP_logical(i)) {
			pbat++; 
			if (BBP_cache(i)) {
				pheat += BBPheat(i); 
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else tmp++;
			} else {
				pdisk++; 
			}
		}
	}
	b = BUNins(b, "bats", &pbat);
	b = BUNins(b, "tmpbats", &tmp);
	b = BUNins(b, "perbats", &per);
	b = BUNins(b, "ondisk", &pdisk);
	b = BUNins(b, "todisk", &BBPout);
	b = BUNins(b, "fromdisk", &BBPin);

	@:Pseudo(gdk,bbp)@
	return GDK_SUCCEED;
}

@+ Printing
The print commands are implemented as single instruction rules,
because they need access to the calling context.
Check string printing first !!
@c
int CMDprint_val(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int tpe = getArgType(mb,pci,1);
	ptr val = getArgReference(mb,stk,pci,1);
        FILE *fp = GDKout;
	if( val==NULL) {
		tpe = TYPE_str;
		val = (ptr) "<null>";
	}
	if( isBatType(tpe)){
		BAT *b = BATdescriptor(*(int*)val);
		if( b== NULL) {
			GDKerror("CMDprint_val:could not access descriptor\n");
			return GDK_FAIL;
		}
		BATprint(b);
		return GDK_SUCCEED;
	}
        fputs("[ ", fp);
	if( tpe== TYPE_str)
		ATOMprint(tpe, *(str*)val, fp);
        else  	ATOMprint(tpe, val, fp);
        fputs(" ]\n", fp);
        return GDK_SUCCEED;
}

int CMDprint_otable( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i,order=0;
	ptr val;

	order = *(int*) getArgReference(mb,stk,pci,1);
	for(i=2; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = getArgReference(mb,stk,pci,i);
		if( !isBatType(tpe)) return GDK_FAIL;
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return GDK_FAIL;
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, nbats, piv, TRUE, order);
        return GDK_SUCCEED;
}

int CMDprint_table( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i;
	ptr val;

	for(i=1; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = getArgReference(mb,stk,pci,i);
		if( !isBatType(tpe)) return GDK_FAIL;
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return GDK_FAIL;
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, nbats, piv, FALSE, 0);
        return GDK_SUCCEED;
}

@-
The format string is scrutinized using VALsprintf in the GDK library
to avoid that passing a wrong argument (e.g. NULL pointer) kills the server.
The generic printf function is rather expensive. Ideally it should be
replaced by a squeezer into a type-specific function calls.
@-
Formatted print statements are to be broken down into its constituents.
This avoids repeated type checking in most cases.
@c
int CMDprint_str(int *ret, str *s){
	FILE *fd = getClient()->fdout;
	str c;
	if( strNil(*s)) *ret = fputs("nil",fd);
	else {
		for(c= *s;*c; c++){
			if( *c=='\\'){
				c++;
				switch(*c){
				case 'n': *ret =  fputc('\n',fd);break;
				case 't': *ret =  fputc('\t',fd);break;
				case 'r': *ret =  fputc('\r',fd);break;
				case '\\': *ret =  fputc('\\',fd);break;
				default : *ret = fputc('\\',fd);fputc(*c,fd);
				}
			} else *ret = fputc(*c,fd);
		}
	}
	return GDK_SUCCEED;
}
int CMDprint_formatted_str(int *ret, ptr fmt, str *s){
	FILE *fd = getClient()->fdout;
	char *format;
	str c;
	/* TODO: check format properly !!! */
	format= *(str *)fmt;
	if( format== NULL) return GDK_FAIL;
	if( strchr(format,'%') == NULL) return GDK_FAIL;

	if( strNil(*s)) *ret = fputs("nil",fd);
	else {
		for(c= format;*c; c++){
			if( *c=='\\'){
				c++;
				switch(*c){
				case 'n': *ret =  fputc('\n',fd);break;
				case 't': *ret =  fputc('\t',fd);break;
				case 'r': *ret =  fputc('\r',fd);break;
				case '\\': *ret =  fputc('\\',fd);break;
				default : *ret = fputc('\\',fd);fputc(*c,fd);
				}
			} else 
			if( *c== '%'){
				c++;
				if(*c!= 's') 
				GDKerror("ERROR: printf format limitation\n");
				else  fputs(*s,fd);
			} else *ret = fputc(*c,fd);
		}
	}
	return GDK_SUCCEED;
}
int CMDprint_oid(int *ret, ptr fmt, oid *s){
	FILE *fd = getClient()->fdout;
	char *format; /* "%@2";*/
	/* TODO: check format properly !!! */
	format= *(str *)fmt;
	if( format== NULL) return GDK_FAIL;
	if( strchr(format,'%') == NULL) return GDK_FAIL;

	if( *s == oid_nil) *ret = fputs("nil",fd);
	else *ret= ATOMprint(TYPE_oid,s,fd);
	return (*ret==EOF? GDK_FAIL:GDK_SUCCEED);
}
int CMDprint_bit(int *ret, ptr fmt, bit *s){
	FILE *fd = getClient()->fdout;
	char *format; /* "%@2";*/
	/* TODO: check format properly !!! */
	format= *(str *)fmt;
	if( format== NULL) return GDK_FAIL;
	if( strchr(format,'%') == NULL) return GDK_FAIL;

	if( *s == bit_nil) *ret = fputs("nil",fd);
	else 
	if( *s ) fprintf(fd,format,"true");
	else 	fprintf(fd,format,"false");

	/* *ret= ATOMprint(TYPE_bit,s,getClient()->fdout);*/
	return (*ret==EOF? GDK_FAIL:GDK_SUCCEED);
}

@-
The formatted print routines permit just a single
format and argument. This to simplify the analysis.
The format type conformance should be implemented.

@= printType
int CMDprint_@1(int *ret, ptr fmt, @1 *v){
	FILE *fd = getClient()->fdout;
	char *format; /* "%@2";*/
	/* TODO: check format properly !!! */
	format= *(str *)fmt;
	if( format== NULL) return GDK_FAIL;
	if( strchr(format,'%') == NULL) return GDK_FAIL;

	if( *v == @1_nil) *ret = fputs("nil",fd);
	else *ret= fprintf(fd,format,*v);
	return (*ret==EOF? GDK_FAIL:GDK_SUCCEED);
}

@c
 	@:printType(chr,c)@
 	@:printType(sht,d)@
 	@:printType(int,d)@
 	@:printType(lng,d)@
 	@:printType(flt,f)@
 	@:printType(dbl,f)@

int CMDprint_table_default( MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
        BAT *piv[MAXPARAMS],*b;
        int nbats = 0;
	int tpe,i;
	ptr val;

	for(i=1; i< pci->argc;i++) {
		tpe = getArgType(mb,pci,i);
		val = getArgReference(mb,stk,pci,i);
		if( !isBatType(tpe)) return GDK_FAIL;
		b= BATdescriptor(*(int*)val);
		if(b == NULL) return GDK_FAIL;
                piv[nbats++] = b;
        } 
        BATmultiprintf(GDKout, i-1, piv, FALSE, 0);
        return GDK_SUCCEED;
}

int format_fcn_sig(str *sig, oid *fid){
	return GDK_FAIL;
}

int print_mem_map() {
        MT_alloc_print();
        return GDK_SUCCEED;
}
@-
If we don;t have an implementation at hand, we simple generate
an error message.
@c
int tobedefined(){
	GDKerror("ERROR:function not (yet) implemented\n");
	return GDK_FAIL;
}

@
@}
