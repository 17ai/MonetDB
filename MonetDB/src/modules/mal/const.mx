@f const
@t MAL constant management
@a Martin Kersten
@v 0.1
@* Constant space management

This module shows the behavior of a simple box of objects.
Objects are stored into the box using deposit() and taken
out with take(). Once you are done, elements can be
removed by name or reference using discard().

A box should be opened before being used. It is typically used
to set-up the list of current users and to perform authorization.

The default constant box is initialized with session values,
such as 'user','dbname', 'dbfarm', and 'dbdir'. These actions
are encapsulated in the prelude routine called.

Furthermore, it implements a simple authorization scheme, 
prohibiting all updates unless issued by the system administrator.
@mal
module const;

pattern open():nil= CONSTopen
comment "Locate the constant box and open it";

pattern close():nil= CONSTclose
comment "Close the constant box ";

pattern destroy():nil= CONSTdestroy
comment "Destroy the box";

pattern take(name:str):any = CONSTtake
comment "Locates the typed value in the constant box";

pattern deposit(name:str,v:any):nil = CONSTdeposit
comment "Enter a new value into the constant box";

pattern releaseAll():nil = CONSTreleaseAll
comment "Release all constants for this client";

pattern release(name:str,val:any):nil = CONSTrelease
comment "Release a new constant value";

pattern release(name:str):nil = CONSTrelease
comment "Release a new constant value";

pattern toString(name:str):str = CONSTtoString
comment "Get the string representation of an element in the box";

pattern discard(name:str):nil = CONSTdiscard
comment "Release the const from the box";

pattern iterator(nme:str):lng = CONSTiterator
comment "Locates the next element in the constant box";

pattern prelude():nil = CONSTprelude
comment "Initialize the const box";

const.prelude();
@-
@+ Implementation
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	if( !isAuthorized("Admin"))
		return throwMessage(":unauthorized access to 'const' box");
@c
#include "const.h"
#include "mal.h"
#include "mal_client.h"

int isAuthorized(str nme){
	Client c;
	if( nme == 0) return 1;
	c= getClient();
	return idcmp(c->user,nme)==0;
}
str CONSTprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	ValRecord vr;
	@:authorize@
	box= openBox("const");
	if( box== 0) 
		return throwMessage("CONSTprelude:failed to open box");
	/* if the box was already filled we can skip initialization */
	if( box->sym->vtop == 0){
		insertToBox(box,"user",getClient()->user);
		insertToBox(box,"database",GDKdbnameStr);
		insertToBox(box,"dbfarm",GDKdirStr);
		insertToBox(box,"distribution",GDKdistrStr);
		insertToBox(box,"monetrc",GDKmonetrcStr);
		insertToBox(box,"architecture",GDKarchStr);
		insertToBox(box,"version",GDKversionStr);
		insertToBox(box,"environment","unknown yet");
	}
	return MAL_SUCCEED;
}
@- Operator implementation
@c
str CONSTopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:authorize@
	if(openBox("const") != 0) return MAL_SUCCEED;
	return throwMessage("CONSTopen:failed to open box");
}

str CONSTclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	@:authorize@
	if( closeBox("const",TRUE) ==0) return MAL_SUCCEED;
	return throwMessage("CONSTclose:failed to close box");
}
str CONSTdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	@:OpenBox(CONSTdestroy)@
	destroyBox("const");
	return MAL_SUCCEED;
}
@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	@:authorize@
	box= findBox("const");
	if( box ==0) 
	return throwMessage("@1:box is not open");
@-
@c
str CONSTdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	ValPtr v;
	Box box;

	@:OpenBox(CONSTdeposit)@
	name = (str) getArgValue(stk,pci,1);
	v = &stk->stk[pci->argv[2]];
	if(depositBox(box,name,v) )
		return throwException("CONSTdeposit:%s:failed to deposit box",name);
	return MAL_SUCCEED;
}

str CONSTtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;
	ValPtr v;

	@:OpenBox(CONSTtake)@
	name = (str) getArgValue(stk,pci,1);
	v = &stk->stk[pci->argv[0]];
	if(takeBox(box,name,v)) 
		return throwException("CONSTtake:%s:failed to take from box",name);
	return MAL_SUCCEED;
}

str CONSTrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(CONSTrelease)@
        name = (str) getArgValue(stk,pci,1);
        releaseBox(box,name);
	return MAL_SUCCEED;
}

str CONSTreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;

	@:OpenBox(CONSTrelease)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str CONSTdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str name;
	Box box;

	@:OpenBox(CONSTdiscard)@
        name = (str) getArgValue(stk,pci,1);
        if( discardBox(box,name) == 0)
                return throwException("CONSTdiscard: failed to discard '%s'", name);
	return MAL_SUCCEED;
}
str CONSTtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	int i,len=0;
	ValPtr v;
	str nme,s=0;

	@:OpenBox(CONSTtoString)@
	nme = (str) getArgValue(stk,pci,1);
	i= findVariable(box->sym,nme);
	if( i <0) return throwException("CONSTtostring:%s:failed to take",nme);

	v= &box->val->stk[i];
	garbageElement(&stk->stk[pci->argv[0]]);

	if( v->vtype== TYPE_str) s= v->val.sval;
	else (*BATatoms[v->vtype].atomToStr)(&s,&len,v);
	if(s== NULL) return throwMessage("CONSTtoString:illegal value");
	VALset(&stk->stk[pci->argv[0]], TYPE_str,s);

	/* if( VALconvert(TYPE_str,v, TRUE) == ILLEGALVALUE) 
		return throwMessage("CONSTtoString:illegal value");
	VALcopy(&stk->stk[pci->argv[0]], v); */
	return MAL_SUCCEED;
}

str CONSTiterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	Box box;
	lng *cursor;
	ValPtr v;

	@:OpenBox(CONSTiterator)@
	cursor= (lng*) getArgValue(stk,pci,0);
	v= &stk->stk[pci->argv[1]];
	nextBoxElement(box, cursor, v);
	return MAL_SUCCEED;
}
