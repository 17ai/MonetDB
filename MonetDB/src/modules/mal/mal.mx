@t MAL extensions
@a Martin Kersten
@v 0.1
@* MAL extensions
This module contains enhances to the MAL interpreter layer, such as
iterators over ranges and bats, object management, access to the debugger, ....
This module is loaded directly after the kernel modules and provides
a first abstraction layer.

@+ Exception handling
The exception handler works through a string-returning pattern
@mal
# The routines below are linked with the kernel by default

module mal;

command raise(msg:str) :str = CMDraise
comment "Raise an exception labelled with a specific message.";
@+ Iterator primitives
This module contains the framework for the construction of iterators.
Iterators enumerate elements in a collection defined by a few paramaters,
e.g. a lower/upper bound, or a bat. An iterator is initialized in the first
call by recognizing that the control variable lies outside the intended
collection.

@mal

command nextElement(i:flt, first:flt, last:flt, step:flt):bit = fltForloopStep; 
command nextElement(i:dbl, first:dbl, last:dbl, step:dbl):bit = dblForloopStep; 
command nextElement(i:chr, first:chr, last:chr, step:chr):bit = chrForloopStep; 
command nextElement(i:sht, first:sht, last:sht, step:sht):bit = shtForloopStep; 
command nextElement(i:lng, first:lng, last:lng, step:lng):bit = lngForloopStep; 
command nextElement(i:int, first:int, last:int, step:int):bit = intForloopStep; 

command nextElement(i:chr, first:chr, last:chr):bit = chrForloop; 
command nextElement(i:sht, first:sht, last:sht):bit = shtForloop; 
command nextElement(i:lng, first:lng, last:lng):bit = lngForloop; 
command nextElement(i:int, first:int, last:int):bit = intForloop; 
@+ BAT iterator
A BATloop iterator uses an integer cursor to keep track of its
position in the underlying table. 
The head and tail elements can be obtained using the getHead and 
getTail functions, which are to be defined for all atomary types.
@mal
command batloop(i:int,b:bat[any,any]):bit = CMDnextElement_int
comment "Iterate over the elements of a BAT using a cursor.";

pattern batloop(i:int,b:bat[any::1,any::2],h:any::1,t:any::2):bit 
	= CMDnextElement
comment "Iterate over the elements of a BAT using a cursor.";

command batslice(i:int,b:bat[any,any],low:int,high:int):bit = CMDnextSlice
comment "Iterator over all BUNs of b.slice(low,high)";

command hashloop(i:int, p:ptr, b:bat[any,any]):bit = CMDhashloop
comment "Iterate over the elements of a BAT using its hash index.
Each call we set 'i' to denote the next element";
@-
The head and tail values can be extracted using the cursor,
but is often more effective due to overhead involved in
location of the underlying BAT.
The generic solutions are also provided as patterns, because this
trims the number of function signatures in the symbol table.
@mal
pattern getHead(i:int, b:bat[any::1,any]):any::1 = CMDgetHead
comment "return the BUN head value using the cursor.";

pattern getTail(i:int, b:bat[any,any::1]):any::1 = CMDgetTail
comment "return the BUN tail value using the cursor.";

@-
@+ The Monet Debugger interface
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
@mal
pattern mdb():void = MDBmdb
	comment "Start interactive debugger";

@+ Dummy code 
@h
/*
 * The contents of this file are subject to the Monet Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at 
 * http://www.monetsolutions.com/Download/Licensing/MonetPL-1.1.html
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is the Monet Database System.
 * 
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-2001 CWI.  
 * All Rights Reserved.
 * 
 * Contributor(s): Martin Kersten <Martin.Kersten@cwi.nl>
 */
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H*/
@c
#include "monet.h"

@+ Exception implementation
@c
int CMDraise(str *ret,  str *msg){
	*ret= GDKstrdup(*msg);
	return (int) *ret;
}
@+ BAT Iterator Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= batcheck
        if( BBPcheck(*@2,@4)==0) return GDK_FAIL;
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) {
                *@1 = 0;
                return GDK_FAIL;
        }
@-
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0) return i;
	} else {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0) return i;
	} break;
@c
int CMDhashloop(int *ret, lng *cursor, int *bid)
{
	BAT *b;
	@:batcheck(ret,bid,b,"CMDnextElement")@
	GDKerror("not yet implemented\n");
	return GDK_SUCCEED;
}

@-
In principle, we could add iterators with other range bounds.
@= nextLoop
int CMDnextElement_@1(bit *ret, @1 *cursor, int *bid)
{
	BAT *b;
	int limit;
	@:batcheck(ret,bid,b,"CMDnextElement")@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;
	return GDK_SUCCEED;
}
@-
@c
	@:nextLoop(int)@

int CMDnextElement(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int *cursor;
	bit *ret;
	int *bid;
	int limit;
	BUN p;
	ValPtr head, tail;

	if( pci->argc != 5) printf("exception in nextElement\n");
	ret = (bit *) getArgReference(stk,pci,0);
	cursor = (int *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	head = &stk->stk[pci->argv[3]];
	tail = &stk->stk[pci->argv[4]];

	@:batcheck(ret,bid,b,"CMDnextElement")@
	limit=  BUNindex(b,BUNlast(b));

	if( *cursor <0)
		*cursor = BUNindex(b,BUNfirst(b));
	else	*cursor = *cursor+1;
	*ret = *cursor < limit;

	if( *ret== FALSE) return GDK_SUCCEED;
	/* get head = ... tail = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	garbageElement(tail); 
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	VALinit( tail, getArgType(mb,pci,4),BUNtail(b,p));
	return GDK_SUCCEED;
}
int CMDnextSlice(int *ret, lng *cursor, int *bid, lng *low, lng *high)
{
	BAT *b;
	@:batcheck(ret,bid,b,"CMDnextSlice")@
	if( *cursor > *high){
		*ret = FALSE;
	} else 
	if( *cursor < *low){
		*ret = TRUE;
		*cursor = BUNindex(b,BUNfirst(b));
	} else
		*cursor = *cursor+1;
	return GDK_SUCCEED;
}
@-
The fetch operations are all pretty straight forward, provided
you know the underlying type. Often it is cheaper to use
the extended BAT iterator, because then it can re-use the
BAT descriptor.
@c
int CMDgetHead(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr head;
	int r, *ret=&r;

	cursor = (int *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	head = &stk->stk[pci->argv[0]];

	@:batcheck(ret,bid,b,"CMDnextElement")@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return (int)raiseException(mb,stk->pc,"MALexception",
					"getHead:range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(head);
	VALinit( head, getArgType(mb,pci,3),BUNhead(b,p));
	return GDK_SUCCEED;
}
int CMDgetTail(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int *cursor;
	int *bid;
	int limit;
	BUN p;
	ValPtr tail;
	int r, *ret=&r;

	cursor = (int *) getArgReference(stk,pci,1);
	bid = (int *) getArgReference(stk,pci,2);
	tail = &stk->stk[pci->argv[0]];

	@:batcheck(ret,bid,b,"CMDnextElement")@
	limit=  BUNindex(b,BUNlast(b));
	if( *cursor<0  || *cursor >=limit) {
		return (int)raiseException(mb,stk->pc,"MALexception",
					"getTail:range error");
	}

	/* get head = ... */
	p = BUNptr(b,*cursor);
	garbageElement(tail);
	VALinit( tail, getArgType(mb,pci,3),BUNtail(b,p));
	return GDK_SUCCEED;
}
