@ enum
@t Enumeration Datatypes
@a Peter Boncz
@v 1.0
@* Introduction

When large sets of data are stored and memory is short, one 
seeks for memory occupation optimizations.

One way to do this when the ordinality is low, is to substitute
the datatype to a smaller ordinal datatype. For instance, when 
less than 256 different string values occur in an attribute, one 
could store them as a byte. 

This remapping can be encapsulated nicely by introducing an 'enum'
atomic type, that appears to be the original type, but is in fact
stored as something smaller. Encode and decode commands, as well 
as 'tostr' and 'fromstr' ADT functions, can be generated beforehand
and use a mapping table to translate between the two representations. 

Further space optimizations into values smaller than a byte are
impossible in Monet, since all values need to have a unique memory address.

Though this may by a problem may waste memory, one should realize that 
main-memory databases suffer increasingly when the data representation gets 
more complex. This is obviously true for complex compression schemes, but 
even loading a single byte value is considerably slower on custom CPUs
than loading an entire 32-bit integer. On 64-bits architectures, this 
will even be the case for long 64-bit integers. 


This module implements encodings using 'chr' (1-byte encoding),
and 'sht' (2-byte encoding).

In order to use an enumerated type, it should first be introduced as
an ordinary type name, e.g. 'atom fruit:enum'. By default its underlying
type is then set to 'int'.
As soon as a bat of values is associated with the type, its
underlying type changes based on the storage space needed.

Furthermore, the enumerated types are considered ordinary BATs,
whose scope is limited unless they are explicitly made persistent.
Destroying an enumerated type removes its encoding bat and the
information from the GDK atom library, but does not affect the
MAL programs. This implies a runtime error as soon as you
try to encode/decode a value.
@* Module Definition 
@mal
atom enum:int;
module enum;

pattern create(e:any::2, src:bat[any,any::1]): bat[any::1,any::2]= enum_create
comment "Associate a value domain with an enumerated type.";

pattern load(map:any::1):BAT[any,any::1] = enum_load
comment "Load/activate a previously created enumeration type.";

pattern destroy(map:any):void = enum_destroy
comment "Destroy an enumeration type";

pattern encode(e:any::1,v:any::2):any::1 = enum_encode
comment "Encode a value using a small map";

pattern encode(e:any::2,b:BAT[any::1,any]):BAT[any::1,any::2] = enum_encode_multi
comment "Encode a BAT of tail values, into a new BAT of encoded values.
This action is actually a join operation.";

pattern lower(e:any::1, v:any::2):any::1 = enum_lower
comment "Encode to the lowest value in the encoded domain that is 
	equal to or larger than v";

pattern upper(e:any::1, v:any::2):any::1 = enum_upper
comment "Encode to the highest value in the encoded domain that is 
	equal to or less than v";

pattern decode(e:any):any = enum_decode
comment "Decode a value";

pattern decode(b:BAT[any::2,any::1]) : BAT[any::2,any] = enum_decode_multi
comment "Decode a BAT of tail values, into a new BAT of decoded values";

pattern getTable(e:any::1) : bat = enum_table
comment "Return the enumeration BAT of an enum type";

command isEnum(tpe:bat) : bit = isEnum
comment "Returns true iff the bat is used as an enumerated type";

command setHistogram(tpe:any::1, b:BAT[any,any]):void = enum_sethisto
comment "registers the fact that enum_table(tpe) is a histogram on b's head column";

pattern isHistogram(tpe:any,b:BAT[any,any]) : bit = enum_ishisto
comment "returns whether enum_table(tpe) is a histogram on b's head column";

@- 
oldstuff

    proc enum_trick(bat[oid,any] b, BAT[any,int] map) : bat[oid,any] {
        var nme := sprintf("enum_%d", abs(int(map)));
        map.rename(nme);
        var tpe := enum_load(nme);
        enum_sethisto(tpe, b.reverse);
        return [*nme](b);
    }
    ADDHELP("enum_trick", "boncz", "Dec  5 1998",
         "create a view on a BAT with a diffrent enum map.", "enum");

@{
@* Implementation
Part of the code is copied from the V 4.3 bat.mx file.
@= getBATdescriptor
        if( BBPcheck(*@2,@4)==0) return GDK_FAIL;
        @3= (BAT*) BBPgetdesc(*@2);
        if( @3 == NULL) { *@1 = 0; return GDK_FAIL;}
	if( *@2 <0) @3= BATmirror(@3);
@-
Note that we have to build the table with pre-instantiated
function references, because there is no easy way from the GDK layer
to access the enum administration.
@c
#include "gdk.h"
#include "mal_client.h"
#include "io.h"

typedef int (*fcn)();
#define ENUM_CHK(x,y)\
	     for(xx=0; xx<MAX_ENUM; xx++)\
		if (enum_tpe[xx] == x) break;\
	     if ((xx>MAX_ENUM) || ((b=BATdescriptor(enum_map[xx])) == NULL)) {\
	 	GDKerror("%s: illegal enum type.\n",y);\
		return GDK_FAIL; \
	     }

#define MAX_ENUM 80

bat enum_map[MAX_ENUM] = { 0 };
oid enum_histo[MAX_ENUM] = { 0 };
int enum_tpe[MAX_ENUM] = { -1 };

@:imp(0)@	@:imp(1)@	@:imp(2)@	@:imp(3)@ 	@:imp(4)@
@:imp(5)@	@:imp(6)@	@:imp(7)@	@:imp(8)@ 	@:imp(9)@
@:imp(10)@	@:imp(11)@	@:imp(12)@	@:imp(13)@ 	@:imp(14)@
@:imp(15)@	@:imp(16)@	@:imp(17)@	@:imp(18)@ 	@:imp(19)@
@:imp(20)@	@:imp(21)@	@:imp(22)@	@:imp(23)@ 	@:imp(24)@
@:imp(25)@	@:imp(26)@	@:imp(27)@	@:imp(28)@ 	@:imp(29)@
@:imp(30)@	@:imp(31)@	@:imp(32)@	@:imp(33)@ 	@:imp(34)@
@:imp(35)@	@:imp(36)@	@:imp(37)@	@:imp(38)@ 	@:imp(39)@
@:imp(40)@	@:imp(41)@	@:imp(42)@	@:imp(43)@ 	@:imp(44)@
@:imp(45)@	@:imp(46)@	@:imp(47)@	@:imp(48)@ 	@:imp(49)@
@:imp(50)@	@:imp(51)@	@:imp(52)@	@:imp(53)@ 	@:imp(54)@
@:imp(55)@	@:imp(56)@	@:imp(57)@	@:imp(58)@ 	@:imp(59)@
@:imp(60)@	@:imp(61)@	@:imp(62)@	@:imp(63)@ 	@:imp(64)@
@:imp(65)@	@:imp(66)@	@:imp(67)@	@:imp(68)@ 	@:imp(69)@
@:imp(70)@	@:imp(71)@	@:imp(72)@	@:imp(73)@ 	@:imp(74)@
@:imp(75)@	@:imp(76)@	@:imp(77)@	@:imp(78)@ 	@:imp(79)@

fcn enum_conv[MAX_ENUM*4+1] = { 
@:def(0)@	@:def(1)@	@:def(2)@	@:def(3)@ 	@:def(4)@
@:def(5)@	@:def(6)@	@:def(7)@	@:def(8)@ 	@:def(9)@
@:def(10)@	@:def(11)@	@:def(12)@	@:def(13)@ 	@:def(14)@
@:def(15)@	@:def(16)@	@:def(17)@	@:def(18)@ 	@:def(19)@
@:def(20)@	@:def(21)@	@:def(22)@	@:def(23)@ 	@:def(24)@
@:def(25)@	@:def(26)@	@:def(27)@	@:def(28)@ 	@:def(29)@
@:def(30)@	@:def(31)@	@:def(32)@	@:def(33)@ 	@:def(34)@
@:def(35)@	@:def(36)@	@:def(37)@	@:def(38)@ 	@:def(39)@
@:def(40)@	@:def(41)@	@:def(42)@	@:def(43)@ 	@:def(44)@
@:def(45)@	@:def(46)@	@:def(47)@	@:def(48)@ 	@:def(49)@
@:def(50)@	@:def(51)@	@:def(52)@	@:def(53)@ 	@:def(54)@
@:def(55)@	@:def(56)@	@:def(57)@	@:def(58)@ 	@:def(59)@
@:def(60)@	@:def(61)@	@:def(62)@	@:def(63)@ 	@:def(64)@
@:def(65)@	@:def(66)@	@:def(67)@	@:def(68)@ 	@:def(69)@
@:def(70)@	@:def(71)@	@:def(72)@	@:def(73)@ 	@:def(74)@
@:def(75)@	@:def(76)@	@:def(77)@	@:def(78)@ 	@:def(79)@
0 };

@= def
	enum@1chrTostr, enum@1chrFromstr, enum@1shtTostr, enum@1shtFromstr,
@= block
int enum@1Tostr(int mapid, str* dst, int* len, @1* src){
	int l; ptr v; 
	BAT *b = BATdescriptor(enum_map[mapid]);

	if (*src == @1_nil) {
		v = ATOMnilptr(b->htype);
	} else {
		BUN p = BUNptr(b, 1 + *(unsigned @2*) src); 
		v = BUNhead(b,p);
	}
	if (b->htype != TYPE_str) {
		fcn tostr = BATatoms[b->htype].atomToStr;
		return (*tostr)(dst, len, v);
	}
	l = strLen(v);
	if (*len < l) {
		if (*dst) GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = l);
	}
	memcpy(*dst, v, l);
	return l; 
}
int enum@1Fromstr(int mapid, str src, int* len, @1** dst){
	int r, l = 0;
	BUN p; ptr v;
	BAT *b = BATdescriptor(enum_map[mapid]);

	if (b->htype != TYPE_str) {
		fcn fromstr = BATatoms[b->htype].atomFromStr;
 		v = (ptr) GDKmalloc(l=32);
		r = (*fromstr)(src, &l, &v);
	} else {
		r = strlen(src); 
		v = src;
	}
	if (*len < sizeof(@1)) {
		*dst = (@1*) GDKmalloc(*len = sizeof(@1));
	}
	if ((p = SORTfnd(b, v)) != NULL) {
		**(unsigned @2**) dst = BUNindex(b,p)-1;
	} else {
		**dst = @1_nil;
	}
	if (l) GDKfree(v);
	return r;
}
@-
@c
@:block(chr,char)@
@:block(sht,short)@
@= imp
	@:template(@1,chr,char)@ @:template(@1,sht,short)@
@= template
static int enum@1@2Tostr(char** dst, int* len, @2* src){
	return enum@2Tostr(@1,dst,len,src);
}
static int enum@1@2Fromstr(str src, int* len, @2** dst){
	return enum@2Fromstr(@1,dst,len,src);
}
@c
int enum_atom(int i, BAT *h){
	str name= h->batId;
	if (BATcount(h) > 255) {
		ATOMproperty(name, "storage", (fcn) TYPE_sht); 
		ATOMproperty(name, "tostr", enum_conv[i*4+2]);
		ATOMproperty(name, "fromstr", enum_conv[i*4+3]);
	} else {
		ATOMproperty(name, "storage", (fcn) TYPE_chr); 
		ATOMproperty(name, "tostr", enum_conv[i*4]);
		ATOMproperty(name, "fromstr", enum_conv[i*4+1]);
	}
	enum_tpe[i] = ATOMindex(name);
	enum_map[i] = h->batCacheid;
	BBPfix(h->batCacheid);
	return enum_tpe[i];
}
int enum_reload(int *retval, int bid) {
	int i;
	BAT *h;

	@:getBATdescriptor(retval,&bid,h,"enum_load")@
	MT_set_lock(mal_contextLock, "enum_load");
	for(i=0; i<MAX_ENUM; i++) {
		if (enum_map[i] == 0) {
			char *name = h->batId;
			if (BATcount(h) > 255) {
				ATOMproperty(name, "storage", (fcn) TYPE_sht); 
				ATOMproperty(name, "tostr", enum_conv[i*4+2]);
				ATOMproperty(name, "fromstr", enum_conv[i*4+3]);
			} else {
				ATOMproperty(name, "storage", (fcn) TYPE_chr); 
				ATOMproperty(name, "tostr", enum_conv[i*4]);
				ATOMproperty(name, "fromstr", enum_conv[i*4+1]);
			}
			enum_tpe[i] = ATOMindex(name);
			enum_map[i] = h->batCacheid;
			BBPfix(h->batCacheid);
			*retval = h->batCacheid;
			MT_unset_lock(mal_contextLock, "enum_load");
			return GDK_SUCCEED;
		}
	}
	MT_unset_lock(mal_contextLock, "enum_load");
	GDKerror("enum_load: too many active enum types.\n");
	return GDK_FAIL;
}

int enum_create(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *h,*b;
	ptr nil;
	int *retval,hid,bid,ret;
	int tpe,xx;
	str name;

	retval = (int*) getArgReference(stk,pci,0);
	tpe= getArgType(mb,pci,1);
	bid= *(int*) getArgReference(stk,pci,2);
	name= malTypeName(tpe);
	@:getBATdescriptor(retval,&bid,b,"enum_create")@
	h = BAThistogram(b);
	nil = ATOMnilptr(b->htype);
	BUNdelHead(h, nil);
	BATorder(h);
	BATrename(h, name);
/*
	BATmode(h, PERSISTENT);
	BBPsave(h);
*/
	hid= h->batCacheid;
	ret= enum_reload(retval, hid);
	GDKfree(name);
	return ret;
}
int enum_load(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx;
	int tpe, *retval,ret;
	str name;

	tpe= getArgType(mb,pci,1);
	name= malTypeName(tpe);
	retval= (int*) getArgReference(stk,pci,0);
	*retval= BBPindex(name);
	if( *retval ==0){
		GDKerror("enum_load: encoding BAT does not exist.\n");
		return GDK_FAIL;
	}
	ret= enum_reload(retval,*retval);
	GDKfree(name);
	return ret;
}

int enum_destroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx;
	int tpe;

	tpe= getArgType(mb,pci,1);
	ENUM_CHK(tpe, "enum_destroy");
	MT_set_lock(mal_contextLock, "enum_destroy");
	ATOMdelete(tpe);
	BBPunfix(enum_map[xx]);
	enum_histo[xx] = 0;
	enum_map[xx] = 0;
	enum_tpe[xx] = 0;
	MT_unset_lock(mal_contextLock, "enum_destroy");
	return GDK_SUCCEED;
}
@-
The result of an encode/lower/upper step is stored in the 
receiving variable.
@= encoding
	if( ATOMstorage(tpe)== TYPE_chr){
		if (p == NULL) *(chr*) dst = chr_nil; 
		else *(unsigned char*) dst = BUNindex(b,p) - 1;
	} else {
		if (p == NULL) *(sht*) dst = sht_nil; 
		else *(unsigned short*) dst = BUNindex(b,p) - 1;
	}
@c
int enum_encode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	ptr p,src,dst;
	int xx;
	int tpe;

	tpe= getArgType(mb,pci,1);
	ENUM_CHK(tpe,"enum_encode");
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	p = BUNfnd(b, src);
	@:encoding@
	return GDK_SUCCEED;
}
int enum_lower(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	ENUM_CHK(tpe,"enum_lower");
	if (!ATOMlinear(b->htype)) {
	 	GDKerror("enum_lower@1Map: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (BAThordered(b)&1) {
		p = SORTfndlast(BATmirror(b), src);
		if (p && p > BUNfirst(b))  p -= BUNsize(b);
		else p = NULL;
	} else {
		BATidx(b, NULL);
		p = (BUN) IDXfndlast(b, src);
		if (p && p > (BUN) b->hidx.first) p = ((BUN*) p)[-1];
		else p = NULL;
	}
	@:encoding@
	return GDK_SUCCEED;
} 

int enum_upper(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src,dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,2);
	dst= (ptr) getArgReference(stk,pci,0);
	ENUM_CHK(tpe,"enum_lower");
	if (!ATOMlinear(b->htype)) {
	 	GDKerror("enum_upper@1Map: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (BAThordered(b)&1) {
		p = SORTfndfirst(BATmirror(b), src);
	} else {
		BATidx(b,NULL);
		p = (BUN) IDXfndfirst(b, src);
		if (p) p = *(BUN*) p;
	}
	@:encoding@
	return GDK_SUCCEED;
} 

int enum_decode(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int xx,tpe;
	BUN p,src, *dst;
	BAT *b;
	
	tpe= getArgType(mb,pci,1);
	src= *(ptr*) getArgReference(stk,pci,1);
	dst= (ptr) getArgReference(stk,pci,0);
	ENUM_CHK(tpe,"enum_lower");

	if( b->htype != getArgType(mb,pci,0)){
		GDKerror("enum_decode:incompatible source type\n");
		return GDK_FAIL;
	}
	if( ATOMstorage(tpe) == TYPE_chr){
		if (*(chr*) src == chr_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned char*)src));
	} else{
		if (*(sht*) src == sht_nil) p = ATOMnilptr(b->htype);
		else p = BUNhead(b, BUNptr(b, 1 + *(unsigned short*)src));
	}
	
	if (b->hvarsized) {
		int l = ATOMlen(b->htype, p); 
		* (ptr*)dst =  (ptr*) GDKmalloc(l);
		memcpy(*(ptr*)dst, p, l);
	} else {
		memcpy(dst, p, ATOMsize(b->htype));
	}
	return GDK_SUCCEED;
}


#define HASHfnd_loc(r,b,p) r = BUNfnd(b,p)
#define HASHfnd_var(r,b,p) r = BUNfnd(b,p)

@= encode
{ 	BAT *bn = BATnew(src->htype, tpe, BATcount(src)); 
	BUN p,q,r; int xx;
	unsigned @2 idx;
	
	if (BAThordered(b)&1) {
	    BATloopFast(src, p, q, xx) {
		BUN r = (BUN) SORTfnd@4(b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} else {
	    BATloopFast(src, p, q, xx) {
		HASHfnd@4(r, b, BUNt@3(src,p));
		if (r == NULL) {
			idx = @1_nil; 
		} else {
			idx = BUNindex(b,r) - 1;
		}
		BUNfastins(bn, BUNhead(src,p), &idx); 
	    } 
	} 
	*retval = bn->batCacheid;
	bn->tsorted = 0;
	ALIGNsetH(bn, src);
} break;
@c
int enum_encode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	ptr p;
	int xx,bid,*retval;
	int tpe;

	tpe= getArgType(mb,pci,1);
	ENUM_CHK(tpe,"enum_encode_multi");
	bid= *(int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,&bid,src,"enum_encode_multi")@

	if (src->ttype != b->htype) {
	 	GDKerror("[encode]: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		GDKerror("[encode](): illegal tail type.\n");
	        return GDK_FAIL;
	    case TYPE_chr:	@:encode(chr,char,loc,_chr)@
	    case TYPE_sht:	@:encode(chr,char,loc,_sht)@
	    case TYPE_int:	@:encode(chr,char,loc,_int)@
	    case TYPE_flt:	@:encode(chr,char,loc,_flt)@
	    case TYPE_lng:	@:encode(chr,char,loc,_lng)@
	    case TYPE_dbl:	@:encode(chr,char,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(chr,char,var,_var)#
		    } else {
				@:encode(chr,char,loc,_loc)#
	    }	    }
	} else {
	    switch(ATOMstorage(src->ttype)) {
	    case TYPE_void: 
		GDKerror("[encode](): illegal tail type.\n");
	        return GDK_FAIL;
	    case TYPE_chr:	@:encode(sht,short,loc,_chr)@
	    case TYPE_sht:	@:encode(sht,short,loc,_sht)@
	    case TYPE_int:	@:encode(sht,short,loc,_int)@
	    case TYPE_flt:	@:encode(sht,short,loc,_flt)@
	    case TYPE_lng:	@:encode(sht,short,loc,_lng)@
	    case TYPE_dbl:	@:encode(sht,short,loc,_dbl)@
	    default:if(src->tvarsized) {
				@:encode(sht,short,var,_var)#
		    } else {
				@:encode(sht,short,loc,_loc)#
	    }	    }
	}
	return GDK_SUCCEED;
} 

@= decode
{	BAT *bn = BATnew(src->htype, b->htype, BATcount(src)); 
	BUN p,q; int xx;
	ptr w,nil = ATOMnilptr(b->htype);
	
	BATloopFast(src, p, q, xx) {
		unsigned @2 *idx = (unsigned @2*) BUNtloc(src,p);
		if (*(@1*) idx == chr_nil) {
			w = nil;
		} else {
			w = BUNhead(b, BUNptr(b, 1 + *idx));
		}
		BUNfastins(bn, BUNhead(src,p), w); 
		
	} 
	*retval = bn->batCacheid;
}
@c
int enum_decode_multi(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*src;
	ptr p;
	int xx,*bid,*retval;
	int tpe;

	bid= (int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);
	@:getBATdescriptor(retval,bid,src,"enum_encode_multi")@
	tpe= src->ttype;
	ENUM_CHK(tpe,"enum_encode_multi");
	if (ATOMstorage(tpe) == TYPE_chr) { 
	    @:decode(chr,char)@
	} else if (ATOMstorage(tpe) == TYPE_sht) { 
	    @:decode(sht,short)@
	} else {
	    GDKerror("enum_decode_multi(): illegal tail type.\n");
	    return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int enum_chktpe(int tpe) {
	int i;
	for(i=0; i<MAX_ENUM; i++)
		if (enum_tpe[i] == tpe) return TRUE;
	return FALSE;
}

int enum_isTable(BAT *b, int tpe){
	if( b->ttype== tpe)
		return enum_chktpe(tpe);
	return FALSE;
}
int enum_table(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b;
	int xx,*retval;
	int tpe;

	tpe= *(int*) getArgReference(stk,pci,1);
	retval= (int*) getArgReference(stk,pci,0);

	ENUM_CHK(tpe, "enum_table");
	BBPfix(b->batCacheid);
	*retval = b->batCacheid;
	return GDK_SUCCEED;
}

int isEnum(bit *ret, int *bid){
	BAT *b;
	int i;
	@:getBATdescriptor(ret,bid,b,"isEnum")@
	*ret= FALSE;
	for(i=0; i<MAX_ENUM; i++)
		if (enum_map[i] == b->batCacheid) { *ret= TRUE;break;}
	return GDK_SUCCEED;
}

int enum_sethisto(int *retval, int* tpe, int *bid) {
	BAT *b,*column;
	int xx;
	ENUM_CHK(*tpe, "enum_sethisto");
	@:getBATdescriptor(retval,bid,column,"enum_sethisto")@
	if (column->halign == 0) {
		column->halign = OIDnew(1);
		column->batDirtydesc = TRUE;
	}
	enum_histo[xx] = column->halign;
	return GDK_SUCCEED;
}

int enum_ishisto(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	BAT *b,*column;
	int xx,*retval;
	int tpe,*bid;

	tpe= *(int*) getArgReference(stk,pci,1);
	bid= (int*) getArgReference(stk,pci,2);
	retval= (int*) getArgReference(stk,pci,0);
	ENUM_CHK(tpe, "enum_ishisto");
	@:getBATdescriptor(retval,bid,column,"enum_ishisto")@
	*retval = (enum_histo[xx] == column->halign);
	return GDK_SUCCEED;
}

int enum_epilogue() {
	int xx;
	for(xx=0; xx<MAX_ENUM; xx++)  {
		if (enum_map[xx])  {
			BBPunfix(enum_map[xx]);
		}
	}
	return GDK_SUCCEED;
}
