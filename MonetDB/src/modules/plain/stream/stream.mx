@f stream
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files. 

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <ctype.h>
#include <stdio.h>

#ifdef _MSC_VER
#ifndef LIBSTREAM
#define stream_export extern __declspec(dllimport) 
#else
#define stream_export extern __declspec(dllexport) 
#endif
#else
#define stream_export extern 
#endif

typedef struct stream {
	short byteorder;
	char *filename;
	char *stream_data;
	int errnr;
	int (*read)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	int (*readInt)( struct stream *s, int *val );
	int (*write)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	int (*writeInt)( struct stream *s, const int val );
	void (*close)( struct stream *s);
	char *(*error)( struct stream *s );
	void (*destroy)( struct stream *s );
	void (*flush)( struct stream *s );
} stream;

stream_export stream *open_rstream( char *filename );
stream_export stream *open_wstream( char *filename );
/* open in ascii stream in read mode */
stream_export stream *open_rastream( char *filename ); 
/* open in ascii stream in write mode*/
stream_export stream *open_wastream( char *filename ); 

#ifdef HAVE_LIBZ
stream_export stream *open_gzrstream( char *filename );
stream_export stream *open_gzwstream( char *filename );
stream_export stream *open_gzrastream( char *filename );
stream_export stream *open_gzwastream( char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream_export stream *open_bzrstream( char *filename );
stream_export stream *open_bzwstream( char *filename );
stream_export stream *open_bzrastream( char *filename );
stream_export stream *open_bzwastream( char *filename );
#endif

stream_export stream *socket_rstream( int socket, char *name );
stream_export stream *socket_wstream( int socket, char *name );
stream_export stream *socket_rastream( int socket, char *name );
stream_export stream *socket_wastream( int socket, char *name );

stream_export stream *file_rstream( FILE *fp, char *name );
stream_export stream *file_wstream( FILE *fp, char *name );
stream_export stream *file_rastream( FILE *fp, char *name );
stream_export stream *file_wastream( FILE *fp, char *name );

stream_export stream *block_stream( stream *s );

#endif /*_STREAM_H_*/
@c
#include <config.h>
#include "stream.h"
#include <string.h> 

#ifdef HAVE_NETDB_H
# include <sys/types.h> 
# include <netinet/in_systm.h> 
# include <netinet/in.h> 
# include <netinet/ip.h> 
# include <netinet/tcp.h>
# include <netdb.h> 
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif

#define convertInt(i) (((0x000000ff&(i))<<24) | ((0x0000ff00&(i))<<8) | \
                       ((0x00ff0000&(i))>>8)  | ((0xff000000&(i))>>24))


typedef enum steam_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;

#define EXT_LEN 4
static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void stream_destroy( stream *s){
	free(s->filename);
	free(s);
}

static stream *create_stream( char *filename ){
	stream *s = (stream*)malloc(sizeof(stream));
	s->byteorder = 1234;
	s->filename = strdup(filename); 
	s->stream_data = NULL;
	s->errnr = NO__ERROR;
	s->destroy = &stream_destroy;
	return s;
}

static char *stream_error( stream *s ){
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		sprintf(buf, "Error could not open file %s\n", s->filename );
		return strdup(buf);
	case READ_ERROR:
		sprintf(buf, "Error reading file %s\n", s->filename );
		return strdup(buf);
	case WRITE_ERROR:
		sprintf(buf, "Error writing file %s\n", s->filename );
		return strdup(buf);
	}
	return strdup("Unkonwn error");
}

static int stream_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fread( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static int stream_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int res = fwrite( buf, elmsize, cnt, (FILE*)s->stream_data);
	fflush( (FILE*)s->stream_data );
	return res;
}

static int stream_readInt( stream *s, int *val ){
	int ok = s->read(s, (char*)val, sizeof(int), 1) == 1;
	if (!ok) s->errnr = READ_ERROR;
	if (s->byteorder != 1234)
		*val = convertInt(*val);	
	return ok;
}
static int stream_writeInt( stream *s, const int val ){
	int ok = s->write(s, (char*)&val, sizeof(int), 1)==1;
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}

static void stream_close( stream *s ){
	FILE *fp = (FILE*)s->stream_data;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
	else
		fflush( fp );
}
static void stream_flush( stream *s ){
	fflush( (FILE*)s->stream_data);
}
static stream *open_stream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = &stream_read;
	s->write = &stream_write;
	s->readInt  = &stream_readInt;
	s->writeInt = &stream_writeInt;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
	  	s = open_stream( filename, "rb");
		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_wstream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		if (s->errnr == NO__ERROR)
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_rastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "rb");
		return s;
	}
}
stream *open_wastream( char *filename ){
	stream *s;
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return s;
	} 
#endif
	{
		s = open_stream( filename, "wb");
		return s;
	}
}


#ifdef HAVE_LIBZ
static int stream_gzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzread( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_gzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzwrite( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_gzreadInt( stream *s, int *val ){
	int ok = gzread( (gzFile*)s->stream_data, (char*)val, sizeof(int)) == sizeof(int);
	if (s->byteorder != 1234)
		*val = convertInt(*val);	
	if (!ok) s->errnr = READ_ERROR;
	return ok;
}
static int stream_gzwriteInt( stream *s, const int val ){
	int ok = gzwrite( (FILE*)s->stream_data, (char*)&val, sizeof(int)) == sizeof(int);
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}
static void stream_gzclose( stream *s ){
	gzclose( (gzFile*)s->stream_data);
}
static void stream_gzflush( stream *s ){
	gzflush( (gzFile*)s->stream_data, Z_SYNC_FLUSH);
}
stream *open_gzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = &stream_gzread;
	s->write = &stream_gzwrite;
	s->readInt  = &stream_gzreadInt;
	s->writeInt = &stream_gzwriteInt;
	s->close = &stream_gzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_gzflush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzwstream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzrastream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	return s;
}
stream *open_gzwastream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static int stream_bzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzread( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_bzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzwrite( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_bzreadInt( stream *s, int *val ){
	int ok = BZ2_bzread( (BZFILE*)s->stream_data, (char*)val, sizeof(int)) == sizeof(int);
	if (s->byteorder != 1234)
		*val = convertInt(*val);	
	if (!ok) s->errnr = READ_ERROR;
	return ok;
}
static int stream_bzwriteInt( stream *s, const int val ){
	int ok = BZ2_bzwrite( (BZFILE*)s->stream_data, (char*)&val, sizeof(int)) == sizeof(int);
	if (!ok) s->errnr = WRITE_ERROR;
	return ok;
}
static void stream_bzclose( stream *s ){
	BZ2_bzclose( (BZFILE*)s->stream_data);
}
static void stream_bzflush( stream *s ){
	BZ2_bzflush( (BZFILE*)s->stream_data);
}
stream *open_bzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = &stream_bzread;
	s->write = &stream_bzwrite;
	s->readInt  = &stream_bzreadInt;
	s->writeInt = &stream_bzwriteInt;
	s->close = &stream_bzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	s->flush = &stream_bzflush;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzwstream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzrastream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	return s;
}
stream *open_bzwastream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	return s;
}
#endif

static int socket_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
#ifdef WIN32
	size = send( (int)s->stream_data, buf, size, 0 );
#else
	size = write( (int)s->stream_data, buf, size );
#endif
	if (size) return size/elmsize;
	return 0;
}
static int socket_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int res = 0, size = elmsize*cnt;
	while( (res += 
#ifdef WIN32
			recv( (int)s->stream_data, buf+res, size-res, 0 )
#else
			read( (int)s->stream_data, buf+res, size-res )
#endif
			) > 0 && res < size );
	if (size) return size/elmsize;
	return 0;
}
static void socket_flush( stream *s ){
	/* not needed */
}
static void socket_close( stream *s ){
	int fd = (int)s->stream_data;
	shutdown(fd,2);
	close(fd);
}
static
stream *socket_open( int socket, char *name ){
	int fl = fcntl(socket, F_GETFL);
	stream *s = create_stream(name);
	s->read  = &socket_read;
	s->write = &socket_write;
	s->readInt  = &stream_readInt;
	s->writeInt = &stream_writeInt;
	s->close = &socket_close;
	s->error = &stream_error;
	s->flush = &socket_flush;
	s->stream_data = (char*)socket;

#ifdef SO_KEEPALIVE
	{ int opt = 0; 
	setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (char *) &opt,
			                   sizeof(opt)); }
#endif
#ifdef IPTOS_THROUGHPUT
	{ int tos = IPTOS_THROUGHPUT; 
    	setsockopt(socket, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos)); }
#endif
#ifdef TCP_NODELAY
	{ int nodelay = 1;
    	setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay,
		                         sizeof(nodelay)); }
#endif
	fl &= ~O_NONBLOCK;
	fcntl(socket, F_SETFL, fl ); 

	return s;
}
stream *socket_rstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	if (s->errnr == NO__ERROR)
		read( socket, (char*)&s->byteorder, sizeof(short)); 
	return s;
}

stream *socket_wstream( int socket, char *name ){
	stream *s = socket_open( socket, name );
	if (s->errnr == NO__ERROR)
	   	write( socket, (char*)&s->byteorder, sizeof(short));
	return s;
}

stream *socket_rastream( int socket, char *name ){
	return socket_open( socket, name );
}

stream *socket_wastream( int socket, char *name ){
	return socket_open( socket, name );
}

stream *file_stream( char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->readInt  = &stream_readInt;
	s->writeInt = &stream_writeInt;
	s->close = &stream_close;
	s->error = &stream_error;
	s->flush = &stream_flush;
	return s;
}
stream *file_rstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
			fflush( (FILE*)s->stream_data );
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, char *name ){
	stream *s = file_stream(name);
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
} 

#define BLOCK 4096

typedef struct bs {
	stream *s;
	int onr;
	int inr;
	int itotal;
	char out[BLOCK];
	char in[BLOCK];
} bs;

static
bs *bs_create( stream *s ){
	/* should be a binary stream */
	bs *ns = (bs*)malloc(sizeof(bs));
	ns->s = s;
	ns->inr = 0;
	ns->itotal = 0;
	ns->onr = 0;
	return ns;
}

static
int bs_write( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	int todo = cnt * elmsize;
	if (s->onr + todo >= BLOCK){
		int rest = BLOCK - s->onr;
		memcpy( s->out+s->onr, buf, rest );
		buf += rest;
		todo -= rest;

		s->s->writeInt( s->s, BLOCK);
		s->s->write( s->s, s->out, 1, BLOCK);
		s->onr = 0;
	}
	while (todo >= BLOCK){
		s->s->writeInt( s->s, BLOCK);
		s->s->write( s->s, buf, 1, BLOCK);
		buf += BLOCK;
		todo -= BLOCK;
	}
	memcpy( s->out+s->onr, buf, todo );
	s->onr += todo;
	return cnt;
}

static
int bs_read( stream *ss, char *buf, size_t elmsize, size_t cnt ){
	bs *s = (bs*)ss->stream_data;
	int nr = 0;

	int todo = cnt * elmsize;
	if (todo < s->itotal - s->inr){
		memcpy( buf, s->in + s->inr, todo );

		s->inr += todo;
		return cnt;
	}
	if (todo >= s->itotal - s->inr ){
		int rest = s->itotal - s->inr;
		memcpy( buf, s->in + s->inr, rest );
		buf += rest;
		todo -= rest;

		s->inr = 0;
		s->itotal = 0;
	}
	while (todo >= BLOCK){
		s->s->readInt( s->s, &nr);
		s->s->read( s->s, buf, 1, BLOCK);
		buf += nr;
		todo -= nr;
		if (nr < BLOCK){
			return cnt - (todo/elmsize);
		}
	} 
	if (todo){
		s->s->readInt( s->s, &nr);
		s->s->read( s->s, s->in, 1, BLOCK);
		memcpy( buf, s->in, todo );
		s->itotal = nr;
		s->inr = todo;
		todo -= nr;
	}
	if (s->itotal < s->inr){
		s->itotal = s->inr = 0;
		return cnt - (todo/elmsize);
	} else {
		return cnt;
	}
}

static
int bs_writeInt( stream *ss, const int res ){
	printf("writeInt not available \n");
	return -1;
}
static
int bs_readInt( stream *ss, int *res ){
	printf("readInt not available \n");
	return -1;
}

static
void bs_flush(stream *ss){
	bs *s = (bs*)ss->stream_data;
	if (s->onr){
		s->s->writeInt( s->s, s->onr);
		s->s->write( s->s, s->out, 1, BLOCK );
	}
	s->onr = 0;
}

static
void bs_close( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->close( s->s );
}
static
void bs_destroy( stream *ss ){
	bs *s = (bs*)ss->stream_data;
	s->s->destroy( s->s );
	free(s);
	stream_destroy(ss);
}

stream *block_stream( stream *s ){
	stream *ns = create_stream(s->filename);
	bs *bs = bs_create(s);
	ns->read  = &bs_read;
	ns->write = &bs_write;
	ns->readInt  = &bs_readInt;
	ns->writeInt = &bs_writeInt;
	ns->close = &bs_close;
	ns->error = &stream_error;
	ns->flush = &bs_flush;
	ns->destroy = &bs_destroy;
	if (bs != NULL){ 
		ns->stream_data = (char*)bs;
		return ns;
	}
	ns->errnr = OPEN_ERROR;
	return ns;
}

