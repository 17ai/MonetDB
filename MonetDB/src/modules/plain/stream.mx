@f stream
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files. 

@m
.MODULE stream;
.USE io;

    .ATOM stream = ptr;
    .END;

.COMMAND open_rstream( str filename ) : stream = stream_open_rstream;
	"open a file stream for reading"
.COMMAND open_wstream( str filename ) : stream = stream_open_wstream;
	"open a file stream for writing"
.COMMAND open_rastream( str filename ) : stream = stream_open_rastream; 
	"open ascii file stream for reading"
.COMMAND open_wastream( str filename ) : stream = stream_open_wastream; 
	"open ascii file stream for writing"

.COMMAND socket_rstream( int socket, str name ) : stream = 
	stream_socket_rstream; "open a socket stream for reading"
.COMMAND socket_wstream( int socket, str name ) : stream = 
	stream_socket_wstream; "open a socket stream for writing"
.COMMAND socket_rastream( int socket, str name ) : stream = 
	stream_socket_rastream; "open ascii socket stream for reading"
.COMMAND socket_wastream( int socket, str name ) : stream = 
	stream_socket_wastream; "open ascii socket stream for writing"

.COMMAND file_rstream( fstream file, str name ) : stream = 
	stream_file_rstream; "open a file stream for reading"
.COMMAND file_wstream( fstream file, str name ) : stream = 
	stream_file_wstream; "open a file stream for writing"
.COMMAND file_rastream( fstream file, str name ) : stream = 
	stream_file_rastream; "open ascii file stream for reading"
.COMMAND file_wastream( fstream file, str name ) : stream = 
	stream_file_wastream; "open ascii file stream for writing"

.COMMAND stream_write( stream s, str data ) = stream_write_string;
	"write data on the stream"

.COMMAND stream_close( stream s ) = stream_close_stream; 
	"close and destroy the stream s"

.END stream;
@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <gdk.h>
#include <ctype.h>

typedef struct stream {
	sht byteorder;
	char *filename;
	char *stream_data;
	int errnr;
	int (*read)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	int (*write)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	void (*close)( struct stream *s);
	char *(*error)( struct stream *s );
	void (*destroy)( struct stream *s );
} stream;

#include <blob.h>
#include <io.h>
#include "stream.proto.h"

stream *open_rstream( char *filename );
stream *open_wstream( char *filename );
/* open in ascii stream in read mode */
stream *open_rastream( char *filename ); 
/* open in ascii stream in write mode*/
stream *open_wastream( char *filename ); 

#ifdef HAVE_LIBZ
stream *open_gzrstream( char *filename );
stream *open_gzwstream( char *filename );
stream *open_gzrastream( char *filename );
stream *open_gzwastream( char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream *open_bzrstream( char *filename );
stream *open_bzwstream( char *filename );
stream *open_bzrastream( char *filename );
stream *open_bzwastream( char *filename );
#endif

stream *socket_rstream( int socket, char *name );
stream *socket_wstream( int socket, char *name );
stream *socket_rastream( int socket, char *name );
stream *socket_wastream( int socket, char *name );

stream *file_rstream( FILE *fp, char *name );
stream *file_wstream( FILE *fp, char *name );
stream *file_rastream( FILE *fp, char *name );
stream *file_wastream( FILE *fp, char *name );

#endif /*_STREAM_H_*/
@c
#include <gdk.h>
#include "stream.h"
#include <stdio.h>
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif

typedef enum steam_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;

#define EXT_LEN 4
static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void stream_destroy( stream *s){
	GDKfree(s->filename);
	GDKfree(s);
}

static stream *create_stream( char *filename ){
	stream *s = (stream*)GDKmalloc(sizeof(stream));
	s->byteorder = 1234;
	s->filename = GDKstrdup(filename); 
	s->stream_data = NULL;
	s->errnr = NO__ERROR;
	s->destroy = &stream_destroy;
	return s;
}

static char *stream_error( stream *s ){
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		sprintf(buf, "Error could not open file %s\n", s->filename );
		return GDKstrdup(buf);
	case READ_ERROR:
		sprintf(buf, "Error reading file %s\n", s->filename );
		return GDKstrdup(buf);
	case WRITE_ERROR:
		sprintf(buf, "Error writing file %s\n", s->filename );
		return GDKstrdup(buf);
	}
	return GDKstrdup("Unkonwn error");
}

static int stream_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fread( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static int stream_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fwrite( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static void stream_close( stream *s ){
	FILE *fp = (FILE*)s->stream_data;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
}
static stream *open_stream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
	  	stream *s = open_stream( filename, "rb");
		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_wstream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "wb");
		if (s->errnr == NO__ERROR)
	   		fwrite( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_rastream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "rb");
		return s;
	}
}
stream *open_wastream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "wb");
		return s;
	}
}


#ifdef HAVE_LIBZ
static int stream_gzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzread( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_gzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzwrite( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_gzclose( stream *s ){
	gzclose( (gzFile*)s->stream_data);
}
stream *open_gzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = &stream_gzread;
	s->write = &stream_gzwrite;
	s->close = &stream_gzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(sht));
	return s;
}
stream *open_gzwstream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(sht));
	return s;
}
stream *open_gzrastream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	return s;
}
stream *open_gzwastream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static int stream_bzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzread( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_bzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzwrite( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_bzclose( stream *s ){
	BZ2_bzclose( (BZFILE*)s->stream_data);
}
stream *open_bzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = &stream_bzread;
	s->write = &stream_bzwrite;
	s->close = &stream_bzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(sht) );
	return s;
}
stream *open_bzwstream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(sht) );
	return s;
}
stream *open_bzrastream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	return s;
}
stream *open_bzwastream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	return s;
}

stream *socket_rstream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "rb" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_wstream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "wb" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_rastream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "r" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_wastream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "w" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rstream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(sht), 
						1, (FILE*)s->stream_data);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

#endif

int stream_open_rstream( stream *S, str filename ){
	if ((*(stream**)S = open_rstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wstream( stream *S, str filename ){
	if ((*(stream**)S = open_wstream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_rastream( stream *S, str filename ){
	if ((*(stream**)S = open_rastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_open_wastream( stream *S, str filename ){
	if ((*(stream**)S = open_wastream( filename )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rstream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wstream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wstream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_rastream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_rastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_socket_wastream( stream *S, int *socket, str name ){
	if ((*(stream**)S = socket_wastream( *socket, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_rstream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_rstream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_wstream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_wstream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_rastream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_rastream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}
int stream_file_wastream( stream *S, fstream *file, str name ){
	if ((*(stream**)S = file_wastream( *file, name )) == NULL){
		return GDK_FAIL; 
	} else {
		return GDK_SUCCEED;
	}
}

int stream_write_string( stream *S, str data ){
	stream *s = *(stream**)S;
	s->write( s, data, 1, strlen(data));
	return GDK_SUCCEED;
}

int stream_close_stream( stream *S ){
	stream *s = *(stream**)S;
	s->close( s );
	s->destroy( s );
	return GDK_SUCCEED;
}
