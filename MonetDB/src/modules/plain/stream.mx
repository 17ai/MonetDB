@f stream
@a Niels Nes
@* An simple interface to streams 
This interface can be used to open 'non compressed, gzipped, bz2zipped' 
data files. 

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h 
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 * 
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is 
 * required for proper conversion on different byte order platforms.
 */

#include <ctype.h>
#include <stdio.h>

typedef struct stream {
	short byteorder;
	char *filename;
	char *stream_data;
	int errnr;
	int (*read)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	int (*write)( struct stream *s, char *buf, size_t elmsize, size_t cnt );
	void (*close)( struct stream *s);
	char *(*error)( struct stream *s );
	void (*destroy)( struct stream *s );
} stream;

stream *open_rstream( char *filename );
stream *open_wstream( char *filename );
/* open in ascii stream in read mode */
stream *open_rastream( char *filename ); 
/* open in ascii stream in write mode*/
stream *open_wastream( char *filename ); 

#ifdef HAVE_LIBZ
stream *open_gzrstream( char *filename );
stream *open_gzwstream( char *filename );
stream *open_gzrastream( char *filename );
stream *open_gzwastream( char *filename );
#endif

#ifdef HAVE_LIBBZ2
stream *open_bzrstream( char *filename );
stream *open_bzwstream( char *filename );
stream *open_bzrastream( char *filename );
stream *open_bzwastream( char *filename );
#endif

stream *socket_rstream( int socket, char *name );
stream *socket_wstream( int socket, char *name );
stream *socket_rastream( int socket, char *name );
stream *socket_wastream( int socket, char *name );

stream *file_rstream( FILE *fp, char *name );
stream *file_wstream( FILE *fp, char *name );
stream *file_rastream( FILE *fp, char *name );
stream *file_wastream( FILE *fp, char *name );

#endif /*_STREAM_H_*/
@c
#include <config.h>
#include "stream.h"
#include <string.h> 
#ifdef HAVE_NETDB_H
# include <netinet/in.h> 
# include <netdb.h> 
#endif
#ifdef HAVE_LIBZ
	#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
	#include <bzlib.h>
#endif

typedef enum steam_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR, 
	WRITE_ERROR
}stream_errors;

#define EXT_LEN 4
static void get_extention( char *file, char *ext)
{
   	int j = 0;
	char *ext_start = strrchr( file, '.' );

	if (ext_start){
	    ext_start++;
            for (j = 0; j < EXT_LEN-1 && *ext_start; j++, ext_start++ )
                ext[j] = tolower(*ext_start);
        }
        ext[j] = '\0';
}

static void stream_destroy( stream *s){
	free(s->filename);
	free(s);
}

static stream *create_stream( char *filename ){
	stream *s = (stream*)malloc(sizeof(stream));
	s->byteorder = 1234;
	s->filename = strdup(filename); 
	s->stream_data = NULL;
	s->errnr = NO__ERROR;
	s->destroy = &stream_destroy;
	return s;
}

static char *stream_error( stream *s ){
	char buf [BUFSIZ];
	switch(s->errnr){
	case OPEN_ERROR:
		sprintf(buf, "Error could not open file %s\n", s->filename );
		return strdup(buf);
	case READ_ERROR:
		sprintf(buf, "Error reading file %s\n", s->filename );
		return strdup(buf);
	case WRITE_ERROR:
		sprintf(buf, "Error writing file %s\n", s->filename );
		return strdup(buf);
	}
	return strdup("Unkonwn error");
}

static int stream_read( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fread( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static int stream_write( stream *s, char *buf, size_t elmsize, size_t cnt ){
	return fwrite( buf, elmsize, cnt, (FILE*)s->stream_data);
}
static void stream_close( stream *s ){
	FILE *fp = (FILE*)s->stream_data;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose( fp );
}
static stream *open_stream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	FILE *fp = fopen( filename, flags );

	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *open_rstream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrstream( filename );
	} else 
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
	  	stream *s = open_stream( filename, "rb");
		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_wstream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwstream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwstream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "wb");
		if (s->errnr == NO__ERROR)
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
}
stream *open_rastream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzrastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzrastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "rb");
		return s;
	}
}
stream *open_wastream( char *filename ){
  	char    ext[EXT_LEN];

  	get_extention(filename, ext);

#ifdef HAVE_LIBZ
  	if (!strcmp(ext,"gz" )){
		return open_gzwastream( filename );
	} else
#else
  	if (!strcmp(ext,"gz" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
#ifdef HAVE_LIBBZ2
	if (!strcmp(ext,"bz2" )){
		return open_bzwastream( filename );
	} else 
#else
	if (!strcmp(ext,"bz2" )){
		stream *s = create_stream(filename);
		s->errnr = OPEN_ERROR;
		return NULL;
	} 
#endif
	{
		stream *s = open_stream( filename, "wb");
		return s;
	}
}


#ifdef HAVE_LIBZ
static int stream_gzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzread( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_gzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = gzwrite( (gzFile*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_gzclose( stream *s ){
	gzclose( (gzFile*)s->stream_data);
}
stream *open_gzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	gzFile *fp = gzopen( filename, flags );
	s->read  = &stream_gzread;
	s->write = &stream_gzwrite;
	s->close = &stream_gzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_gzrstream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	if (s->errnr == NO__ERROR)
	   gzread( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzwstream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	if (s->errnr == NO__ERROR)
	   gzwrite( (gzFile*)s->stream_data, (char*)&s->byteorder, sizeof(short));
	return s;
}
stream *open_gzrastream( char *filename ){
	stream *s = open_gzstream( filename, "rb");
	return s;
}
stream *open_gzwastream( char *filename ){
	stream *s = open_gzstream( filename, "wb");
	return s;
}
#endif

#ifdef HAVE_LIBBZ2
static int stream_bzread( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzread( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static int stream_bzwrite( stream *s, char *buf, size_t elmsize, size_t cnt ){
	int size = elmsize*cnt;
	size = BZ2_bzwrite( (BZFILE*)s->stream_data, buf, size );
	if (size) return size/elmsize;
	return 0;
}
static void stream_bzclose( stream *s ){
	BZ2_bzclose( (BZFILE*)s->stream_data);
}
stream *open_bzstream( char *filename, char *flags ){
	stream *s = create_stream(filename);
	BZFILE *fp = BZ2_bzopen( filename, flags );
	s->read  = &stream_bzread;
	s->write = &stream_bzwrite;
	s->close = &stream_bzclose;
	s->error = &stream_error;
	s->destroy = &stream_destroy;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
stream *open_bzrstream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	if (s->errnr == NO__ERROR) BZ2_bzread( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzwstream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	if (s->errnr == NO__ERROR) BZ2_bzwrite( 
		(BZFILE*)s->stream_data, (char*)&s->byteorder, sizeof(short) );
	return s;
}
stream *open_bzrastream( char *filename ){
	stream *s = open_bzstream( filename, "rb");
	return s;
}
stream *open_bzwastream( char *filename ){
	stream *s = open_bzstream( filename, "wb");
	return s;
}
#endif

stream *socket_rstream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "rb" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_wstream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "wb" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_rastream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "r" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *socket_wastream( int socket, char *name ){
	stream *s = create_stream(name);
	FILE *fp = fdopen( socket, "w" );
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rstream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR)
	   		fread( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wstream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;

		if (s->errnr == NO__ERROR){
	   		fwrite( (char*)&s->byteorder, sizeof(short), 
						1, (FILE*)s->stream_data);
		}
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_rastream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}

stream *file_wastream( FILE *fp, char *name ){
	stream *s = create_stream(name);
	s->read  = &stream_read;
	s->write = &stream_write;
	s->close = &stream_close;
	s->error = &stream_error;
	if (fp != NULL){ 
		s->stream_data = (char*)fp;
		return s;
	}
	s->errnr = OPEN_ERROR;
	return s;
}
