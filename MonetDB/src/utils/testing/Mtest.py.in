#!/usr/bin/env python

#TODO:
#=====
# - check all TODO's below
# - add Mapprove.py
# - tidy -up HTML-generation by "keeping in mind" during testing, 
#   which OUT/ERR differ or not and which tests were skipped.
#   dump HTML-stuff only at end
#   print an ascii summary at end, too
# - if no diffs, but warnings, say so at end
# - produce, keep & reference LOG
# - add a "grep-like" function and replace "inlined" grep
#   contains(<file>,<string>)
# - replace pure boldface (<B>) by red-boldface
#   (also in Mdiff)
# - do multi-level prompting?
# - solve chdir - link - getcwd problem
#   (e.g., implement own directory stack)
# - normalize all path's used
# - remove one of milM, milS

import os
import sys
import getopt
import fileinput
import popen2
import shutil
import re
import regsub
import string
import random
import time
#import signal
#import getpass

STDOUT = sys.stdout
STDERR = sys.stdout	# err

def Usage() :
	print('''

Usage:  %s [options] ( [<dir>] [<tests>] | [<dirs>] )

 -I<exp> : (optional) ignore lines matching <exp> during diff (default: -I'^#')
 -c<num> : (optional) use <num> lines of context during diff (default: -c1)
 -a<num> : (optional) accuracy for diff: 0=lines, 1=words, 2=chars (default: -a1)
 -t<sec> : (optional) timeout: kill (hanging) M{server,client,createdb,destroydb,load}
                       after <sec> seconds; -t0 means no timeout (default: -t600)
 -r      : (optional) proceed in subdirectories as well (implies 'All`)

 --monetrc=<path>
         : (optional) location of .monet.conf file; default is the first found of
			%s.monet.Mtest.conf                        
			<TSTSRCBASE>%s.monet.Mtest.conf            
			%s.monet.Mtest.conf                               
			%smonet.Mtest.conf                                                                      

 --TSTSRCBASE=<abspath>
 --TSTBLDBASE=<abspath>
 --TSTTRGBASE=<abspath>
         : (optional) overrule defaults:
			TSTSRCBASE=@MONET_SOURCE@
			TSTBLDBASE=@MONET_BUILD@
			TSTTRGBASE=@MONET_PREFIX@

 <dir>   : (optional) if present, %s behaves as if called in <dir>
 <tests> : (optional) list of tests to be processed; if none or 'All` is given,
                       all tests listed in 'Tests/All` are processed
                       (defaults to 'All` if -r is used)
 <dirs>  : (optional) list of directories to be processed; if present, %s processes
                       'All` tests in each directory of <dirs>; -r may be used also

         See  %sREADME  for details about  %s.

''' % (THISFILE, os.getcwd()+os.sep, os.sep, os.environ['HOME']+os.sep, path("@MONET_PREFIX@/share/Monet/"), THISFILE, THISFILE, path("@MONET_SOURCE@/src/utils/testing/"), THISFILE))

#TODO:
#class TimeoutError:
#	def __init__(self, text):
#		self.text = text
#	def __str__(self):
#		return self.text
#
#def AlarmHandler(signum, frame):
#	raise TimeoutError, "Timeout"

def ErrMsg(TEXT) :
	STDOUT.flush()
	STDERR.write("\n"+THISFILE+":  ERROR:  %s\n\n" % TEXT)
	STDERR.flush()

def ErrXit(TEXT) :
	ErrMsg(TEXT)
	sys.exit(1)

def Warn(TEXT) :
	STDOUT.flush()
	STDERR.write("\n"+THISFILE+"  Warning:  %s\n\n" % TEXT)
	STDERR.flush()

def startswith(str,pre) :
	return not ((len(str) < len(pre)) or (str[:len(pre)] != pre))

def path(str) :
	return regsub.gsub("/",os.sep,str)

def url(str) :
	if os.name == "nt":
		return regsub.gsub("\\\\","/",str)
	else:
		return regsub.gsub(os.sep,"/",str)

def CreateHtmlIndex (env) :
	TSTDIR=env['TSTDIR']
	TSTTRGBASE=env['TSTTRGBASE']
	TSTTRGDIR=env['TSTTRGDIR']

	if TSTDIR:
		INDEX=".index"
	else:
		INDEX="index"

	if os.path.isfile(TSTTRGDIR+os.sep+INDEX+".head.html"):
		BACK = os.getcwd()
		os.chdir(TSTTRGDIR)

		f = open(INDEX+".head.html","r")
		BODY = f.readlines()
		f.close()
		f = open(INDEX+".head.html","w")
		f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=3>
<TR>
<TH ALIGN=CENTER><FONT FACE='helvetica, arial'>
""")
		if TSTDIR:
			f.write("""
<A HREF='"""+URLPREFIX+url(TSTDIR)+"/Tests"+URLSUFFIX_D+"""' TARGET='"""+OSVER+"_"+TSTDIR+"""_body'><FONT COLOR=#000000>"""+TSTDIR+"""</FONT></A><BR>
""")
			#TODO ?
			#<A HREF='.$THISFILE.Slave.Log.OutErr' TARGET='${OSVER}_${TSTDIR}_body'><FONT COLOR=#000000><I>(log)</I></FONT></A>
		else:
			f.write("<FONT COLOR=#000000>"+OSVER+"</FONT>")
			#TODO ?
			#f.write("""
			#<A HREF='.$THISFILE.Master.Log.OutErr' TARGET='${OSVER}_${TSTDIR}_body'><FONT COLOR=#000000>$OSVER</FONT></A>
			#""")
		f.write("</FONT></TH>\n")
		for l in BODY:
			f.write(l)
		f.write("</TR>\n")
		f.write("</TABLE>\n")
		f.write("</CENTER>\n")
		f.write("</BODY>\n")
		f.write("</HTML>\n")
		f.close()

		if TSTDIR:
			ROWS="72"
		else:
			ROWS="54"
		f = open(INDEX+".html","w")
		f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<FRAMESET ROWS='"""+ROWS+""",*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='"""+INDEX+""".head.html' SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"""_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='"""+url(env['_'+TSTDIR+'_BODY_'][0])+"""' SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"""_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""")
		f.close()
		env['_'+TSTDIR+'_BODY_'] = ["",0]
		os.chdir(BACK)

def CreateTstWhatXhtml (env, TST, stableWHAT, EXT) :
	WHAT = stableWHAT[7:11]
	TSTDIR    = env['TSTDIR']
	TSTSRCDIR = env['TSTSRCDIR']

	testT = re.compile("^/"+TST+EXT+"/([^/]*)/")
	testS = re.compile("^/"+TST+stableWHAT+"/([^/]*)/")
	REVt="?"
	REVs="?"
	for l in fileinput.input(TSTSRCDIR+os.sep+"CVS"+os.sep+"Entries"):
		mT = testT.match(l)
		if mT:
			REVt=mT.group(1)
		mS = testS.match(l)
		if mS:
			REVs=mS.group(1)
	test = re.compile("^<TR.*><TH.*>No differences.</TH></TR>$")
	DIFF = "<B>Differences</B>"
	for l in fileinput.input(TST+WHAT+".diff.html"):
		if test.match(l):
			DIFF = "No differences"
	SYSTEM = OSVER+":"
	if COMPILER:
		SYSTEM = COMPILER+", "+SYSTEM

	f = open("."+TST+WHAT+".html","w")
	f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<FRAMESET ROWS='42,*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='."""+TST+WHAT+""".head.html' SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='""" +TST+WHAT+""".diff.html' SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""")
	f.close()
	f = open("."+TST+WHAT+".head.html","w")
	f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<FONT FACE='helvetica, arial'>
"""+SYSTEM+"""
<A HREF='"""+TST+WHAT+""".diff.html' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>"""+DIFF+"""</A>
between
<A HREF='"""+TST+stableWHAT+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>"""+stableWHAT[1:]+" (r"+REVs+""")</A>
and
<A HREF='"""+TST+".test"+WHAT+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>test"""+WHAT+"""</A>
of
<A HREF='"""+TST+EXT+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>"""+TST+EXT+" (r"+REVt+""")</A>
in
<A HREF='./' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>"""+TSTDIR+"""</A>
(<A HREF='"""+URLPREFIX+url(TSTDIR)+"/Tests"+URLSUFFIX_D+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>CVS</A>,
 <A HREF='"""+url(env['RELSRCDIR'])+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>SRC</A>""")
	for d in env['RELBLDDIR'], os.path.dirname(env['RELBLDDIR']), env['RELBLDBASE']:
		if os.path.isdir(d):
			f.write(""",
 <A HREF='"""+url(d)+"""' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>BLD</A>""")
	f.write(""").
</FONT>
</CENTER>
</BODY>
</HTML>
""")
	f.close()
#TODO?
# <A HREF='.Mtest.Slave.Log.OutErr' TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>LOG</A>).

def CreateSrcIndex (env, TST, EXT) :
	TSTSRCDIR = env['TSTSRCDIR']
	TSTDIR    = env['TSTDIR']

	f = open("."+TST+".src.index.html","w")
	f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<FRAMESET ROWS='54,*' FRAMEBORDER=yes BORDER=1 BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='."""+TST+""".src.index.head.html' SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"_"+TST+"""_head' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
<FRAME SRC='"""+URLPREFIX+url(TSTDIR)+"/Tests/"+TST+EXT+URLSUFFIX_F+"""'
  SCROLLING=auto NAME='"""+OSVER+"_"+TSTDIR+"_"+TST+"""_body' FRAMEBORDER=yes BORDERCOLOR=#ffffff MARGINWIDTH=0 MARGINHEIGHT=0>
</FRAMESET>
</HTML>
""")
	f.close()
	f = open("."+TST+".src.index.head.html","w")
	f.write("""
<HTML>
<HEAD><TITLE>"""+HTMLTITLE+"""</TITLE></HEAD>
<BODY BGCOLOR=#ffffff TEXT=#000000 LINK=#00AA00 VLINK=#005500 ALINK=#00ff00>
<CENTER>
<TABLE ALIGN=ABSCENTER BORDER=1 CELLSPACING=0 CELLPADDING=3>
<TR>
<TH ALIGN=CENTER><FONT FACE='helvetica, arial'>"""+TST+"""</FONT></TH>
""")
	for s in os.listdir(TSTSRCDIR):
		if len(s) >= len(TST)  and  s[:len(TST)] == TST:
			f.write("""
<TD><FONT FACE='helvetica, arial'>
  <A HREF='"""+URLPREFIX+url(TSTDIR)+"/Tests/"+s+URLSUFFIX_F+"""'
    TARGET='"""+OSVER+"_"+TSTDIR+"_"+TST+"_body'>"+s+"""</A></FONT></TD>
""")
	f.write("""
</TR>
</TABLE>
</CENTER>
</BODY>
</HTML>
""")
	f.close()

def AddHref (TSTDIR, TST, WHAT, diff) :
	STRING = "<A HREF='."+TST+WHAT+".html' TARGET='"+OSVER+"_"+TSTDIR+"_body'>"+WHAT[1:]+"</A>"
	if diff:
		return "<B>"+STRING+"</B>"
	else:
		return "("+STRING+")"

def AddTstToHtmlIndex (env, TST, STABLEout, STABLEerr, EXT) :
	TSTDIR = env['TSTDIR']

	CreateTstWhatXhtml(env, TST, STABLEout, EXT)
	CreateTstWhatXhtml(env, TST, STABLEerr, EXT)

	f = open(".index.head.html","a")
	f.write("<TD ALIGN=CENTER><FONT FACE='helvetica, arial'><A HREF='."+TST+".src.index.html' TARGET='"+OSVER+"_"+TSTDIR+"_body'><FONT COLOR=#000000>")
	test = re.compile("^<TR.*><TH.*>No differences.</TH></TR>$")
	o = e = 1
	for l in fileinput.input(TST+".out.diff.html"):
		if test.match(l):
			o = 0
	for l in fileinput.input(TST+".err.diff.html"):
		if test.match(l):
			e = 0
	if o or e:
		f.write("<B>"+TST+"</B>")
	else:
		f.write(TST)
	f.write("</FONT></A><BR>")
	f.write(AddHref(TSTDIR, TST, ".out", o))
	f.write("&nbsp;|&nbsp;")
	f.write(AddHref(TSTDIR, TST, ".err", e))
	f.write("</FONT></TD>\n")
	f.close()
	if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
	   not env['_'+TSTDIR+'_BODY_'][0]  or  \
	   ( (not env['_'+TSTDIR+'_BODY_'][1])  and  (o or e) ):
		if e and not o:
			env['_'+TSTDIR+'_BODY_'] = ["."+TST+".err.html", e]
		else:
			env['_'+TSTDIR+'_BODY_'] = ["."+TST+".out.html", o]

	CreateSrcIndex(env, TST, EXT)

def AddSubToHtmlIndex (env, TSTDIR) :
	TSTTRGBASE = env['TSTTRGBASE']

	if os.path.isfile(TSTTRGBASE+os.sep+"Tests"+os.sep+TSTDIR+os.sep+".index.html"):
		BACK = os.getcwd()
		os.chdir(TSTTRGBASE+os.sep+"Tests")
		f = open("index.head.html","a")
		f.write("<TD><FONT FACE='helvetica, arial'>")
		STRING = "<A HREF='"+url(TSTDIR)+"/.index.html' TARGET='"+OSVER+"__body'>"+TSTDIR+"</A>"
		test = re.compile("^.*><B>.*</B><.*$")
		diff = 0
		for l in fileinput.input(TSTDIR+os.sep+".index.head.html"):
			if test.match(l):
				diff = 1
		if diff:
			f.write("<B>"+STRING+"</B>")
		else:
			f.write("("+STRING+")")
		f.write("</FONT></TD>\n")
		f.close()
		if not env.has_key('__BODY_')  or  \
		   not env['__BODY_'][0]  or  \
		   ( (not env['__BODY_'][1])  and  diff ):
			env['__BODY_'] = [TSTDIR+"/.index.html", diff]
		os.chdir(BACK)

def SkipTest(env, TST, EXT, REASON) :
	TSTDIR = env['TSTDIR']
	TEXT="Skipping test "+TST+EXT+" "+REASON
	Warn(TEXT)
	f = open("."+TST+".SKIPPED","w")
	f.write("\n"+THISFILE+"  Warning:  %s\n\n" % TEXT)
	f.close()
	f = open(".index.head.html","a")
	f.write("""
<TD ALIGN=CENTER><FONT FACE='helvetica, arial'><A HREF='."""+TST+""".src.index.html' TARGET='"""+OSVER+"_"+TSTDIR+"""_body'><FONT COLOR=#000000>
"""+TST+"</FONT></A><BR><A HREF='."+TST+".SKIPPED' TARGET='"+OSVER+"_"+TSTDIR+"""_body'>(skipped)</A></FONT></TD>
""")
	if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
	   not env['_'+TSTDIR+'_BODY_'][0]  or  \
	   not env['_'+TSTDIR+'_BODY_'][1]:
		env['_'+TSTDIR+'_BODY_'] = ["."+TST+".SKIPPED", 1]
	CreateSrcIndex(env, TST, EXT)

def find_test_dirs(thisdir) :
	testdirs = []
	thisdir = os.path.abspath(thisdir)
	dirnme = os.path.basename(thisdir)
	dirlst = os.listdir(thisdir)
	if dirnme == "Tests"  and  "All" in dirlst  and  os.path.isfile(thisdir+os.sep+"All"):
		testdirs.append(os.path.dirname(thisdir))
	for d in dirlst:
		d = thisdir+os.sep+d
		if os.path.isdir(d):
			testdirs = testdirs + find_test_dirs(d)
	return testdirs

def runtests(env, testdir, testlist) :
	TSTSRCBASE = env['TSTSRCBASE']
	if testdir == TSTSRCBASE:
		TSTDIR = os.curdir
	else:
		TSTDIR = testdir[len(TSTSRCBASE+os.sep):]
	TSTSRCDIR = testdir+os.sep+"Tests"
	TSTBLDDIR = env['TSTBLDBASE']+os.sep+TSTDIR+"Tests"
	TSTTRGDIR = env['TSTTRGBASE']+os.sep+"Tests"+os.sep+TSTDIR
	if os.name == "nt":
		TSTDB = "Tests_"+regsub.gsub("\\\\","_",TSTDIR)
	else:
		TSTDB = "Tests_"+regsub.gsub(os.sep,"_",TSTDIR)
	if not testlist:
		for tst in fileinput.input(TSTSRCDIR+os.sep+"All"):
			tst = string.strip(tst)
			if tst  and  tst[0] != "#":
				testlist.append(tst)
	if not testlist:
		Warn("No tests found in '"+TSTSRCDIR+"`; skipping directory!")
		return
	if not os.path.exists(TSTTRGDIR):
		#TODO: set mode to umask
		os.makedirs(TSTTRGDIR)
	env['TSTDB']     = TSTDB
	env['TSTDIR']    = TSTDIR
	env['TSTSRCDIR'] = TSTSRCDIR
	env['TSTBLDDIR'] = TSTBLDDIR
	env['TSTTRGDIR'] = TSTTRGDIR
	env['RELSRCDIR'] = ((os.pardir+os.sep)*(len(string.split(TSTDIR,os.sep))+1))+env['RELSRCBASE']+os.sep+TSTDIR+os.sep+"Tests"
	env['RELBLDDIR'] = ((os.pardir+os.sep)*(len(string.split(TSTDIR,os.sep))+1))+env['RELBLDBASE']+os.sep+TSTDIR+os.sep+"Tests"
	os.environ['TSTDB']     = TSTDB
	os.environ['TSTDIR']    = TSTDIR
	os.environ['TSTSRCDIR'] = TSTSRCDIR
	os.environ['TSTBLDDIR'] = TSTBLDDIR
	os.environ['TSTTRGDIR'] = TSTTRGDIR
	os.environ['RELSRCDIR'] = env['RELSRCDIR']
	os.environ['RELBLDDIR'] = env['RELBLDDIR']
	if os.path.exists(env['GDK_DBFARM']+os.sep+TSTDB):
		if Check(env['exe']['Mdestroydb'][1]+" -db "+TSTDB, ""):
			Warn("database '"+TSTDB+"` exists, but destroying it failed; skipping tests in '"+TSTSRCDIR+"`!")
			#TODO:
			# add "something" to HTML output
			return
	if Check(env['exe']['Mcreatedb'][1] +" -db "+TSTDB, ""):
		Warn("creating database '"+TSTDB+" failed; skipping tests in '"+TSTSRCDIR+"`!")
		#TODO:
		# add "something" to HTML output
		return
	for t in testlist:
		runtest(env, t)
	CreateHtmlIndex(env)
	AddSubToHtmlIndex(env, TSTDIR)

def isexecutable(TST) :
	if   os.name == "nt":
		for ext in ".exe", ".com", ".bat", ".cmd":
			if os.path.isfile(TST+ext):
				return [ 1, ext ]
	elif os.name == "posix":
		#TODO:
		# check with "file", and set executable
		if os.path.isfile(TST)  and  os.access(TST,os.X_OK):
			return [ 1, "" ]
	#TODO:
	#else:
		# ???
	return [ 0, "" ]

def GetBitsAndMods(env) :
	pOut,pIn,pErr = popen2.popen3(env['exe']['Mserver'][1]+" -db Tests")
	pIn.write('''
printf("\\n");x:="";sunion([~monet_mod_nme],[~view_modules]).reverse.kunique@batloop{printf("%s'%s'",x,$h);x:=",";}printf("\\n");quit;
''')
	pIn.close()
	qOut = pOut.readlines()
	qErr = pErr.readlines()
	pOut.close()
	pErr.close()
	test = re.compile("^# compiled for .*/([63][42]bit)")
	if qOut:
		for l in qOut:
			m = test.match(l)
			if m:
				env['TST_BITS'] = m.group(1)
				os.environ['TST_BITS'] = env['TST_BITS']
		env['TST_MODS'] = eval(qOut[-1])
	else:
		Warn("No output from Mserver when checking for Bits & Modules!?")
		if qErr:
			STDERR.writelines(qErr)
			STDERR.write("\n")
			STDERR.flush()
		env['TST_BITS'] = ""
		env['TST_MODS'] = []
	os.environ['TST_MODS'] = str(env['TST_MODS'])
	return env['TST_BITS'], env['TST_MODS']

def CheckMods(env, TST, EXT) :
	missing = []
	if os.path.isfile(TST+".modules"):
		for m in fileinput.input(TST+".modules"):
			m = string.strip(m)
			if m  and  m[0] != "#"  and  m not in env['TST_MODS']:
					missing.append(m)
	if EXT == ".milC":
		for m in "unix", "str", "mapi":
			if m not in env['TST_MODS']:
				missing.append(m)
	return missing

def CheckBATs(env, TST, TSTDB) :
	pOut,pIn,pErr = popen2.popen3(env['exe']['Mserver'][1]+" -db "+TSTDB)
	pIn.write('''
printf("\\n");x:="";view_bbp_name@batloop{printf("%s'%s'",x,$t);x:=",";}printf("\\n");quit;
''')
	pIn.close()
	qOut = pOut.readlines()
	qErr = pErr.readlines()
	pOut.close()
	pErr.close()
	if qOut:
		TST_BATS = eval(qOut[-1])
	else:
		Warn("No output from Mserver when checking for Bats!?")
		if qErr:
			STDERR.writelines(qErr)
			STDERR.write("\n")
			STDERR.flush()
		TST_BATS = []

	missing = []
	if os.path.isfile(TST+".BATs"):
		for b in fileinput.input(TST+".BATs"):
			b = string.strip(b)
			if b  and  b[0] != "#"  and  b not in TST_BATS:
					missing.append(b)
	return missing

def runtest(env, TST) :
	TSTDB = env['TSTDB']
	TSTDIR  = env['TSTDIR']
	TSTSRCDIR = env['TSTSRCDIR']
	TSTTRGDIR = env['TSTTRGDIR']
	os.chdir(TSTSRCDIR)

	EXT = "" ; CALL = ""
	x = isexecutable(TST)
	if   x[0]:
		EXT = x[1]    ; CALL = "other"
	elif os.path.isfile(TST+".py")    or  os.path.isfile(TST+".py.src"):
		EXT = ".py"   ; CALL = "python"
	elif os.path.isfile(TST+".milM")  or  os.path.isfile(TST+".milM.src"):
		EXT = ".milM" ; CALL = "milM"
	elif os.path.isfile(TST+".milS")  or  os.path.isfile(TST+".milS.src"):
		EXT = ".milS" ; CALL = "milS"
	elif os.path.isfile(TST+".milC")  or  os.path.isfile(TST+".milM.src"):
		EXT = ".milC" ; CALL = "milC"
	elif os.path.isfile(TST+"_s00.milM"):
		EXT = ".milM" ; CALL = "milMXs"
	elif os.path.isfile(TST+"_s00.milS"):
		EXT = ".milS" ; CALL = "milSXs"
	elif os.path.isfile(TST+"_s00.milC"):
		EXT = ".milC" ; CALL = "milCXs"
	elif os.path.isfile(TST+"_p00.milC"):
		EXT = ".milC" ; CALL = "milCXp"
		#TODO:
		#elif [ -f "$TST.java"       ] ; then  EXT="java" ; CALL="Java   "+TST+" "+EXT
		#elif [ -f "${TST}_s00.java" ] ; then  EXT="java" ; CALL="JavaXs "+TST+" "+EXT
		#elif [ -f "${TST}_p00.java" ] ; then  EXT="java" ; CALL="JavaXp "+TST+" "+EXT
		#elif [ -f "$TST.odmg"       ] ; then  EXT="odmg" ; CALL="odmg   "+TST+" "+EXT
	else:
		EXT = ""      ; CALL = ""
		if os.name == "nt":
			ErrMsg("test missing: '"+TSTSRCDIR+os.sep+TST+".(exe|com|bat|cmd|py|milM|milS|milC)`")
			#TODO:
			#elif os.name == "posix":
		else:
			ErrMsg("test missing: '"+TSTSRCDIR+os.sep+TST+"[.py|.milM|.milS|.milC]`")
		return

	MissingMods = CheckMods(env, TST, EXT)
	MissingBATs = CheckBATs(env, TST, TSTDB)

	os.chdir(TSTTRGDIR)

	NotOnNT = ["src/modules/plain/salgebra", "tests/by_Peter/tst_priv", "src/modules/plain/tcpip1", "src/modules/plain/tcpip2"]
	ReqMshdn = [".milC"]
	if   os.name == "nt"  and  url(TSTDIR)+"/"+TST in NotOnNT:
		SkipTest(env, TST, EXT, "as it currently crashes/hangs on NT.")
	elif EXT in ReqMshdn  and  not env['exe']['Mshutdown'][0]:
		SkipTest(env, TST, EXT, "as Mshutdown is not available.")
	elif EXT == ".milC" and  not env['exe']['MapiClient'][0]:
		SkipTest(env, TST, EXT, "as MapiClient is not available.")
	elif EXT == ".milC" and  not os.path.isfile(env['MONET_PREFIX']+regsub.gsub("/",os.sep,"/share/Monet/mapi.mil")):
		SkipTest(env, TST, EXT, "as "+env['MONET_PREFIX']+regsub.gsub("/",os.sep,"/share/Monet/mapi.mil")+" is not available.")
	elif EXT == ".py"   and  not env['exe']['python'][0]:
		SkipTest(env, TST, EXT, "as python is not available.")
		#TODO:
		#elif EXT == ".milC":
		#SkipTest(env, TST, EXT, "as MapiClient-tests are temporary not supported by Mtest.")
	elif EXT == ".milC"  and  os.name == "nt":
		SkipTest(env, TST, EXT, "as MapiClient is currently not working on WindowsNT.")
		#TODO:
		#elif [ "$EXT" = "java"  -a  ! "`type -path java`" ] ; then
		#SkipTest(env, TST, EXT, "as java is not in $PATH.")
	elif MissingMods:
		SkipTest(env, TST, EXT, "as modules '"+str(MissingMods)+"` are missing.")
	elif MissingBATs:
		SkipTest(env, TST, EXT, "as BATs '"+str(MissingBATs)+"` are missing in database '"+TSTDB+"`.")
	elif CALL == "milCXp":
		SkipTest(env, TST, EXT, "as multiple clients in parallel are currently not supported by Mtest.")
	else:
		test = re.compile("^"+TST+"(|\..*|_[sp][0-9][0-9]\..*)$")
		for f in os.listdir(TSTSRCDIR):
			if test.match(f):
				shutil.copy(TSTSRCDIR+os.sep+f,TSTTRGDIR)
		if os.path.isfile(TST+EXT+".src")  and not os.path.isfile(TST+EXT):
			f = open(TST+EXT+".src","r")
			TSTSRC = os.path.expandvars(regsub.gsub("/",os.sep,string.strip(f.readline())))
			f.close()
			if os.path.isfile(TSTSRC):
				shutil.copy(TSTSRC,TST+EXT)
			else:
				SkipTest(env, TST, EXT+".src", "as source file '"+TSTSRC+"` is missing.")
				return

		BITS = env['TST_BITS']
		for e in "."+OSVER+"."+BITS , "."+OSVER , "."+OS , "":
			E = ".stable.out"+e
			if os.path.isfile(TST+E)  or  not e:
				STABLEout = E
				break
		if not os.path.isfile(TST+STABLEout):
			open(TST+STABLEout,"w").close()
		for e in "."+OSVER+"."+BITS , "."+OSVER , "."+OS , "":
			E = ".stable.err"+e
			if os.path.isfile(TST+E)  or  not e:
				STABLEerr = E
				break
		if not os.path.isfile(TST+STABLEerr):
			open(TST+STABLEerr,"w").close()

		if os.path.isfile(TST+".prelude"):
			PRELUDE = TST+".prelude"
			if EXT == ".milC":
				PRELUDE = "-prelude "+PRELUDE
		else:
			PRELUDE = ""
		
		TIMEOUTED = "Mtimeout"
		for v in env['exe'].keys():
			TIMEOUTED = TIMEOUTED+"|"+string.upper(v)
		test = re.compile("^.*("+TIMEOUTED+").*$")
		TIMEOUT = par['TIMEOUT']
		XTIMEOUT = 0
		if   CALL == "other"  or  CALL == "python":
			XTIMEOUT = XTIMEOUT + 60
			for l in fileinput.input(TST+EXT):
				if test.match(l):
					XTIMEOUT = XTIMEOUT + TIMEOUT
		elif CALL in ["milMXs", "milSXs", "milCXs"]:
			test = re.compile("^"+TST+"_s[0-9][0-9]"+EXT+"$")
			d = os.listdir(os.getcwd())
			for f in d:
				if test.match(f):
					XTIMEOUT = XTIMEOUT + TIMEOUT
		elif CALL in ["milM", "milS", "milC"]:
			XTIMEOUT = XTIMEOUT + TIMEOUT
		if  CALL in ["milC", "milCXs"]:
			XTIMEOUT = XTIMEOUT + TIMEOUT + 60

		ME = ""
		ATJOB = ""
		if os.name != "nt":
			ME = str(os.getpid())
			WAIT = str(int(XTIMEOUT / 60) + 2)
			FILES = TSTTRGDIR+os.sep+TST+" "+TSTTRGDIR+os.sep+TST+".*"
			for f in ["bat/\\*", '.gdk_lock']:
				FILES = FILES+" "+env['GDK_DBFARM']+os.sep+TSTDB+os.sep+path(f)
			WHAT = THISPATH+os.sep+"MkillUsers -l"+ME+" "+FILES+" \\>"+TSTTRGDIR+os.sep+TST+".KILLED.out 2\\>"+TSTTRGDIR+os.sep+TST+".KILLED.err"
			WHEN = "now + "+WAIT+" minutes"
			cmd  = "echo  "+WHAT+"  2>/dev/null | at "+WHEN+" 2>&1 | awk '/^[Jj]ob/{print $2}'" 
			pOut,pIn,pErr = popen2.popen3(cmd)
			pIn.close()
			ATJOB = string.strip(pOut.readline())
			pOut.readlines()
			pErr.readlines()
			pOut.close()
			pErr.close()
			#TODO:
			#LOG1x at -l >&2

		TestOut = open(TST+".test.out","w")
		TestErr = open(TST+".test.err","w")
		TestOut.write("stdout of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")
		TestErr.write("stderr of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")

		DoIt (env, CALL, TST, EXT, PRELUDE, TestOut, TestErr, XTIMEOUT, TIMEOUT)

		if os.name != "nt":
			while  os.path.isfile(path("/tmp/.MkillUsers."+ME)):
				time.sleep(9)
			if OS == "Linux":
				ATRM = 'at -d '
			else:
				ATRM = 'at -r '
			os.system(ATRM+ATJOB)
			#TODO:
			#LOG1x at -l >&2
			f = TST+".KILLED.out"
			if  os.path.isfile(f):
				for l in fileinput.input(f):
					TestOut.write("! "+l)
			f = TST+".KILLED.err"
			if  os.path.isfile(f):
				for l in fileinput.input(f):
					TestErr.write("! "+l)

		#TODO:
		##if [ ! -f $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ] ; then  touch $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi
		##LEFTOVERTMPBATS="`find $MONETFARM/dbfarm/*/bat/ -name tmp_\* -print 2> /dev/null`"
		##if [ "$LEFTOVERTMPBATS" ] ; then
		##	ls -alF $LEFTOVERTMPBATS 2> /dev/null > .all.left-over.tmp.bats.
		##	diff -u0 $TSTTRGBASE/Tests/.old.left-over.tmp.bats. .all.left-over.tmp.bats. | grep '^\+[^\+]' > .new.left-over.tmp.bats.
		##fi
		##if [ -s .new.left-over.tmp.bats. ] ; then
		##	echo -e "\n!ERROR: persistent temporary bats remained:" >> $LOGFILE.err
		##	sed 's|^\+|! |g' .new.left-over.tmp.bats.               >> $LOGFILE.err
		##	echo                                                    >> $LOGFILE.err
		##fi
		##rm -f .new.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats.
		##if [ -f .all.left-over.tmp.bats. ] ; then  mv -f .all.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi

		TestOut.close()
		TestErr.close()

		os.system("python "+THISPATH+os.sep+"Mfilter.py "+par['IGNORE']+" "+TST+STABLEout+" "+TST+STABLEerr+" "+TST+".test.out "+TST+".test.err")
		if os.name == "nt":
			time.sleep(1)

		testO = re.compile("^/"+TST+STABLEout+"/([^/]*)/")
		testE = re.compile("^/"+TST+STABLEerr+"/([^/]*)/")
		REVo="?"
		REVe="?"
		for l in fileinput.input(TSTSRCDIR+os.sep+"CVS"+os.sep+"Entries"):
			mO = testO.match(l)
			if mO:
				REVo=mO.group(1)
			mE = testE.match(l)
			if mE:
				REVe=mE.group(1)
		REVo=" (r"+REVo+")"
		REVe=" (r"+REVe+")"

		ACCURACY = par['ACCURACY']
		#TODO:
		#timedout = 1
		#while timedout and ACCURACY >= 0:
		#	timedout = 0
		#	signal.alarm(par['TIMEOUT'])
		#	try:
		#		os.system(env['exe']['Mdiff'][1]+' '+par['IGNORE']+' '+par['CONTEXT']+' -a'+str(ACCURACY)+' -r"'+REVo+'" '+TST+STABLEout+'.FILTERED '+TST+'.test.out.FILTERED '+TST+'.out.diff.html')
		#	except TimeoutError, t:
		#		timedout = 1
		#	signal.alarm(0)
		#	ACCURACY = ACCURACY - 1
		os.system(env['exe']['Mdiff'][1]+' '+par['IGNORE']+' '+par['CONTEXT']+' -a'+str(ACCURACY)+' -r"'+REVo+'" '+TST+STABLEout+'.FILTERED '+TST+'.test.out.FILTERED '+TST+'.out.diff.html')

		ACCURACY = par['ACCURACY']
		#TODO:
		#timedout = 1
		#while timedout and ACCURACY >= 0:
		#	timedout = 0
		#	signal.alarm(par['TIMEOUT'])
		#	try:
		#		os.system(env['exe']['Mdiff'][1]+' '+par['IGNORE']+' '+par['CONTEXT']+' -a'+str(ACCURACY)+' -r"'+REVe+'" '+TST+STABLEerr+'.FILTERED '+TST+'.test.err.FILTERED '+TST+'.err.diff.html')
		#	except TimeoutError, t:
		#		timedout = 1
		#	signal.alarm(0)
		#	ACCURACY = ACCURACY - 1
		os.system(env['exe']['Mdiff'][1]+' '+par['IGNORE']+' '+par['CONTEXT']+' -a'+str(ACCURACY)+' -r"'+REVe+'" '+TST+STABLEerr+'.FILTERED '+TST+'.test.err.FILTERED '+TST+'.err.diff.html')

		AddTstToHtmlIndex(env, TST, STABLEout, STABLEerr, EXT)

def Prompt(cmd):
	prompt = time.strftime('\n# %H:%M:%S >  ',time.localtime(time.time()))
	return prompt+prompt+cmd+prompt+"\n\n"

def LaunchIt(cmd, TestIn, TestOut, TestErr):
	TestOut.write(Prompt(cmd)) ; TestOut.flush()
	TestErr.write(Prompt(cmd)) ; TestErr.flush()
	pOut,pIn,pErr = popen2.popen3(cmd)
	pIn.write(TestIn)
	return pIn, pOut, pErr

def CollectIt(pOut, pErr, TestOut, TestErr):
	TestOut.writelines(pOut.readlines()) ; TestOut.flush()
	TestErr.writelines(pErr.readlines()) ; TestErr.flush()
	pOut.close()
	pErr.close()

def RunIt(cmd, TestIn, TestOut, TestErr):
	pIn, pOut, pErr = LaunchIt(cmd, TestIn, TestOut, TestErr)
	pIn.close()
	CollectIt(pOut, pErr, TestOut, TestErr)

def DoIt(env, CALL, TST, EXT, PRELUDE, TestOut, TestErr, XTIMEOUT, TIMEOUT) :
	STDERR.flush()
	print(env['TSTDIR']+os.sep+TST+EXT+" "+PRELUDE)
	STDOUT.flush()
	TSTDB = env['TSTDB']
	exe = env['exe']
	if exe['Mtimeout'][0]:
		MTO = "Mtimeout -timeout "
		TOT = TIMEOUT
		XTO = XTIMEOUT
	else:
		MTO = ""
		TOT = ""
		XTO = ""
	if   CALL == "other":
		cmd = MTO+str(XTO)+" ."+os.sep+TST+" "+TST+" "+PRELUDE
		RunIt(cmd, "", TestOut, TestErr)
	elif CALL == "python":
		cmd = MTO+str(XTO)+" "+exe['python'][1]+" "+TST+EXT+" "+TST+" "+PRELUDE
		RunIt(cmd, "", TestOut, TestErr)
	elif CALL in ["milM", "milS", "milMXs", "milSXs"]:
		cmd = MTO+str(TOT)+" "+exe['Mserver'][1]
		cmd = cmd+" -db "+TSTDB+" "+PRELUDE+" < "
		if CALL in ["milM", "milS"]:
			X=""
		else:
			X="_s[0-9][0-9]"
		test = re.compile("^"+TST+X+EXT+"$")
		d = os.listdir(os.getcwd())
		d.sort()
		for f in d:
			if test.match(f):
				RunIt(cmd+f, "", TestOut, TestErr)
	elif CALL in ["milC", "milCXs"]:
		TSTs = []
		if CALL == "milC":
			X=""
		else:
			X="_s[0-9][0-9]"
		test = re.compile("^"+TST+X+EXT+"$")
		d = os.listdir(os.getcwd())
		d.sort()
		for f in d:
			if test.match(f):
				TSTs.append(f)

		Srvr = MTO+str(XTO)+" "+exe['Mserver'][1]+" -db "+TSTDB+" "+env['MONET_PREFIX']+regsub.gsub("/",os.sep,"/share/Monet/mapi.mil")+" "
		#-background"
		Clnt = MTO+str(TOT)+" "+exe['MapiClient'][1]+" "+PRELUDE+" < "
		Shwn = MTO+str(TOT)+" "+exe['Mshutdown'][1]

		SrvrOut = open(TST+".server.out","w")
		SrvrErr = open(TST+".server.err","w")
		ClntOut = open(TST+".client.out","w")
		ClntErr = open(TST+".client.err","w")
		ShwnOut = open(TST+".shutdown.out","w")
		ShwnErr = open(TST+".shutdown.err","w")

		pSrvrIn, pSrvrOut, pSrvrErr = LaunchIt(Srvr, "", SrvrOut, SrvrErr)
		#pSrvrIn.close()
		time.sleep(9)

		for f in TSTs:
			RunIt(Clnt+f, "", ClntOut, ClntErr)

		#TODO:
		#Clnt = MTO+str(TOT)+" "+exe['MapiClient'][1]
		#RunIt(Clnt, "shutdown;\n", ClntOut, ClntErr)

		RunIt(Shwn, "", ShwnOut, ShwnErr)

		pSrvrIn.close()
		CollectIt(pSrvrOut, pSrvrErr, SrvrOut, SrvrErr)

		for q in [SrvrOut, ClntOut, ShwnOut]:
			n = q.name
			q.close()
			q = open(n,'r')
			TestOut.writelines(q.readlines())
			q.close()
		TestOut.flush()
		for q in [SrvrErr, ClntErr, ShwnErr]:
			n = q.name
			q.close()
			q = open(n,'r')
			TestErr.writelines(q.readlines())
			q.close()
		TestErr.flush()
	#TODO
	#elif CALL == "milCXp":
	TestOut.write(Prompt('Done.')) ; TestOut.flush()
	TestErr.write(Prompt('Done.')) ; TestErr.flush()

def Check(command, input) :
	pOut,pIn,pErr = popen2.popen3(command+" || echo ! Exit 1")
	pIn.write(input)
	pIn.close()
	qOut = pOut.readlines()
	qErr = pErr.readlines()
	rOut = pOut.close()
	rErr = pErr.close()
	rOutErr = ( rOut or rErr )
	if not rOutErr:
		for l in qOut+qErr:
			if l[0] == "!":
				rOutErr = 1
	if rOutErr:
		ErrMsg("'"+command+"` failed:")
		if qOut  and  len(qOut[-1]) >= 8  and  qOut[-1][:8] == "! Exit 1":
			qErr.append(qOut.pop())
		STDERR.writelines(qOut)
		STDERR.writelines(qErr)
		STDERR.write("\n")
		STDERR.flush()
		#sys.exit(1)
	return rOutErr

def CheckExec(cmd) :
	for p in string.split(os.environ['PATH'],os.pathsep):
		x = isexecutable(p+os.sep+cmd)
		if x[0]:
			return p+os.sep+cmd+x[1]
	return ""

#############################################################################
#	MAIN

THISFILE = os.path.basename(sys.argv[0])
THISPATH = os.path.abspath(os.path.dirname(sys.argv[0]))

if os.environ.has_key('HOST'):
	HOST = os.environ['HOST']
elif os.name != "nt":
	HOST = os.uname()[1]
else:
	HOST = "batman"
HOST = string.split(HOST,'.')[0]

if os.name == "nt":
	OS    = "WindowsNT"
	OSVER = OS+"5.0"
else:
	OS    = os.uname()[0]
	if OS == "AIX":
		OSVER = OS+os.uname()[3]+"."+os.uname()[2]
	else:
		OSVER = OS+os.uname()[2]
os.environ['OS'] = OS
os.environ['OSVER'] = OSVER

if os.environ.has_key('COMPILER'):
	COMPILER = os.environ['COMPILER']
else:
	COMPILER = ""

if os.environ.has_key('HTMLTITLE'):
	HTMLTITLE = os.environ['HTMLTITLE']
else:
	HTMLTITLE = ""
	if COMPILER:
		HTMLTITLE = " for "+COMPILER
	HTMLTITLE = "Mtest results"+HTMLTITLE+" on "+OSVER	#"+ ("`date`")"

URLPREFIX   = 'http://monetdb.cwi.nl/htbin/monet/viewcvs/viewcvs.cgi/monet/'
URLSUFFIX_F = '?cvsroot=Monet-4.2'
URLSUFFIX_D = '?cvsroot=Monet-4.2'

par = {}

def FindMonetConf(env):
	dirs = [ os.getcwd()+os.sep+".", env['TSTSRCBASE']+os.sep+"." ]
	if os.environ.has_key('HOME'):
		dirs.append(os.environ['HOME']+os.sep+".")
	dirs.append(path(env['MONET_PREFIX']+"/share/Monet/"))
	for d in dirs:
		f = d+'monet.Mtest.conf'
		if os.path.isfile(f):
			return f
	return ""

def ReadFromMonetConf(env, var):
	value = ""
	test = re.compile("^\s*"+var+"\s*=\s*([^#\s]+)")
	for l in fileinput.input(env['MONETRC']):
		m = test.match(l)
		if m:
			value = m.group(1)
	if len(value) >= 4  and  url(value[:4]) == ".../":
		value = env['MONET_PREFIX']+value[3:]
	return value

def main(argv) :
	#TODO:
	#signal.signal(signal.SIGALRM, AlarmHandler)

	vars = ['MONET_SOURCE', 'MONET_BUILD'   , 'MONET_PREFIX'  , \
		'TSTSRCBASE'  , 'TSTBLDBASE'    , 'TSTTRGBASE'    , \
		'MONETRC'     , 'MONET_MOD_PATH', 'MAPIPORT'         ]

	# most intuitive (?) default settings
	dft = {}
	dft['MONET_SOURCE']   = "'@MONET_SOURCE@'"
	dft['MONET_BUILD']    = "'@MONET_BUILD@'"
	dft['MONET_PREFIX']   = "'@MONET_PREFIX@'"	# or THISPATH ?
	dft['TSTSRCBASE']     = "env['MONET_SOURCE']"
	dft['TSTBLDBASE']     = "env['MONET_BUILD']"
	dft['TSTTRGBASE']     = "env['MONET_PREFIX']"	# or os.getcwd() ?
	dft['MONETRC']        = "FindMonetConf(env)"
	dft['MONET_MOD_PATH'] = "env['MONET_PREFIX']+os.sep+'lib'+os.pathsep+env['MONET_PREFIX']+os.sep+'lib'+os.sep+'Monet'"
	dft['MAPIPORT']       = "HOST+':'+str(random.randint(10000,65535))"
	env = {}

	#par = {}
	par['IGNORE']    = '-I"^#"'
	par['CONTEXT']   = '-c1'
	par['ACCURACY']  = 2
	par['TIMEOUT']   = 600
	par['RECURSIVE'] = 0

	# get current environment
	for v in vars:
		if os.environ.has_key(v):
			env[v] = os.environ[v]
			#TODO:
			# make sure, that PATHs ar absolute

	# commandline options overrule environment
	try:
		opts, args = getopt.getopt(argv[1:], "?hI:c:a:t:r", ["help", "monetrc=", "TSTSRCBASE=", "TSTBLDBASE=", "TSTTRGBASE=", "MONET_SOURCE=", "MONET_BUILD=", "MONET_PREFIX="])
	except getopt.GetoptError:
		Usage()
		sys.exit(1)
	for o, a in opts:
		if   o in ("-?", "-h", "--help"):
			Usage()
			sys.exit(0)
		elif o == "-I":
			par['IGNORE'] = o+a
		elif o == "-c":
			par['CONTEXT'] = o+str(int(a))
		elif o == "-a":
			a = int(a)
			if a not in (0,1,2):
				Usage()
				ErrXit("Accuracy for diff (-a) must be one of: 0=lines, 1=words, 2=chars !")
			par['ACCURACY'] = a
		elif o == "-t":
			par['TIMEOUT'] = int(a)
		elif o == "-r":
			par['RECURSIVE'] = 1
			# commandline options overrule environment
		elif len(o) > 2  and  o[:2] == "--"  and  o[2:] in vars:
			env[o[2:]] = a
			#TODO:
			# make sure, that PATHs ar absolute
		else:
			Usage()
			ErrXit("Illegal option: '"+o+"`!")
	#TODO
	if os.name == "nt"  and  par['ACCURACY'] != 0:
		Warn("Currently only '-a0` is supported on NT!")
		par['ACCURACY'] = 0

	# display par's
	STDERR.flush()
	for v in par.keys():
		#os.environ[v] = par[v]
		print(v+" = "+str(par[v]))
	STDOUT.flush()
	#env['par'] = par

	# tidy-up and fall-back to defaults where necessary
	for v in vars:
		if not env.has_key(v):
			env[v] = eval(dft[v])
			#TODO:
			# make sure, that PATHs ar absolute

	if not env['MONETRC']:
		Usage()
		ErrXit("No .monet.[Mtest.]conf found!")

	#TODO:
	## in case of inconsistencies, try to fallback to "save" settings
	#
	#if not os.path.indir(TSTSRCBASE):
	#	ErrXit("Illegal TSTSRCBASE: directory '"+a"` does not exist!")
	#if not os.path.indir(MONET_SOURCE):
	#	ErrXit("Illegal MONET_SOURCE: directory '"+a"` does not exist!")
	#if not os.path.indir(MONET_BUILD):
	#	ErrXit("Illegal MONET_BUILD: directory '"+a"` does not exist!")
	#if not os.path.indir(MONET_PREFIX):
	#	ErrXit("Illegal MONET_PREFIX: directory '"+a"` does not exist!")

	# some relative path's for relocatable HTML output
	if env['TSTSRCBASE'] == env['TSTBLDBASE']  and  env['TSTBLDBASE'] == env['TSTTRGBASE']:
		RELSRCBASE = os.curdir
		RELBLDBASE = os.curdir
	else:
		TSTBASE = os.path.dirname(os.path.commonprefix([env['TSTSRCBASE'],env['TSTBLDBASE'],env['TSTTRGBASE']]))
		RELBASE = ((os.sep+os.pardir)*len(string.split(env['TSTTRGBASE'][len(TSTBASE+os.sep):],os.sep)))[len(os.sep):]
		RELSRCBASE = RELBASE+env['TSTSRCBASE'][len(TSTBASE):]
		RELBLDBASE = RELBASE+env['TSTBLDBASE'][len(TSTBASE):]
	env['RELSRCBASE'] = RELSRCBASE
	env['RELBLDBASE'] = RELBLDBASE
	
	#STDERR.flush()
	#for v in 'RELSRCBASE', 'RELBLDBASE':
	#	print(v+" = "+str(env[v]))
	#STDOUT.flush()

	env['GDK_DBFARM'] = path(ReadFromMonetConf(env, "gdk_dbfarm"))

	# export and display env
	STDERR.flush()
	for v in vars + ['GDK_DBFARM']:
		os.environ[v] = env[v]
		print(v+" = "+env[v])
	STDOUT.flush()

	# set/extend PATH & LD_LIBRARY_PATH
	bp = env['MONET_PREFIX']+os.sep+"bin"
	lp = env['MONET_MOD_PATH']
	if os.name == "nt":
		bp = bp+os.pathsep+lp
	if os.environ.has_key('PATH'):
		bp = bp+os.pathsep+os.environ['PATH']
	os.environ['PATH'] = bp
	print("PATH = "+bp)
	if os.name == "posix":
		if os.environ.has_key('LD_LIBRARY_PATH'):
			lp = lp+os.pathsep+os.environ['LD_LIBRARY_PATH']
		os.environ['LD_LIBRARY_PATH'] = lp
		print("LD_LIBRARY_PATH = "+lp)

	if not startswith(os.getcwd()+os.sep, env['TSTSRCBASE']+os.sep):
		Warn("Current directory "+os.getcwd()+" is no descendant of TSTSRCBASE="+env['TSTSRCBASE']+";")
		Warn("changing to TSTSRCBASE="+env['TSTSRCBASE']+", now.")
		os.chdir(env['TSTSRCBASE'])

	# check for executables, set their standard options and export them
	exe = {}
	exe['Mtimeout']   = CheckExec('Mtimeout')  , 'Mtimeout -timeout '+str(par['TIMEOUT'])
	exe['Mserver']    = CheckExec('Mserver')   , 'Mserver -monetrc '+env['MONETRC']
	exe['MapiClient'] = CheckExec('MapiClient'), 'MapiClient -everything'
	exe['Mcreatedb']  = CheckExec('Mcreatedb') , 'Mcreatedb -monetrc '+env['MONETRC']
	exe['Mdestroydb'] = CheckExec('Mdestroydb'), 'Mdestroydb -monetrc '+env['MONETRC']
	exe['Mshutdown']  = CheckExec('Mshutdown') , 'Mshutdown'
	exe['Mdiff']      = CheckExec('Mdiff')     , 'Mdiff'
	exe['python']     = CheckExec('python')    , 'python'
	STDERR.flush()
	for v in exe.keys():
		V = string.upper(v)
		# TODO ?
		# if exe[v][0]:
		if os.name == "nt":
			CALL = "call "
		else:
			CALL = ""
		if  v != 'Mtimeout'  and  exe['Mtimeout'][0]:
			os.environ[V] = CALL+exe['Mtimeout'][1]+" "+exe[v][1]
		else:
			os.environ[V] = CALL+exe[v][1]
		print(V+" = "+exe[v][0]+" : "+exe[v][1])
	STDOUT.flush()
	env['exe'] = exe

	#TODO:
	#exe['JAVA']       = 'java'
	#exe['JAVAC']      = 'javac'

	# parse commandline arguments
	testdirs = []
	testlist = []
	dirlist = []
	if   len(args) == 1:
		if   os.path.isdir(args[0]):
			d = os.path.abspath(args[0])
			if startswith(d+os.sep, env['TSTSRCBASE']+os.sep):
				dirlist.append(d)
			#TODO:
			#else:
				# WARNING/ERROR
		elif string.find(args[0], os.sep) != -1:
			ErrXit("'"+args[0]+"` is neither a valid directory in "+os.getcwd()+" nor a valid test-name!")
		elif args[0] != "All":
			#TODO:
			# check, whether args[0] in All
			testlist.append(args[0])
	elif len(args) > 1:
		i = 0
		while i < len(args)  and  os.path.isdir(args[i]):
			d = os.path.abspath(args[i])
			if startswith(d+os.sep, env['TSTSRCBASE']+os.sep):
				dirlist.append(os.path.abspath(args[i]))
			#TODO:
			#else:
				# WARNING/ERROR
			i = i + 1
		if len(dirlist) == 1  and  i < len(args)  and  args[i] != "All":
			while i < len(args):
				if string.find(args[i], os.sep) == -1:
					#TODO:
					# check, whether args[i] in All
					testlist.append(args[i])
				#TODO
				#else:
					# ERROR/WARNING
				i = i + 1
		else:
			if i < len(args)  and  args[i] == "All":
				i = i + 1
			#TODO:
			#if i < len(args):
				#if len(dirlist) > 1:
					# Warn: dirlist => ignore testlist, assume All
				#else:
					# Warn: All => ignore testlist
	if not dirlist:
		dirlist.append(os.getcwd())
	if par['RECURSIVE']:
		#TODO
		#if testlist:
			# WARNING
		testlist = []
		for d in dirlist:
			for t in find_test_dirs(d):
				if t not in testdirs:
					testdirs.append(t)
	else:
		for d in dirlist:
			if   os.path.basename(d) == "Tests"  and  os.path.isfile(d+os.sep+"All"):
				testdirs.append(os.path.dirname(os.path.abspath(d)))
			elif os.path.isdir(d+os.sep+"Tests")  and  os.path.isfile(d+os.sep+"Tests"+os.sep+"All"):
				testdirs.append(os.path.abspath(d))
			else:
				Warn("No tests found in '"+d+"`; skipping directory!")

	if len(testdirs) > 1  and  testlist:
		testlist = []
		#TODO
		# WARNING
	if not testdirs:
		Warn("No tests found!")
		sys.exit(1)

	if os.path.exists(env['TSTTRGBASE']+os.sep+"Tests"):
		shutil.rmtree(env['TSTTRGBASE']+os.sep+"Tests")
	if not os.path.exists(env['GDK_DBFARM']):
		#TODO: set mode to umask
		os.makedirs(env['GDK_DBFARM'])

	if os.path.exists(env['GDK_DBFARM']+os.sep+"Tests"):
		if Check(env['exe']['Mdestroydb'][1]+" -db Tests", ""):
			sys.exit(1)
	if Check(env['exe']['Mcreatedb'][1] +" -db Tests", ""):
		sys.exit(1)
	if Check(env['exe']['Mserver'][1]   +" -db Tests", "quit;\n"):
		sys.exit(1)
	GetBitsAndMods(env)
	STDERR.flush()
	print("Bits: ", env['TST_BITS'])
	print("Modules: ", env['TST_MODS'])
	STDOUT.flush()

	if len(testdirs) == 1:
		runtests(env, testdirs[0], testlist)
	else:
		testdirs.sort()
		for d in testdirs:
			runtests(env, d, [])
	env['TSTDIR'] = ""
	env['TSTTRGDIR'] = env['TSTTRGBASE']+os.sep+"Tests"
	CreateHtmlIndex(env)

	test = re.compile("^.*<B>.*$")
	failed = 0
	for l in fileinput.input(env['TSTTRGBASE']+os.sep+"Tests"+os.sep+"index.head.html"):
		if test.match(l):
			failed = 1
	STDERR.flush()
	if failed:
		print("""
 !ERROR:  Testing FAILED ! 

 First, check the testing results in  """+env['TSTTRGBASE']+os.sep+"Tests"+os.sep+"index.html"+"""  ! 

 Then, fix the problems by: 
  - fixing sources and test scripts 
  - fixing stable output by hand 
  - approving test output by Mapprove (cf. Mapprove -?) 

 After that, re-run Mtest. 
""")
	else:
		print("""
 No differences encountered during testing. 

 If necessary, you can checkin your modifications, now. 
""")

if __name__ == "__main__":
	main(sys.argv)

#	END
#############################################################################
