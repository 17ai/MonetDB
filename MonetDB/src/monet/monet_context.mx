@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f monet_context
@a M. L. Kersten, P. Boncz

@* Monet variables
The Monet name space is a multi-level hierarchy of contexts. Each
context contains variables. Variables are sought from the deepest 
level upwards.s The root conext is formed by the context created at 
server start, i.e. the administrator console (0).  The next layer is 
bound to a client session, the lower layers correspond to the stack 
of MIL blocks in execution.

The context structures are collected in a table. The first entries
are reserved for a session context per client.

The stack forms a potential shared resource. The task of assigning new
context records or freeing them therefore is protected with a lock.
The implementation is optimistic in the sense that once an entry has been
located it is privately used. This assumes the implementation of detecting
duplicate identifier use in parallel blocks!

A variable binding may become CONSTANT for the duration of its
life time, or the type can be FROZEN.

TODO: looking for a variable in a context is implemented by scanning 
the whole list.  Maybe we should switch to a hash-table here!
One thing to have in mind, though, is intrensive MIL scripts that do
while or batloops, only lookup a variable the first time the loop
is executed, so the performance problem should not be very severe.
@h
#ifndef _MONET_CNTXT_H_
#define _MONET_CNTXT_H_
#include "monet.h"


typedef struct VARSTRUCT{
        ValRecord   binding;	/* the MIL value of the variable */
        struct VARSTRUCT *next;	/* linked list */
        bit	constant;	/* value cannot change */
        bit	frozen;		/* type cannot change */
        char    name[1];	/* variable name (var length, extends after record!!) */
} *Variable, VarRecord;

typedef struct CNTXT {
	Variable var;   /* head of the variable list */
	Cntxt   outer;	/* where to look next, basically the call stack */
	Cntxt   next;	/* for making chains. differs from 'outer' due to parallel execution */
	bit 	shadow;	/* shadow stk; create new variables in outer */
	bit 	used;	/* in use or not */
	short 	reuse;	/* context record is reused (i.e. kept around) for speed among multiple loop iterations 
			 * reuse==-1: not in a loop, reuse==stk: reused by (while/multiplex/bat)loop in 'stk' 
		         */
} CntxtRec;

m_export CntxtRec* monet_cntxt;

m_export void	CNTXTinit    (void);
m_export Cntxt	CNTXTnew     (Cntxt outer);
m_export void	CNTXTclear   (Cntxt i);
m_export void	CNTXTfree    (Cntxt stk, Client c);
m_export void	CNTXTdelete  (Cntxt i);
m_export int	CNTXTclient  (Cntxt i, Client *c);
m_export Cntxt 	CNTXTcopy    (Cntxt src);

/* inline for speed */
#define CNTXTuse(stk)		monet_cntxt[stk].used = 1;
#define CNTXTfree2(stk,c)	((c) && (c)->maxstk != stk && CNTXTfree(stk,c))
#define CNTXTfree1(stk)		{ Client c; CNTXTclient(stk, &c); CNTXTfree2(stk,c); }

m_export Variable	VARfind      (Cntxt *stk, str scope);
m_export Variable	VARlocalfind (Cntxt *stk, str scope);
m_export Variable	VARnew       (Cntxt stk, str name);  
m_export int 	VARpurge     (int nbats, int* bats, int natoms, int* atoms);

#define VARclearBAT(B)	((B) && VARpurge(1, &(B)->batCacheid, 0, NULL))
#define VARfreeze(X)	((X) && ((X)->frozen=TRUE))
#define VARfixate(X)	((X) && ((X)->constant=(X)->frozen=TRUE))

m_export Cntxt monet_cntxtmax;
m_export Cntxt monet_cntxtlim;

#endif /* _MONET_CNTXT_H_ */
@c
#include "monet.h"

Cntxt monet_cntxtmax = 200*MAXCLIENTS;
Cntxt monet_cntxtlim = 1024*1024;
Cntxt monet_cntxtfree = MAXCLIENTS;
Cntxt monet_cntxtcur = 0;
CntxtRec *monet_cntxtbuf = NULL, *monet_cntxt = NULL;

void CNTXTinit(void) {
    monet_cntxtlim = MAX(monet_cntxtmax+1,monet_cntxtlim); 

    /* alloc cntxt space; try to reserve as much space as possible */
    for (;;) {
        size_t size = (monet_cntxtmax+1)*sizeof(CntxtRec);
        size_t maxsize = monet_cntxtlim*sizeof(CntxtRec);

        monet_cntxtbuf = (CntxtRec*) GDKvmalloc(size, &maxsize);
	MT_alloc_register(monet_cntxtbuf, maxsize, 'C');
        if (monet_cntxtbuf && maxsize >= monet_cntxtlim*sizeof(CntxtRec)) {
		monet_cntxtlim = (Cntxt) (maxsize / sizeof(CntxtRec));
                break;
        }
	MT_alloc_register(monet_cntxtbuf, maxsize, 'c');
        if (monet_cntxtbuf) GDKvmfree(monet_cntxtbuf, size, maxsize);
        if ((monet_cntxtlim/=2) < monet_cntxtmax+1) {
            GDKfatal("CNTXTinit: could not alloc arena\n");
        }
    } 
    memset(monet_cntxtbuf, 0, (monet_cntxtmax+1)*sizeof(CntxtRec));
    monet_cntxt = monet_cntxtbuf + 1;
}


int CNTXTrealloc(flt factor) {
    /* extend the VM region; make it start at the same base address */
    Cntxt oldsize = monet_cntxtmax+1;
    Cntxt newsize = (Cntxt) ((double)oldsize*factor);
    size_t maxsize = MAX(newsize,monet_cntxtlim)*sizeof(CntxtRec);
    CntxtRec* p = (CntxtRec*) GDKvmrealloc(monet_cntxtbuf, oldsize*sizeof(CntxtRec), 
					newsize*sizeof(CntxtRec), maxsize, &maxsize);
    if (p == NULL || p != monet_cntxtbuf) {
	if (p) GDKvmfree(p, oldsize*sizeof(CntxtRec), maxsize);
	GDKerror("CNTXTrealloc(): out of context space\n");
	return FALSE;
    }
    memset(monet_cntxtbuf+oldsize, 0, (newsize-oldsize)*sizeof(CntxtRec));
    monet_cntxtmax = newsize-1;
    monet_cntxtlim = (Cntxt) (maxsize/sizeof(CntxtRec));
    return TRUE;
}

@- 
find the Client who owns  a cetrain context record 'stk' (by walking upwards).
@c
int CNTXTclient(Cntxt stk, Client* c){
	int depth = 0;	
	while(stk >= MAXCLIENTS) {
		depth++;
		stk = monet_cntxt[stk].outer;
	}
	*c = monet_clients+stk;
	return depth;
}

@- 
Initialize a new context for a particular user. The non-used
context records are linked through the outer field. This way
we can get a new context in 'constant' time.
@c
Cntxt CNTXTnew(Cntxt outer){
	Cntxt i;

	MT_set_lock(monet_contextLock, "CNTXTnew");
	if (monet_cntxtcur >= MAXCLIENTS) {
		i = monet_cntxtcur; /* get from freelist */
		monet_cntxtcur = monet_cntxt[monet_cntxtcur].next;
	} else if (monet_cntxtfree >= monet_cntxtmax && !CNTXTrealloc((flt)BATMARGIN)) {
		MT_unset_lock(monet_contextLock, "CNTXTnew");
		return 0;
	} else {
		i = monet_cntxtfree++; /* alloc new at end succeeded */
	}
	monet_cntxt[i].outer = outer;
	monet_cntxt[i].next = c->maxstk;
	monet_cntxt[i].reuse = monet_cntxt[outer].reuse; /* inherit reuse spec from parent */
        monet_cntxt[i].shadow = 0;
        monet_cntxt[i].used = 1;
	c->maxstk = i; 
	MT_unset_lock(monet_contextLock, "CNTXTnew");
	return i;
}
@- 
Deleting a context basically means deleting all its variables
@c
void CNTXTdelete(Cntxt cur){
	Variable w, v = monet_cntxt[cur].var;

	for(monet_cntxt[cur].var = 0; v ; v= w) {
		w = v->next;
		GDKfree(v);
	}
	monet_cntxt[cur].reuse = -1;
}

@-
CNTXTfree deletes all unsed contexts between maxstk and stk. It then adapts maxstk.
Due to parallel execution, not all stacks on the trail from maxstk to current
can be freed. Hence we filter out those that can, and leave in those that cannot.
@c
void CNTXTfree(Cntxt stk, Client c){
	Cntxt keep_first = -1, del_first = -1;
	Cntxt keep_last = -1, del_last = -1;
	Cntxt cur;

	MT_set_lock(monet_contextLock, "CNTXTfree");
	for(cur = c->maxstk; cur != stk; cur = monet_cntxt[cur].next) {
		if (monet_cntxt[cur].used == 0 && (monet_cntxt[cur].reuse < 0 
			|| monet_cntxt[monet_cntxt[cur].reuse].reuse < 0))
		{
			CNTXTdelete(cur);
			if (del_first < 0) del_first = cur;
			if (del_last >= 0) monet_cntxt[del_last].next = cur;
			del_last = cur;
		} else {
			if (keep_first < 0) keep_first = cur;
			if (keep_last >= 0) monet_cntxt[keep_last].next = cur;
			keep_last = cur;
		}
       	}
	if (del_last >= 0) {
       		monet_cntxt[del_last].next = monet_cntxtcur;
		monet_cntxtcur = del_first;
	}
	if (keep_last >= 0) {
		monet_cntxt[keep_last].next = stk;
		c->maxstk = keep_first;
	} else {
		c->maxstk = stk;
	}
	MT_unset_lock(monet_contextLock, "CNTXTfree");
}
@-
Clearing a context leavs all variables in place, but frees
all their values, which are set to nil. This typically
occurs when a MIL block (context) that is in a loop
reaches end-of-scope. The context and all variable records
are left intact, so they can be reused in the next iteration.
@c
void CNTXTclear(Cntxt stk){
        Variable w, v = monet_cntxt[stk].var;
        
       	while (v) {
       		w = v->next;
		ATOMunfix(v->binding.vtype, VALptr(&v->binding));
		VALclear(&v->binding);
		v = w;
       	}
       	monet_cntxt[stk].used = 0;
}

@-
Copy the stack with all its variables.
@c
Cntxt CNTXTcopy(Cntxt srcstk){
	Cntxt res, tmp = CNTXTnew(-1); 

	res = tmp;
	while(srcstk>=0){
        	Variable v;

		monet_cntxt[tmp].shadow = 0;
		monet_cntxt[tmp].used = monet_cntxt[srcstk].used;
		monet_cntxt[tmp].reuse = monet_cntxt[srcstk].reuse;

		for(v = monet_cntxt[srcstk].var; v != NULL; v= v->next) {
			Variable n = VARnew( tmp, v->name );
			
			n->constant = v->constant;
			n->frozen = v->frozen;
			VALcopy(&n->binding, &v->binding);
			ATOMfix(n->binding.vtype, VALptr(&n->binding));
		}
		if (monet_cntxt[srcstk].outer >= 0){ 
			monet_cntxt[tmp].outer = CNTXTnew(-1); 
			tmp = monet_cntxt[tmp].outer;
		}
		srcstk = monet_cntxt[srcstk].outer;
	}
	return res;
}

@-
A variable is initialized as an integer 0 and made accessible through
a context.
@c
Variable VARnew(Cntxt stk, str name){
	Variable v;
	size_t	i;
	
	i = strlen(name);
	v = (Variable) GDKmalloc(sizeof(VarRecord)+i);
	v->binding.vtype = TYPE_int;
	v->binding.val.ival = 0;

	strncpy(v->name, name, i);
	v->name[i] = 0;
	v->constant = 0;
	v->frozen = 0;

	MT_set_lock(monet_contextLock, "VARnew");
	while(monet_cntxt[stk].shadow) stk = monet_cntxt[stk].outer;
	v->next = monet_cntxt[stk].var;
	monet_cntxt[stk].var = v;
	MT_unset_lock(monet_contextLock, "VARnew");
	return v;
}
@
@-
The routine @%VARfind@ dereferences a name to find the variable descriptor.
@c
Variable VARfind(Cntxt *stk, str nme){
        Variable v;
	int i, s = *stk;

        if (nme == NULL) {
                return 0;
        }
	do {
		i = s;
	        for (v = monet_cntxt[i].var; v; v = v->next) {
        	        if (*nme == *v->name && strcmp(nme, v->name) == 0) {
                	        return v;
               		}
		}
		s = monet_cntxt[i].outer;
	} while(i >= 0);

        return 0;
}

@-
The routine @%VARlocalfind@ dereferences a name to find the variable descriptor.
Only the local stack is inspected. 
@c
Variable VARlocalfind(Cntxt *stk, str nme){
        Variable v;
	int i, s = *stk;

        if (nme == NULL) {
                return 0;
        }
	i = s;
	for (v = monet_cntxt[i].var; v; v = v->next) {
                if (*nme == *v->name && strcmp(nme, v->name) == 0) {
			*stk = s;
               	        return v;
        	}
	}

        return 0;
}



@-
Sometimes we are hard-forced to unload a particular kind of BAT. For example, if
a MIL module is dropped that contains an ADT implementation, and we have BATs in
memory of that type. This routine is a kind of a hack that goes through all live
MIL variables, and unloads such bats. The list of bats that are on the death-list 
and should be 'purged' is passed as a parameter (see TBL_unloadmod in monet_tbl.mx).
@c
int VARpurge(int nbats, int *bats, int natoms, int *atoms){
	int i, *dst = (int*) alloca((1+natoms)*(int)sizeof(int));
	Cntxt j;
	Variable v;

	if (nbats == 0 && natoms == 0) return 0;

	for(i=0; i<natoms; i++) {
		dst[i] = ATOMstorage(atoms[i]);
		if (dst[i] > TYPE_str) dst[i] = 0; 
	}
	for(i=0; i<nbats; i++) {
		if (bats[i] < 0)  bats[i] = -bats[i];
	}

	for (j = 0; j < monet_cntxtmax; j++) if (monet_cntxt[j].used)
	for (v = monet_cntxt[j].var; v; v = v->next) {
		int tpe = v->binding.vtype;
		if (tpe == TYPE_bat) {
			int bid = ABS(v->binding.val.bval);
			for(i=0; i<nbats; i++) 
				if (bats[i] == bid) {
				    v->binding.vtype = TYPE_int; 
				    break;
				}
		} else if (tpe > TYPE_str) {
			for(i=0; i<natoms; i++) 
		        if (atoms[i] == tpe) {
				if (dst[i]) {
				    v->binding.vtype = dst[i];
				} else {
				    if (ATOMextern(tpe)) {
					GDKfree(v->binding.val.pval);
				    }
				    v->binding.vtype = TYPE_int; 
	   			    v->binding.val.ival = int_nil;
				}
				break;
			}
		}
	}
	for(i=0; i<nbats; i++) {
		BAT* b = BBPcache(bats[i]);
		if (b != NULL) BBPreclaim(b);
	}
	return 0;
}
@
