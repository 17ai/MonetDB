@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.
@' 
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2003 CWI.
@' All Rights Reserved.
@' 
@' Contributor(s):
@' 		Martin Kersten <Martin.Kersten@cwi.nl>
@' 		Peter Boncz <Peter.Boncz@cwi.nl>
@' 		Niels Nes <Niels.Nes@cwi.nl>
@' 		Stefan Manegold  <Stefan.Manegold@cwi.nl>

@f gdk_tm
@a M. L. Kersten, P. Boncz, N. J. Nes

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk.h"
#include "gdk_tm.h"

char			TMname[MAXTM][IDLENGTH] = { SYSTRANSACTION }; 

int TMnew(str s) {
	THRprintf(GDKout, "begin transaction %s\n", s); 
	strcpy(TMname[0], s); 

	return 0; 
}

int TMresume(str s) {
	strcpy(TMname[0], s); 
	return 0;
}

str TMcntxt(void) {
	return TMname[0]; 
}
@
@}
@- 
Upon transaction commit all dirty BATs should be saved on disk.
Dirty bats on disc are only loaded if needed; in most cases
it is enough to handle the (cached) BAT descriptor. 
@{
@c
int TMcommit() {
	int nkills=0, maxkills=1024, killbuf[1024], *kills = killbuf;
	int i, ret = 0;

	/* Acquire BBP locks */
	BBPlock("TMcommit");

        /* commit the delta status of each BAT */
        for (i = 1; i < BBPsize; i++)  
	if (BBP_status(i) & BBPPERSISTENT) {
		BAT *b = BBPcache(i);
		if (b == NULL && (BBP_status(i)&BBPSWAPPED)) {
			b = BBPquickdesc(i, TRUE);
			if (b == NULL) { ret = 1; break; }
		}
		if (b) {
			BATcommit(b);
		}
	}

        /* atomic write of all dirty BATs and BBP.dir */
	if (ret == 0)
	ret = BBPsync(TRUE);

        /* succeeded: adapt BBPstatus of all bats while we're still locked */
	if (ret == 0) 
        for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i)&BBPPERSISTENT) {
			BBP_status_on(i, BBPEXISTING, "TMcommit");
		} else if ((BBP_status(i)&(BBPDELETED|BBPTMP)) && BBP_refs(i) <= 0) {
			/* We cannot kill here, because some complex accelerators (histolink)
                         * need BBP locks in their delete sequence. Hence we must postpone 
                         * their destruction until after the commit has released all locks.
                         */
			if (nkills >= maxkills) {
				int *bak = kills;
				kills = (int*) GDKmalloc((maxkills*=2)*sizeof(int));
				memcpy(kills, bak, nkills*sizeof(int));
				if (bak != killbuf) {
					GDKfree(bak);
				}
			}
			/* unregister logical names; bat will be called tmp_X again */
			if (BBP_logical(-i)) {
                		BBP_delete(-i);
        			GDKfree(BBP_logical(-i));
        			BBP_logical(-i) = NULL;
			}
        		if (BBPnamecheck(BBP_logical(i)) == 0) {
				char buf[32];
				sprintf(buf, "tmp_%d", i);
                		BBP_delete(i);
        			GDKfree(BBP_logical(i));
        			BBP_logical(i) = GDKstrdup(buf);
			}
			kills[nkills++] = i;
			BBP_refs(i) = 1; /* make unkillable; so nobody else can kill it */
			BBP_status_on(i, BBPUNLOADING, "TMcommit");
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMcommit");
        }
	BBPunlock("TMcommit");

	/* outside the lock: now kill all ex-persistent bats */
	if (ret == 0)
	for(i=0; i<nkills; i++) {
                BAT *b = BBPquickdesc(kills[i], TRUE);

                if (BBP_cache(kills[i])) {
			/* those that quickdesc decides to load => proper unfix */
                        BBPunfix(kills[i]);
                } else {
                        /* the unloaded ones are deleted without loading */
                        BATdelete(b); /* delete disk images */
                        BBPclear(kills[i]); /* clear with locking */
                }
        }
	if (kills != killbuf) {
		GDKfree(kills);
	}
	return ret; 
}
@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int TMabort(void) {
	int i; 

	BBPlock("TMabort");
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPquickdesc(i, FALSE);
			if (b) {
				if (b->batPersistence == PERSISTENT)
					BBPdecref(i, TRUE);
				b->batPersistence = TRANSIENT;
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) { 
		if (BBP_status(i) & (BBPPERSISTENT|BBPDELETED|BBPSWAPPED)) {
			BAT *b = BBPquickdesc(i, TRUE);
			ALIGNundo(b);
			BATundo(b); 
			if (BBP_status(i)&BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				if (b->batPersistence != PERSISTENT)
					BBPincref(i, TRUE);
				b->batPersistence = PERSISTENT;
				b->batDirtydesc = 1;
			}					
		}
		BBP_status_off(i, BBPDELETED|BBPSWAPPED|BBPNEW, "TMabort");
	}
	BBPunlock("TMabort");
	return 0; 
}
@}
