@t Monet Values
@a Martin L. Kersten & Peter Boncz
@v 2.0 
@* Introduction

 
When manipulating values, Monet puts them into value records.
The built-in types have a direct entry in the union. Others should 
be represented as a pointer of memory in pval or as a string, which
is basically the same. In such cases the @%len@ field indicates
the size of this piece of memory.

Monet Extenders will use value records for passing parameters to
their new operators. Monet algebraic commands receive an 
(argc, argv) combination, where
argc is an integer indicating the size of the the argv array of value 
records. On call, the first record, argv[0], is always empty. The
routine must place its return value - if any - there. The other
values are the parameters.

@{
Actually, the gdk value type defined here should become a built-in
type in the kernel. Next step will be to define the corresponding
extension module.
@h
#ifndef _GDK_VALUE_H_
#define _GDK_VALUE_H_

#include "gdk.h"

#endif /* _GDK_VALUE_H_*/

@}

@{
@+ Value operations
The following primitives are required to manipulate value records.
Note that binding a BAT requires upgrading its reference count.
The receiver of the value should have been cleared or represent
free space.
@c
#include "gdk_value.h"

ValPtr VALnew(){
	ValPtr v = (ValPtr) GDKmalloc(sizeof(ValRecord));
	VALempty(v);
	return v;
}

ValPtr VALset(ValPtr v, int t, ptr p){
	switch(ATOMstorage(v->vtype = t)) {
	case TYPE_chr: v->val.cval[0] = *(chr*) p; 
		       v->val.cval[1] = 0;
		       v->val.cval[2] = 0;
		       v->val.cval[3] = 0;
			break;
	case TYPE_sht: v->val.shval = *(sht*) p; break;
	case TYPE_bit:
	case TYPE_int: v->val.ival = *(int*) p; break;
	case TYPE_flt: v->val.fval = *(flt*) p; break;
	case TYPE_dbl: v->val.dval = *(dbl*) p; break;
	case TYPE_lng: v->val.lval = *(lng*) p; break;
	default:       v->val.pval = p;
		       v->len = ATOMlen(t, p);
	}
	return v;
}

void *VALget(ValPtr v){
	switch(ATOMstorage(v->vtype)) {
	case TYPE_chr: return (void*) &v->val.cval[0];
	case TYPE_sht: return (void *) &v->val.shval;
	case TYPE_void:
	case TYPE_bit:
	case TYPE_int: return (void *) &v->val.ival;
	case TYPE_flt: return (void *) &v->val.fval;
	case TYPE_dbl: return (void *) &v->val.dval;
	case TYPE_lng: return (void *) &v->val.lval;
	case TYPE_str: return (void *) v->val.pval;
	}
	return NULL;
}

void VALclear(ValPtr v){
	switch(ATOMstorage(v->vtype)) {
	case TYPE_str:
	case TYPE_ptr:
		if(v->val.pval && v->val.pval != str_nil) GDKfree(v->val.pval);
		v->val.pval = 0;
	}
	/* if (ATOMextern(v->vtype) && v->val.pval) {
		GDKfree(v->val.pval);
		v->val.pval = 0;
	} */
	VALempty(v);
}

void VALempty(ValPtr v){
	v->len = 0;
	v->val.oval = oid_nil;
	v->vtype = TYPE_void;
}

ValPtr VALcopy(ValPtr d, ValPtr s){
	if (ATOMextern(s->vtype) == 0) {
		*d = *s;
	} else if (s->val.pval == 0) {
		/*GDKwarning("VALcopy: copying null %s.\n", ATOMname(s->vtype)); */
		d->val.pval = ATOMnil(s->vtype);
		d->vtype = s->vtype;
	} else if (s->vtype == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s->val.sval);
		d->len = strLen(d->val.sval);
	} else {
		ptr p = s->val.pval;
		d->vtype = s->vtype;
		d->val.pval = GDKmalloc(s->len);
		d->len = s->len;
		memcpy(d->val.pval, p, s->len);
	}
	return d;
}
@-
Moving a value from a BUN into a value record, making proper copies
on the way.
@c
ValPtr VALinit(ValPtr d, int tpe, ptr s){
	if (ATOMextern(tpe) == 0) {
		d->vtype= tpe;
		memcpy(&d->val.ival, s, ATOMlen(tpe,s));
	} else 
	if (s == 0) {
		GDKerror("VALinit:unsupported init\n");
		d->vtype= TYPE_int;
	} else if( ATOMstorage(tpe) == TYPE_str) {
		d->vtype = TYPE_str;
		d->val.sval = GDKstrdup(s);
		d->len = strLen(s);
	} else {
		d->vtype= tpe;
		d->len = ATOMlen(tpe,s);
		d->val.pval = GDKmalloc(d->len);
		memcpy(d->val.pval, s, d->len);
		/* GDKwarning("VALinit: not yet supported %s.\n", 
			ATOMname(tpe)); */
	}
	return d;
}
@-
VALprint shows the contents of a value record, but without
expanding the BAT contents.
@c
int VALprint(FILE *fd, ValPtr res){
	int t = ATOMstorage(res->vtype);
	return ATOMprint(t, VALptr(res), fd);
}	


int VALformat(char **buf, ValPtr res){
	int t = ATOMstorage(res->vtype);
	*buf = 0;
	return ATOMformat(t, VALptr(res), buf);
}

@-
The routine @%VALconvert@ transforms a value for interpretation
in a certain type. It uses some standard cast conventions to do this.
The result, a pointer to a value, is returned. If there are
illegal values, or type combinations involved, it gives
up with an ILLEGALVALUE.

@= valconvert
	if (dst_tpe == TYPE_chr) {
		t->val.cval[0] = (char) @1; 
	} else if (dst_tpe == TYPE_sht) {
		t->val.shval = (short) @1; 
	} else if (dst_tpe == TYPE_bat) {
		int bid = (int) @1;
		if (ABS(bid) > BBPsize || BBP_logical(bid) == NULL) {
			bid = 0;
			p = ILLEGALVALUE;
		} else {
			p = (ptr) BATdescriptor(bid);
		} t->val.bval = bid; 
	} else if (dst_tpe == TYPE_int) {
		t->val.ival = (int) @1; 
	} else if (dst_tpe == TYPE_flt) {
		t->val.fval = (float) @1; 
	} else if (dst_tpe == TYPE_lng) {
		t->val.lval = (lng) @1; 
	} else if (dst_tpe == TYPE_dbl) {
		t->val.dval = (dbl) @1; 
	}
	warning = (sizeof(dst_tpe) < sizeof(@2));
@c
ptr VALconvert(int typ, ValPtr t, int silent){
	int src_tpe = ATOMstorage(t->vtype), dst_tpe = typ, warning = 0;
	ptr p = VALptr(t);

        if (dst_tpe != TYPE_bat) {
		dst_tpe = ATOMstorage(dst_tpe);
	}  
	if (src_tpe != dst_tpe && t->vtype != typ && dst_tpe != TYPE_void) { 
		if (src_tpe >= TYPE_str || dst_tpe >= TYPE_str) { 
			if (ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) {
				VALclear(t);
				VALset(t, dst_tpe, p = ATOMnil(dst_tpe));
			} else { 
				return ILLEGALVALUE; 
			}
		} else if ((t->vtype == TYPE_bat && t->val.bval == 0 ) ||
	    	           ATOMcmp(src_tpe, ATOMnilptr(src_tpe), p) == 0) 
		{
			memcpy(p, ATOMnilptr(dst_tpe), ATOMsize(dst_tpe));
		} else if (src_tpe == TYPE_chr) {
			@:valconvert(t->val.cval[0], chr)@;
		} else if (src_tpe == TYPE_sht) {
			@:valconvert(t->val.shval, sht)@;
		} else if (src_tpe == TYPE_int) {
			@:valconvert(t->val.ival, int)@;
		} else if (src_tpe == TYPE_flt) {
			@:valconvert(t->val.fval, flt)@;
		} else if (src_tpe == TYPE_lng) {
			@:valconvert(t->val.lval, lng)@;
		} else if (src_tpe == TYPE_dbl) {
			@:valconvert(t->val.dval, dbl)@;
		}
        	if (!silent && t->vtype && warning) {
                	GDKwarning("VALconvert: converted type '%s' to '%s'.\n",
                        	ATOMname(t->vtype), ATOMname(typ));
        	}
	}
	t->vtype = typ;
	return p;
}

@+ sprintf()
The @%VALsprintf@() gets a FILE*, str, and a sequence of (ptr,int) parameters
containing values and their type numbers. The @%printf@() proved to be a
great risk; people formatting badly their "%s" format strings were crashing
the kernel. This function will prevent you from doing so.

NEW implementation that repeatedly invokes sprintf => hacking the va_alist 
for using vfsprintf proved to be too compiler-dependent (OLD approach). 

@= writemem
	if (dst+@1 > buf+size) {
		int offset = dst - buf;
		do {
			size *= 2;
		} while (dst+@1 > buf+size);
		buf = GDKrealloc(buf, size);
		dst = buf + offset;
	} 
@= sprintf
	if (width > adds) {
		adds = width+10; 
		add = (str) alloca(adds);
	}
	sprintf(add, meta, @1);
@c
static char toofew_error[80] = 
	"VALsprintf(): at least %d parameters expected.\n";
static char format_error[80] = 
	"VALsprintf(): error in format before param %d.\n";
static char type_error[80] = 
	"VALsprintf(): illegal type in param %d.\n";
#define return_error(x)\
	GDKerror(x, argc); GDKfree(buf); return GDK_FAIL;

int VALsprintf(str *res, str format, va_list ap){
	int adds = 100, prec, width, dotseen, escaped = 0, type, size, argc = 1;
	char addbuf[100], *add = addbuf, *dst, *buf, *cur, *paramseen = NULL;

        if (format == NULL) {
                GDKerror("VALsprintf(): NULL pointer passed as format.\n");
                return GDK_FAIL;
        } else if (strchr(format, '%') == NULL) {
		*res = GDKstrdup(format);
                return GDK_SUCCEED;
	}
	buf = dst = (str) GDKmalloc(size=80);
	*res = NULL;

	for(cur=format; *cur; cur++) {
		if (paramseen) {
			char *p, meta[100];
			int extra = 0;

			if (GDKisdigit(*cur)) {
				if (dotseen) {
					prec = 10*prec + (*cur - '0');
				} else {
					width = 10*width + (*cur - '0');
				}
				continue;
			} else if (dotseen == 0  && *cur == '.') {
				dotseen = 1;
				continue;
			} else if (cur == paramseen + 1 && 
				   (*cur == '+' || *cur == '-')) {
				continue;
			} else if (*cur == 'l') {
				cur++;
				if (*cur == 'l') {
					cur++; extra = 1;
				}
			} 
			if ((p = va_arg(ap,char*)) == NULL) {
				return_error(toofew_error);
			}
			type = ATOMstorage(va_arg(ap,int));
			memcpy(meta, paramseen, 1+(cur-paramseen));
			meta[1+(cur-paramseen)] = 0;

			if (strchr("cdiouxX", *cur) && !extra) {
				int ival;
				if (dotseen) {
					return_error(format_error);
		        	} else if (type == TYPE_chr) {
					ival = (int) *(chr*) p;
		        	} else if (type == TYPE_sht) {
					ival = (int) *(sht*) p;
		        	} else if (type == TYPE_flt) {
					ival = (int) *(flt*) p;
		        	} else if (type == TYPE_int) {
					ival = *(int*) p;
				} else {
					return_error(type_error);
				}
				@:sprintf(ival)@
			} else if (strchr("diouxX", *cur)) {
				lng lval;
				if (dotseen) { 
					return_error(format_error);
				} if (type == TYPE_chr) {
					lval = (lng) *(chr*) p;
				} else if (type == TYPE_sht) {
					lval = (lng) *(sht*) p;
				} else if (type == TYPE_int) {
					lval = (lng) *(int*) p;
				} else if (type == TYPE_flt) {
					lval = (lng) *(flt*) p;
				} else if (type == TYPE_dbl) {
					lval = (lng) *(dbl*) p;
		        	} else if (type == TYPE_lng) {
					lval = *(lng*) p;
				} else {
					return_error(type_error);
				}
				@:sprintf(lval)@
		    	} else if (strchr("feEgG", *cur)) {
				dbl dval;
		        	if (type == TYPE_flt) {
					dval = (dbl) *(flt*) p;
		        	} else if (type == TYPE_dbl) {
					dval = *(dbl*) p;
				} else {
					return_error(type_error);
				}
				width += (1+prec);
				@:sprintf(dval)@
			} else if (*cur == 's') {
				int len;
				if (extra) {
					return_error(format_error);
				} else if (type != TYPE_str) {
					return_error(type_error);
				}
				len = strLen(p);
				width++; prec++;  /* account for '\0' */
				if (dotseen && prec < len) len = prec;
				if (len > width) width = len;
				@:sprintf(p)@
			} else {
				return_error(format_error);
			}
			width = strlen(add);
			@:writemem(width)@
			memcpy(dst,add,width); dst += width; 
			paramseen = NULL; argc++;
		} else if (!escaped) {
			if (*cur == '\\' || (*cur == '%' && cur[1] == '%')) { 
				escaped = 1;
			} else if (*cur == '%') {
				paramseen = cur;
				dotseen = prec = width = 0;
			} else {
				@:writemem(1)@
				*dst++ = *cur;
			} 
		} else {
			escaped = 0;
			@:writemem(1)@
			*dst++ = *cur;
		}
	}

	if (va_arg(ap,char*) != NULL) 
	   GDKwarning("VALsprintf(): params %d and beyond ignored.\n", argc);
	@:writemem(1)@
	*dst = 0;
	*res = buf; 
	return GDK_SUCCEED;
}
@}
@
