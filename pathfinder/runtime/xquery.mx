# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#         Jan Flokstra <flokstra@cs.utwente.nl>
#
# $Id$

@f xquery
@a Jan Flokstra
@t xquery

@c

/*******************************************
* xquery.c : xquery command stuff
*
*/
#include <gdk.h>

#define MAXTAGDEPTH        1024


/**
 *
 * I. THE CONTEXT NODE DEFINITION AND USAGE PART
 *
 * This structure contains the context of the print session.
 * It has several functions. But its main use is the administration 
 * of all BATs containing the XML documents.
 *
 */
typedef struct {
        int     saxMode;        // Flag, true if printing a Sax-O-Phone stream
        BAT*    Tpre_size;      // Start of the document BATs
        BAT*    Tpre_kind;
        BAT*    Tpre_prop;
        BAT*    Tprop_ns;
        BAT*    Tprop_loc;
        BAT*    Tprop_text;
        BAT*    Tprop_com;
        BAT*    Tprop_tgt;
        BAT*    Tprop_ins;
        BAT*    Tattr_own;
        BAT*    Tattr_ns;
        BAT*    Tattr_loc;
        BAT*    Tattr_val;
        //
        /**
         * Next elements is a stack used during printing to store the 
         * pre-value, name, namespace of the nodes currently being printed. 
         */
        int     stackPtr;    
        struct {
                oid     pre;
                str     ns;
                str     name;
        } tagStack[MAXTAGDEPTH];
        //
        int     nAttrOnLine; /* used by top result print routine to count the
                              * number of top-level result items printed on
                              * the current line.
                              */
} XqueryCtx;


/**
 * Functions fills a new context() record with mode and BAT data and
 * initializes all other data structures.
 */
void createContext(XqueryCtx* ctx,
                   str  mode,
                   BAT* Tpre_size,
                   BAT* Tpre_kind,
                   BAT* Tpre_prop,
                   BAT* Tprop_ns,
                   BAT* Tprop_loc,
                   BAT* Tprop_text,
                   BAT* Tprop_com,
                   BAT* Tprop_tgt,
                   BAT* Tprop_ins,
                   BAT* Tattr_own,
                   BAT* Tattr_ns,
                   BAT* Tattr_loc,
                   BAT* Tattr_val
        ) {
        ctx->saxMode   = (strcmp(mode,"sax")==0);
        ctx->Tpre_size = Tpre_size;
        ctx->Tpre_kind = Tpre_kind;
        ctx->Tpre_prop = Tpre_prop;
        ctx->Tprop_ns  = Tprop_ns;
        ctx->Tprop_loc = Tprop_loc;
        ctx->Tprop_text= Tprop_text;
        ctx->Tprop_com = Tprop_com;
        ctx->Tprop_tgt = Tprop_tgt;
        ctx->Tprop_ins = Tprop_ins;
        ctx->Tattr_own = Tattr_own;
        ctx->Tattr_ns  = Tattr_ns;
        ctx->Tattr_loc = Tattr_loc;
        ctx->Tattr_val = Tattr_val;
        ctx->stackPtr  = 0;
}

/**
 * Return if there are still nodes on stack.
 */
int moreTags(XqueryCtx* ctx) {
        return (ctx->stackPtr > 0);
}

/**
 * Push the pre-value, namespace and nodename of stack
 */
void pushTag(XqueryCtx* ctx, oid pre, str ns, str name) {
        ctx->tagStack[ctx->stackPtr].pre  = pre;
        ctx->tagStack[ctx->stackPtr].ns   = strdup(ns); // incomplete
        ctx->tagStack[ctx->stackPtr].name = strdup(name); // incomplete
        ctx->stackPtr++;
}

/**
 * Three function to retrieve the pre-value, namespace or nodename of the
 * top lement on the stack.
 */
oid topTag(XqueryCtx* ctx)  { return ctx->tagStack[ctx->stackPtr-1].pre; }
str topNs(XqueryCtx* ctx)   { return ctx->tagStack[ctx->stackPtr-1].ns; }
str topName(XqueryCtx* ctx) { return ctx->tagStack[ctx->stackPtr-1].name; }

/**
 * Pop the top element of the stack. Means that processing the node has
 * finished.
 */
void popTag(XqueryCtx* ctx) {
        free( topNs(ctx) );
        free( topName(ctx) );
        --ctx->stackPtr;
}

/**
 *
 * II. THE OUTPUT HANDLER PART 
 *
 * The emit functions are used to encapsulate the Sax-O-Phone event
 * emission functions.
 * The current implementation emits the Sax-O-Phone events as if they are
 * a BAT.
 *
 * TODO: solve characters() newline in string problem. 
 *
 */

void emit_start() {
        stream_printf(GDKout,"#-------------------------#\n");
        stream_printf(GDKout,"# h     SAXtape           #\n");
        stream_printf(GDKout,"# str   str               #\n");
        stream_printf(GDKout,"#-------------------------#\n");
}


/* define borrowed fom gdk_atoms.mx */
#define allowed_chr(ch) (!(0 < (ch) && (ch) < 32) && (ch) != '\377')

void emit_escaped(char* src) {
        /* Emit a string with all special character escaped
         * Function adapted from strToStr() in gdk_atoms.mx
         */
        int start=0,end;
        for(end=0; src[end]; end++) {
                if (src[end] == '\t' || src[end] == '\n' ||
                    src[end] == '\\' || src[end] == '\"' ||
                    (!allowed_chr(src[end])) ) {
                        stream_write(GDKout,&src[start],end-start,1); //flush
                        start = end+1;
                        switch( src[end] ) {
                         case '\t':
                                stream_write(GDKout,"\\t",2,1);
                                break;
                         case '\n':
                                stream_write(GDKout,"\\n",2,1);
                                break;
                         case '\\':
                                stream_write(GDKout,"\\\\ ",2,1);
                                break;
                         case '\"':
                                stream_write(GDKout,"\"",2,1);
                                break;
                         default: // case: not_allowed()
                                stream_printf(GDKout,"\\%03o",(unsigned char)src[end]);
                                stream_flush(GDKout);
                        }
                }
        }
        if ( start < end ) {
                stream_flush(GDKout);
                stream_write(GDKout,&src[start],end-start,1); // flush
        }
}

void emit(char* eventName, char* val, int escaped) {
        if ( val ) {
                if ( escaped ) {
                        stream_printf(GDKout,"[\"%s\",\t\"",eventName);
                        emit_escaped(val);
                        stream_printf(GDKout,"\"]\n");
                } else {
                        stream_printf(GDKout,"[\"%s\",\t\"%s\"]\n",eventName,val);
                }
        } else
                stream_printf(GDKout,"[%s,\tnil]\n",eventName);
}

void emit_end() {
}


/*
 *
 * The output handlers. Responslibe for generating the output representing
 * the handles xml structure. Cuurently 3 output structures are used:
 *
 * 1) plain xml text (ctx->saxMode is false)
 * 2) xml Sax-O-Phone stream (ctx->saxMode is true AND SAXOPHONE=1 )
 * 3) My own SAX event stream (ctx->saxMode is true AND SAXOPHONE=0 )
 *
 */

/* The SAXOPHONE define is a temporary flag used by JF to compile 'in'
 * his own Sax-O-Phone version which he thinks is much more efficient
 * than the original (but not as fancy) of course.
 */
#define SAXOPHONE 1

/**
 * Output generation handler. Handles equivalent of * SAX startDocument() event.
 */
void handle_startDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit_start();
                        // emit(START_DOC, NULL);
                } else
                        stream_printf(GDKout,"<S\n");
        } else { // xmlMode
                stream_printf(GDKout,"\n");
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endDocument() event.
 */
void handle_endDocument(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        // emit(END_DOC, NULL);
                        emit_end();
                } else 
                        stream_printf(GDKout,"<E\n");
        } else { // xmlMode
                stream_printf(GDKout,"\n\n");
        }
}

/**
 * Output generation handler. This one of my own invented event describing
 * the usage of an attribute. A sequnce of these events will be ended
 * by a handle_attributeEnd() call.
 */
void handle_attribute(XqueryCtx* ctx, str ns, str name, str value) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit(" attribute",name,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" attribute prefix",ns,0);
                        emit(" attribute value",value,0);
                } else {
                        stream_printf(GDKout,"<A %s=\"%s\"\n",name,value);
                }
        } else { // xmlMode
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout," %s:%s=\"%s\"",ns,name,value);
                } else {
                        stream_printf(GDKout," %s=\"%s\"",name,value);
                }
        }
}

/**
 * Output generation handler. This one of my own invented event indicating
 * there will be no more attribute events for this node.
 */
void handle_attributeEnd(XqueryCtx* ctx) {
        if (ctx->saxMode ) {
        } else { // xmlMode
                stream_printf(GDKout,">");
        }

}

/**
 * Output generation handler. Handles equivalent of * SAX startElement() event.
 */
void handle_startElement(XqueryCtx* ctx, str ns, str name /*,str *atts*/) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("startElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<s %s\n",name);
                }
        } else { // xmlMode
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"<%s:%s",ns,name);
                } else {
                        stream_printf(GDKout,"<%s",name);
                }
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX endElement() event.
 */
void handle_endElement(XqueryCtx* ctx, str ns, str name) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("endElement",NULL,0);
                        if ( ns && (strlen(ns)>0) )
                                emit(" prefix",ns,0);
                        emit(" localname",name,0);
                } else {
                        stream_printf(GDKout,"<e %s\n",name);
                }
        } else { // xmlMode
                if ( ns && strlen(ns)>0 ) {
                        stream_printf(GDKout,"</%s:%s>",ns,name);
                } else {
                        stream_printf(GDKout,"</%s>",name);
                }
        }
}

/**
 * Output generation handler. One on my own again. This one should handle a
 * reference. Don't know wat to to about it now.
 */
void handle_reference(XqueryCtx* ctx, str name) {
        if (ctx && name) {};
}

/**
 * Output generation handler. Handles equivalent of * SAX characters() event.
 */
void handle_characters(XqueryCtx* ctx, str ch) {
        if (ctx->saxMode ) {
                if ( SAXOPHONE ) {
                        emit("characters",NULL,0);
                        emit(" pcdata",ch,1);
                } else {
                        stream_printf(GDKout,"%s\n",ch);
                }
        } else { // xmlMode
                stream_printf(GDKout,"%s",ch);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX ignorableWhitespace()
 * event. I see no reason why it should be used here but I include it for
 * completeness.
 */
void handle_ignorableWhitespace(XqueryCtx* ctx, str ch) {
        handle_characters(ctx,ch); // dispatch
}

/**
 * Output generation handler. Again an own event. But this one should be
 * used I think because the comments are used and stored by  Pathfinder.
 */
void handle_comment(XqueryCtx* ctx, str comm) {
        if (ctx->saxMode ) {
                // INCOMPLETE
        } else { // xmlMode
                stream_printf(GDKout,"<!--%s-->",comm);
        }
}

/**
 * Output generation handler. Handles equivalent of * SAX processingInstruction() event.
 */
void handle_processingInstruction(XqueryCtx* ctx, str target, str data) {
        if (ctx->saxMode ) {
                // INCOMPLETE
        } else { // xmlMode
                stream_printf(GDKout,"<?%s %s?>",target,data);
        }
}

/*
 *
 *
 */

/**
 * OBSOLETE testing function. Should be removed (chk pathfinder.mx)
 */
int helloTEST(BAT** resBAT,str text) {
        int res = GDK_SUCCEED;

        stream_printf(GDKout,"Hello %s\n",text);
        // THRprintf(GDKout,"Hello %s\n",text);
        *resBAT = BATnew(TYPE_void,TYPE_str,10);
        return res;
}

/**
 * Utility function. It reads the tail value of an element in a 
 * [void,any] BAT indexed by oid_index. 
 */
ptr indexedTail(BAT* b, oid oid_index) {
        ptr res;

        if ( BUNsize(b) == 1 ) {
                // There is a probably bug in monet. The else code should work
                // for all situations but does not work for all BAT[void,chr]
                // arguments. At the moment some do and some don't.
                // I reported this bug once and then I could not reproduce
                // the failure. But it still fails for the 'kind' BAT in
                // the xquery_result_main() function
                BUN bun = BUNfirst(b);
                res = &bun[oid_index];
        } else {
                oid real_index = oid_index + 1; //this one cost me 2 hrs

                BUN bun = BUNptr(b,real_index);
                res = BUNtail(b,bun);
        }
        return res;
}

/**
 * Handle the generation of the attributes of the node with oid 'pre'. This
 * function is only called from the xquery_node_print() function.
 */
void query_attr_print(XqueryCtx* ctx, oid pre) {
        BAT* b = BATuselect(ctx->Tattr_own,&pre,&pre);

        BUN p, q; 
        BATloop(b, p, q) {
                oid id = *(oid*)BUNhead(b, p);
                str name = (str)indexedTail(ctx->Tattr_loc, id);
                str val  = (str)indexedTail(ctx->Tattr_val, id);
                str ns   = (str)indexedTail(ctx->Tattr_ns, id);
                handle_attribute(ctx,ns,name,val);
        }
        handle_attributeEnd(ctx);
        BATdelete(b);
}

/**
 * Handle the generation of the node with oid 'pre'.
 */
void xquery_node_print(XqueryCtx* ctx, oid pre) {
        chr kind = *(chr*)indexedTail(ctx->Tpre_kind,pre);
        oid prop = *(oid*)indexedTail(ctx->Tpre_prop,pre);
        switch( kind ) {
                case (char)0: {// ELEMENT
                        str name = (str)indexedTail(ctx->Tprop_loc,prop);
                        str ns   = (str)indexedTail(ctx->Tprop_ns,prop);
                        handle_startElement(ctx,ns,name);
                        query_attr_print(ctx,pre);

                        oid offset = *(oid*)indexedTail(ctx->Tpre_size,pre);
                        pushTag(ctx,pre+offset,ns,name);
                        break;
                        }
                case (char)1: {// TEXT
                        handle_characters(ctx,(str)indexedTail(ctx->Tprop_text,prop));
                        break;
                        }
                case (char)2: {// COMMENT
                        handle_comment(ctx,(str)indexedTail(ctx->Tprop_com,prop));
                        break;
                        }
                case (char)3: {// PI
                        str target = (str)indexedTail(ctx->Tprop_tgt,prop);
                        str data   = (str)indexedTail(ctx->Tprop_ins,prop);
                        handle_processingInstruction(ctx,target,data);
                        break;
                        }
                case (char)4: {// DOCUMENT
                        // The node represents an entire document
                        oid offset = *(oid*)indexedTail(ctx->Tpre_size,pre);
                        pushTag(ctx,pre+offset,"","");
                        break;
                        }
                default:
                        stream_printf(GDKout,"Unknow kind IN xquery_node_print");
        }
}

/**
 * handle the closing tag of a document.
 */
void xquery_endtag_print(XqueryCtx* ctx, oid pre) {
        while( moreTags(ctx) && (pre > topTag(ctx)) ) { //??
                if ( strlen(topName(ctx)) > 0 )
                        handle_endElement(ctx,topNs(ctx),topName(ctx));
                popTag(ctx);
        }
}

/**
 *
 * X. THE MAIN XML DOCUMENT PRINTING PART
 *
 * Main XML document printing routine
 */
int xquery_document_main(
                str  mode,
                BAT* cs,
                BAT* Tpre_size,
                BAT* Tpre_kind,
                BAT* Tpre_prop,
                BAT* Tprop_ns,
                BAT* Tprop_loc,
                BAT* Tprop_text,
                BAT* Tprop_com,
                BAT* Tprop_tgt,
                BAT* Tprop_ins,
                BAT* Tattr_own,
                BAT* Tattr_ns,
                BAT* Tattr_loc,
                BAT* Tattr_val
        ) {
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createContext(ctx, mode, Tpre_size, Tpre_kind, Tpre_prop, Tprop_ns,
                           Tprop_loc, Tprop_text, Tprop_com, Tprop_tgt,
                           Tprop_ins, Tattr_own, Tattr_ns, Tattr_loc,
                           Tattr_val);
        if ( BATcount(cs) == 0 )
                return GDK_SUCCEED;
        
        handle_startDocument(ctx);

        // lastpre := Tpre_size.reverse.fetch(Tpre_size.count - 1);
        BUN b = BUNptr(ctx->Tpre_size,BATcount(ctx->Tpre_size));
        oid lastpre = *(oid*)BUNhead(ctx->Tpre_size,b);

        BUN p, q; 
        BATloop(cs, p, q) {
                oid pre = *(oid*)BUNhead(cs, p);
                do {
                        xquery_node_print(ctx, pre);
                        xquery_endtag_print(ctx,++pre);
                } while( moreTags(ctx) && (pre<lastpre) );
        }
        if ( moreTags(ctx) ) {
                // INCOMPLETE, the next line works but WHY? Should work without
                xquery_endtag_print(ctx,(oid)-1);
        }
        handle_endDocument(ctx);
        //
        return GDK_SUCCEED;
}


/**
 * XI. THE MAIN PATHFINDER QUERY RESULT PART
 *
 * First the event/emit handlers for the sequnce are defined and after that
 * the main function
 */

#define XQRESTAG        "XqueryResult"

/**
 * Handle the start() of an XQUERY/Pathfinder result sequence
 */
void  seqStart(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_startElement(ctx,NULL,XQRESTAG);
        } else {
                stream_printf(GDKout,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
                stream_printf(GDKout,"<%s>\n",XQRESTAG);
                ctx->nAttrOnLine = 0;
        }
}

/**
 * Handle the end() of an XQUERY/Pathfinder result sequence
 */
void  seqEnd(XqueryCtx* ctx) {
        if ( ctx->saxMode ) {
                handle_endElement(ctx,NULL,XQRESTAG);
        } else {
                stream_printf(GDKout,"\n");
                stream_printf(GDKout,"</%s>\n",XQRESTAG);
        }
}


/**
 * Emit a NODE element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitNode(XqueryCtx* ctx, oid nv) {
        if ( ! ctx->saxMode ) {
                if ( ctx->nAttrOnLine > 0 ) {
                        stream_printf(GDKout,"\n");
                        ctx->nAttrOnLine = 0;
                }
        }
        //
        xquery_node_print(ctx, nv);
        //
        if ( ! ctx->saxMode ) {
                stream_printf(GDKout,"\n");
        }
}

/**
 * Emit a Boolean element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitBool(XqueryCtx* ctx, int bv) {
        char *bool_str = (char*)(bv?"true":"false");

        if ( ctx->saxMode ) {
                handle_characters(ctx,bool_str);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",bool_str);
        }
}

/**
 * Emit a Integer element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitInt(XqueryCtx* ctx, int iv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%d",iv);
                handle_characters(ctx,buff);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%d ",iv);
        }
}

/**
 * Emit a Double element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitDbl(XqueryCtx* ctx, dbl dv) {
        if ( ctx->saxMode ) {
                char buff[32];

                sprintf(buff,"%f",dv);
                handle_characters(ctx,buff);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"%f ",dv);
        }
}

/**
 * Emit a String element of an XQUERY/Pathfinder result sequence
 */
void  seqEmitStr(XqueryCtx* ctx, str sv) {
        if ( ctx->saxMode ) {
                handle_characters(ctx,sv);
        } else {
                ctx->nAttrOnLine++;
                stream_printf(GDKout,"\"%s\" ",sv);
        }
}

#define DEBUG_BAT       0

/**
 * Main XQUERY/Pathfinder result sequence printing routine. Arguments are
 * mode: "xml" or "sax"
 * item/kind : sequence result BATs
 * intVAL,dblVAL,decVAL,strVAL : BATSs containing the values of seq elements
 * remainder BATs: conatins the data for the document nodes
 *
 * The function iterates through the item/kind BAT's and retrieves the values
 * from the xxxVAL BATs. Then it calls one of the seqXXXXX() functions
 * defined above to handle the output generation.
 */
int xquery_result_main(
                str  mode,
                BAT* item,
                BAT* kind,
                BAT* intVAL,
                BAT* dblVAL,
                BAT* decVAL,
                BAT* strVAL,
                BAT* Tpre_size,
                BAT* Tpre_kind,
                BAT* Tpre_prop,
                BAT* Tprop_ns,
                BAT* Tprop_loc,
                BAT* Tprop_text,
                BAT* Tprop_com,
                BAT* Tprop_tgt,
                BAT* Tprop_ins,
                BAT* Tattr_own,
                BAT* Tattr_ns,
                BAT* Tattr_loc,
                BAT* Tattr_val
        ) {
        XqueryCtx  ctx_struct, *ctx = &ctx_struct;
        createContext(ctx, mode, Tpre_size, Tpre_kind, Tpre_prop, Tprop_ns,
                           Tprop_loc, Tprop_text, Tprop_com, Tprop_tgt,
                           Tprop_ins, Tattr_own, Tattr_ns, Tattr_loc,
                           Tattr_val);
        //
        if ( DEBUG_BAT ) {
                stream_printf(GDKout,"# RAW XQUERY RESULT:\n");
                stream_printf(GDKout,"# pre\tkind\tvaloid\tval\n");
                stream_printf(GDKout,"# ---\t----\t------\t---\n");
        }
        //
        seqStart(ctx);
        //
        BUN p, q; 
        BATloop(item, p, q) {
                oid pre = *(oid*)BUNhead(item, p);
                oid valoid = *(oid*)BUNtail(item, p);
                chr k = *(chr*)indexedTail(kind,pre);
                if ( DEBUG_BAT )
                        stream_printf(GDKout,"# %d\t%c\t%d\t",pre,k,valoid);
                switch( k ) {
                 case 'a': {
                        stream_printf(GDKout,"<!--attr-not-impl-yet-->\n");
                        break;
                        };
                 case 'b': {
                        if (DEBUG_BAT) stream_printf(GDKout,"%s\n",(valoid?"true":"false"));
                        seqEmitBool(ctx,valoid);
                        break;
                        }
                 case 'd': {
                        dbl dv = *(dbl*)indexedTail(dblVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); // INCOMPLETE ?diff between d and e
                        break;
                        }
                 case 'e': {
                        dbl dv = *(dbl*)indexedTail(decVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%f\n",dv);
                        seqEmitDbl(ctx,dv); // INCOMPLETE ?diff between d and e
                        break;
                        }
                 case 'i': {
                        int iv = *(int*)indexedTail(intVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"%d\n",iv);
                        seqEmitInt(ctx,iv);
                        break;
                        }
                 case 'n': {
                        if (DEBUG_BAT) stream_printf(GDKout,"NODE(%d)\n",valoid);
                        seqEmitNode(ctx, valoid);
                        break;
                        }
                 case 's': {
                        str sv = (str)indexedTail(strVAL,valoid);
                        if (DEBUG_BAT) stream_printf(GDKout,"\"%s\"\n",sv);
                        seqEmitStr(ctx,sv);
                        break;
                        }
                 default:
                        stream_printf(GDKout,"UNKNOW_TYPE(\'%c\'ch(%d))\n",k,k);
                }
        }
        //
        seqEnd(ctx);
        //
        return GDK_SUCCEED;
}

@c
/* vim:set shiftwidth=4 expandtab: */
