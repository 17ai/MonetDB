@ Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@'

@f xrpc_server
@a Ying Zhang

@t MIL primitives for XRPC server

@* Introduction
This module provides new MIL primitives for the server side support of
remote XQuery execution using HTTP connection on top of MonetDB for the
"AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_server;

@- HTTP server function(s)
@m
.COMMAND rpcd_start(int port, bit open, str options) : void = CMDrpcd_start;
"Start the HTTP server for RPC calls on the specified port."

.EPILOGUE = xrpc_epilogue;
.END xrpc_server;

@mil
# initialize xrpcd_admin: IPs that can execute modules from the special
# xrpc/admin directory
var xrpc_admin := bat(str,void);
xrpc_admin.insert(reverse(split(monet_environment.find("xrpc_admin"),";"))).bbpname("xrpc_admin");

# initialize xrpcd_user: IPs that can retrieve XML documents stored in
# the database using a URL of the form:
#               http://<host>[:port]/xrpc/<name>.xml
var xrpc_user := bat(str,void);
xrpc_user.insert(reverse(split(monet_environment.find("xrpc_user"),";"))).bbpname("xrpc_user");

# initialize xrpcd_trusted: URL prefixes for modules that anybody can execute
var xrpc_trusted := bat(str,void);
xrpc_trusted.insert(reverse(split(monet_environment.find("xrpc_trusted"),";"))).bbpname("xrpc_trusted");

proc add_xrpc_trusted(BAT[str,void] prefixes) : void {
    xrpc_trusted.insert(prefixes);
}

proc add_xrpc_trusted(BAT[void,str] prefixes) : void {
    xrpc_trusted.insert(prefixes.reverse());
}

proc add_xrpc_trusted(str prefix) : void {
    xrpc_trusted.insert(prefix, nil);
}

proc get_xrpc_open() : bit {
    if (monet_environment.exist("xrpc_open")){
        return bit(monet_environment.find("xrpc_open"));
    }
    ERROR("get_xrpc_open(): xrpc_open is not set\n");
}
ADDHELP("get_xrpc_open", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
Find if the XRPC server should accept connections from other hosts",
"xrpc_server");

proc get_xrpc_port() : int {
    var xrpc_port := int_nil;

    if (monet_environment.exist("xrpc_port"))
      if (length(monet_environment.find("xrpc_port")) > 0)
        xrpc_port := int(monet_environment.find("xrpc_port"));

    if (isnil(xrpc_port)) {
        var mapi_port := int_nil;
        if (monet_environment.exist("mapi_port")){
            mapi_port := int(monet_environment.find("mapi_port"));
        } else {
            ERROR("get_xrpc_port(): mapi_port is not set\n");
        }
        xrpc_port := mapi_port+1;
    }
    return xrpc_port;
}
ADDHELP("get_xrpc_port", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
find/calculate the port number to be used by the XRPC server",
"xrpc_server");

proc get_xrpc_options() : str {
    if (monet_environment.exist("xrpc_options")){
        return str(monet_environment.find("xrpc_options"));
    }
    return "";
}
ADDHELP("get_xrpc_options", "zhang", "March 2007",
"DESCRIPTION:\n\
Find the options that should be pass to the XRPC server, currently \
\"timing\" or \"debug\"",
"xrpc_server");

PROC rpcd_start() : void {
    var port := get_xrpc_port();
    xrpc_trusted.insert("http://127.0.0.1:"+str(port),nil);
    if (monet_environment.find("monet_welcome") = "yes") 
        printf("%c XRPC administrative console at http://127.0.0.1:%d/admin\n", int(35), port);
    fork( rpcd_start(port, get_xrpc_open(), get_xrpc_options()) );
}
ADDHELP("rpcd_start", "zhang", "Febuary 2007",
"DESCRIPTION:\n\
Start XPRC receiver using the default values as specified in \
\"monet_environment\"",
"xrpc_server");

@c
#include "pf_config.h"
#include <gdk.h>
#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "xrpc_common.h"
#include "xrpc_server.h"
#include "shttpd.h"

static int rpcd_running = 0;
static int timing = 0;
static int debug = 0;
static int listen_socket = -1;
static char datadir[1024];

/**
 * Retrieves the request message from the connection and shred it to
 * BATs.
 *
 * @return BATs containing the shredded request message, or
 *         NULL if an error has occurred.
 */
static BAT *
request2bat(stream *out, char *reqmsg)
{
    char *strptr = NULL;
    lng percentage = 0;
    BAT *shredBAT = NULL;
    bit verbose = FALSE;

    if(!reqmsg){
        send_err(out, ERR404, "env:Sender", "No request message!");
        return NULL;
    }

    /* Remove the first line of the message, which containing
     * "<?xml...?>", so that the message we pass to CMDshred2bats starts
     * directly with <env:Envelope ...> */
    strptr = reqmsg + 7; /* strlen("<?xml...?>") >= 7 */
    if( (strstr(reqmsg, "<?xml") != reqmsg) ||
        (strptr = strchr(strptr, (int)'<')) == NULL ) {
        send_err(out, ERR404, "env:Sender", NOT_WELL_FORMED);
        return NULL;
    }
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))) {
        send_err(out, ERR500, "env:Receiver", OUT_OF_MEM);
        return NULL;
    }
    
    if( CMDshred_str(shredBAT, strptr, &percentage, NULL, &verbose) == GDK_FAIL ) {
        send_err(out, ERR404, "env:Sender", NOT_WELL_FORMED);
        BBPreclaim(shredBAT);
        shredBAT = NULL;
    }
    return shredBAT;
}


XRPCreq_t *
parse_request(stream *out,
              BAT *shredBAT,
              bit isAdmin)
{
     /* request message parsing code  moved to xrpc_common as it is now also 
      * used for response message parsing 
      */
    return xrpc_parse_message(out, shredBAT, NULL, isAdmin);
}

/* return: 1: timedout; 0: not timedout; -1: not found; -2: other errors */
int
check_timeout_by_qid(char *qid, lng timeout)
{
    BATiter qidsi = bat_iterator(xrpc_qids);
    oid qid_idx = oid_nil;
    BUN bun_qid = BUN_NONE;
    int ret = 1;

    if(timeout > GDKusec())
        return 0; /* not timed out */

    MT_set_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
    if((bun_qid = BUNfnd(BATmirror(xrpc_qids), qid)) ==  BUN_NONE) {
        GDKerror("check_timeout_by_qid: "
                 "could not find QID \"%s\" in the meta-BAT "
                 "\"xrpc_qids\"\n", qid);
        ret = -1;
    }
    qid_idx =  *(oid*)BUNtail(qidsi, bun_qid);
    if(!BUNreplace(xrpc_statuses, &qid_idx, "timedout", FALSE)){
        MT_unset_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
        GDKerror("check_timeout_by_qid: "
                 "failed to change the status of query \"%s\" into "
                 "\"timedout\"\n", qid);
        ret = -2;
    }
    MT_unset_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
    return ret; /* timed out */
}


/**
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int
execQuery(mapi_client *mc,
          int flags,
          XRPCreq_t *req,
          BAT *shredBAT)
{
    int ret = GDK_SUCCEED;
	char errbuf[GDKMAXERRLEN], errbuf_all[GDKMAXERRLEN*2], *errbuf_bak = GDKerrbuf;

    /* Possible values of flags:
     * 0: xml-noheader-xrpc
     *    This is the normal serialize mode used for XRPC calls
     * 1: timing
     *    Let the XRPC server print the time of XRPC_Server_Application
     *    and XRPC_Network_Server_2_Client at the server side.
     * 2: xml
     *    Used for the GET, PUT, DELETE HTTP requests to avoid "xrpc"
     *    mode of serialization
     * 3. timing-xml
     *    Again, print time info at the XRPC server side, but is usually
     *    not used.
     * 4. debug
     *    Get generated MIL code in "/tmp/xrpc.mil", hence, this option
     *    is not portable.
     */
	*errbuf = 0;
	GDKsetbuf(errbuf);
    char *err = xquery_method(mc, flags, req->mode, req->module, 
            req->location, req->method, req->qid, req->caller, req->timeout,
            req->argc, req->iterc, req->argcnt, req->argtpe, req->argval, 
            req->hasNodeParam?shredBAT:NULL);

    /* If no error occurred during execution, the serializer would check
     * query expiration time, before printing results */
    if(*errbuf && strstr(errbuf, "xrpc query timed out")) {
        ret = GDK_FAIL;
        snprintf(errbuf_all, GDKMAXERRLEN*2, "%s\n%s", (err && *err) ? err : "", errbuf);
        send_err(mc->c->fdout, ERR504, "env:Receiver", errbuf_all);
    } else if (err) {
        ret = GDK_FAIL;
        /* if error was caused by other problems, we haven't checked
         * query expiration time */
        int tdo = check_timeout_by_qid(req->qid, req->start + req->timeout);
        snprintf(errbuf_all, GDKMAXERRLEN*2,
                "Error occurred during execution:\n%s\n%s\n%s",
                tdo > 0 ? "xrpc query timed out" : "",
                *errbuf ? errbuf : "",
                err == ((char*)-1) ? "no further error message" : err);
        send_err(mc->c->fdout, tdo > 0 ? ERR504 : ERR404,
                               tdo > 0 ? "env:Receiver" : "env:Sender",
                               errbuf_all);
    } else if (req->updCall) {
        /* updating functions donot involve the serializer, hence,
         * time-out not checked yet */
        ret = check_timeout_by_qid(req->qid, req->start + req->timeout);
        if(ret){
            snprintf(errbuf_all, GDKMAXERRLEN*2,
                    "Error occurred when checking query expiration time:\n%s\n%s",
                    ret > 0 ? "xrpc query timed out" : "",
                    *errbuf ? errbuf : "no further error message.");
            send_err(mc->c->fdout, ret > 0 ? ERR504 : ERR404,
                                   ret > 0 ? "env:Receiver" : "env:Sender",
                                   errbuf_all);
            ret = GDK_FAIL;
        } else { /* send empty HTTP OK header for updating request */
            stream_write(mc->c->fdout, "HTTP/1.1 200 OK\r\n"
                    "Content-type: text/xml; charset=\"utf-8\"\r\n\r\n", 1, 60);
        }
    }

    stream_flush(mc->c->fdout);
	GDKsetbuf(errbuf_bak);
    return ret;
}

/**
 * The XRPC server callback function.
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    XRPCreq_t *req;
    BAT *shredBAT;
    lng time_xrpcServDeSeria;
    int flags = timing|debug; 

    time_xrpcServDeSeria = GDKusec();
    if(!(shredBAT = request2bat(mc->c->fdout, shttpd_get_msg(arg))))
        return GDK_FAIL;

    if(!(req = parse_request(mc->c->fdout, shredBAT, 0))) {
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    }
    time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;
    
    /* Execute the query and send XRPC response */
    if(execQuery(mc, flags, req, shredBAT) == GDK_FAIL) {
        BBPreclaim(shredBAT);
        XRPCreq_free(req);
        return GDK_FAIL;
    }

    if (timing) {
        fprintf(stdout,
                "XRPC_Server_DeSerialisation:   " LLFMT " microsec\n",
                time_xrpcServDeSeria);
    }

    BBPreclaim(shredBAT);
    XRPCreq_free(req);
    return GDK_SUCCEED;
}


/**
 * The MonetDB/XQuery Document Management callback function.
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_admin_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    XRPCreq_t *req;
    int flags = 0;
    BAT *shredBAT;
    char dotted[80];
    /* Work arround for the problem that when only loading
     * the xrpc_client/xrpc_server module (without first load
     * module(pathfinder)), the linker doesn't realize that although
     * lib_logger is not used by the XRPC modules, it is needed by
     * lib_pathfinder.  This results in the error:
     * lib_pathfinder.so.0: undefined symbol: TYPE_logger.
     * So here, we misuse the not-yet-initialized 'ret' to add a
     * dependency on lib_logger in xrpc_server.
     */
    int ret = TYPE_logger;

    struct in_addr addr = shttpd_get_inAddr(arg);
#ifdef HAVE_INET_NTOP
    (void) inet_ntop(AF_INET, (void*) &addr, dotted, sizeof(dotted));
#else
    /* not normally thread safe, but on Windows where we need this it
     * actually *is* thread safe */
    strncpy(dotted, inet_ntoa(addr), sizeof(dotted));
#endif
    if (!isAllowed(xrpc_admin, dotted)) {
        char err[1024];
        snprintf(err, 1024, "Permission denied: your host (%s) "
                "does not have admin rights", dotted);
        send_err(mc->c->fdout, ERR403, "env:Sender", err);
        return GDK_FAIL;
    }

    shredBAT = request2bat(mc->c->fdout, shttpd_get_msg(arg));
    if(!shredBAT)
        return GDK_FAIL;

    if(!(req = parse_request(mc->c->fdout, shredBAT, 1))) {
        BBPreclaim(shredBAT);
        return GDK_FAIL;
    } else if (req->qid) {
        send_err(mc->c->fdout, ERR404, "env:Sender",
                "Multi-request transaction not allowed for admin functions");
        BBPreclaim(shredBAT);
        XRPCreq_free(req);
        return GDK_FAIL;
    }

    if(strcmp(req->module, MXQ_ADMIN) != 0){
        send_err(mc->c->fdout, ERR404, "env:Sender", "Invalid namespace of admin module");
        BBPreclaim(shredBAT);
        XRPCreq_free(req);
        return GDK_FAIL;
    }

    ret = execQuery(mc, flags, req, shredBAT);
    BBPreclaim(shredBAT);
    XRPCreq_free(req);
    return ret;
}

/**
 * Handle the document retrieving request using a URL of the form:
 *          http://<host>[:port]/xrpc/doc/<name>.xml
 *
 * @return GDK_SUCCEED, or
 *         GDK_FAIL if an error has occurred.
 */
static int 
xrpc_handle_file_request(mapi_client *mc, struct shttpd_callback_arg *arg)
{
    XRPCreq_t *req;
    char *method = NULL, *uri = NULL;
    char location[1024];
    int ret = GDK_FAIL, flags = 2|timing|debug;

    lng time_xrpcServDeSeria = GDKusec();

    /* skip callback identifier that directed us here */
    uri = shttpd_get_uri(arg) + strlen(XRPC_DOC_CALLBACK);
    /* we don't always have the second '/' */
    if(uri[0] == '/') uri++;
    if(uri[0] == '\0'){
        send_err(mc->c->fdout, ERR403, "env:Sender", "Directory listing denied");
        return GDK_FAIL;
    }

    snprintf(location, 1024, "http://127.0.0.1:%d/admin/admin.xq", xrpc_port);
    method = shttpd_get_method(arg);

    if (strcmp(method, "PUT") == 0) {
        lng percentage = 1;
        bit verbose = FALSE;
        BAT *shredBAT = NULL;
        
        if(!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))) {
            send_err(mc->c->fdout, ERR500, "env:Receiver", OUT_OF_MEM);
            return GDK_FAIL;
        }

        if((ret = CMDshred_str(shredBAT, shttpd_get_msg(arg), &percentage, NULL, &verbose)) == GDK_FAIL) {
            BBPreclaim(shredBAT);
            send_err(mc->c->fdout, ERR404, "env:Sender", NOT_WELL_FORMED);
            return ret;
        }

        if(!(req = XRPCreq_new(NULL, NULL, 0, NULL, MXQ_ADMIN, method, location, FALSE, 1, 2))) {
            send_err(mc->c->fdout, ERR500, "env:Receiver", OUT_OF_MEM);
            BBPreclaim(shredBAT);
            return GDK_FAIL;
        }

        req->argtpe[0] = XS_STRING;
        req->argtpe[1] = XS_DOCUMENT;
        req->argval[0] = uri;
        req->argval[1] = "0";
        req->argcnt[0][0] = req->argcnt[0][1] = 1;

        time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;

        ret = execQuery(mc, flags, req, shredBAT);
        BBPreclaim(shredBAT);
    } else { /* GET/DELETE */
        if(!(req = XRPCreq_new(NULL, NULL, 0, NULL, MXQ_ADMIN, method, location, FALSE, 1, 1))) {
            send_err(mc->c->fdout, ERR500, "env:Receiver", OUT_OF_MEM);
            return GDK_FAIL;
        }

        req->argtpe[0] = XS_STRING;
        req->argval[0] = uri;
        req->argcnt[0][0] = 1;

        time_xrpcServDeSeria = GDKusec() - time_xrpcServDeSeria;

        ret = execQuery(mc, flags, req, NULL);
    }

    if (timing)
        fprintf(stdout, "XRPC_Server_DeSerialisation:   %lld microsec\n",
                time_xrpcServDeSeria);

    XRPCreq_free(req);
    return ret;
}

/*
 * XRPC MAPI client handler (overrides the xquery_client_engine)
 */
static void 
xrpc_client_engine(mapi_client *mc)
{
    struct shttpd_callback_arg *arg = (struct shttpd_callback_arg *) mc->arg;
    char *uri = shttpd_get_uri(arg);

    /* 'admin' and 'file' requests are one-time request, no isolation
     * needed/supported */
    if (strncmp(uri, XRPC_ADM_CALLBACK, strlen(XRPC_ADM_CALLBACK)) == 0) {
        (void) xrpc_handle_admin_request(mc, arg);
    } else if (strncmp(uri, XRPC_DOC_CALLBACK, strlen(XRPC_DOC_CALLBACK)) == 0) {
        (void) xrpc_handle_file_request(mc, arg); /* GET/PUT/DELETE file request */
    } else if (strncmp(uri, XRPC_REQ_CALLBACK, strlen(XRPC_REQ_CALLBACK)) == 0) {
        (void) xrpc_handle_request(mc, arg);
    }

    /* clean up */
    mc->engine = xquery_client_engine;
    xquery_client_end(mc, NULL);
    shttpd_finish(arg);
}


/*
 * handle request asynchronously using a MAPI xquery client
 */
static int
xrpc_fork_mapiclient(struct shttpd_callback_arg *arg)
{

    int sock = shttpd_get_socket(arg);

    /* get a MAPI thread from the xquery client pool */
    stream *fdin = socket_rastream(sock, "XRPC read");
    if (fdin && stream_errnr(fdin) == 0) {
        stream *fdout = wbstream(socket_wastream(sock, "XRPC write"), 8192);
        if (fdout && stream_errnr(fdout) == 0) {
            mapi_client *mc = MAPIclient(fdin, fdout, "xquery");
            if (mc) {
                /* override xquery_client_engine (will be restored later) */ 
                mc->engine = xrpc_client_engine;
                mc->arg = (char*) arg; /* HACK! pass xrpc arg */
                MT_up_sema(mc->s, "XRPC"); /* activate the thread */
                return 0;
            }
            stream_close(fdout);
            stream_destroy(fdout);
        }
        stream_close(fdin);
        stream_destroy(fdin);
    }
    shttpd_finish(arg);
    return -1;
}

/* the thread that checks every 5 seconds for expired queries */
MT_Id checker;

int
CMDrpcd_start(int *port, bit *open, str options)
{
    shttpd_socket ctx;
    char *s;
    
    if (rpcd_running) {
        stream_printf(GDKout,
                "\nRPC receiver already running (on port %d)\n",
                xrpc_port);
        return GDK_SUCCEED;
    }

    xrpc_port = *port;
    rpcd_running = 1;

    /* find 'datadir' (often datadir = <prefix>/share), otherwise use
     * "/usr/share", hence, httpd serves out <datadir>/MonetDB/xrpc */
    if( !(s = GDKgetenv("datadir")) ){
        snprintf(datadir, 1024, "%cusr%cshare%cMonetDB%cxrpc",
                DIR_SEP, DIR_SEP, DIR_SEP, DIR_SEP);
    } else {
        snprintf(datadir, 1024, "%s%cMonetDB%cxrpc", s, DIR_SEP, DIR_SEP);
    }
    shttpd_setopt("document_root", datadir);

    shttpd_init(NULL); /* Initialize httpsd thread */

    if (options && *options) {
        if(strstr(options, "timing"))
            timing = 1;
        if(strstr(options, "debug"))
            debug = 4;
    }

    /* Register call back function, for XRPC (admin) requests, and XML (get/put/delete) file handling */
    shttpd_register_url(XRPC_REQ_CALLBACK, xrpc_fork_mapiclient, NULL);
    shttpd_register_url(XRPC_DOC_CALLBACK, xrpc_fork_mapiclient, NULL);
    shttpd_register_url(XRPC_ADM_CALLBACK, xrpc_fork_mapiclient, NULL);

    /* Open listening socket */
    ctx = shttpd_open_port(xrpc_port, *open);
    listen_socket = ctx.sock;

    /* Serve connections infinitely until someone kills us */
    for ( ; rpcd_running; ) shttpd_poll(&ctx, 200);

    return GDK_SUCCEED;
}

void xrpc_epilogue(void)
{
    shttpd_fini();      /* Shut down the HTTP server. */
    rpcd_running = 0;   /* Stop RPC server */
    if (listen_socket >= 0)
        close(listen_socket);
    listen_socket = -1;
}
/* vim:set shiftwidth=4 expandtab: */
