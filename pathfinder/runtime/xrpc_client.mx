@ Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@'

@f xrpc_client
@a Ying Zhang

@t MIL primitives of XRPC client

@* Introduction
This module provides new MIL primitives for the client side support of
remote XQuery execution using HTTP connection on top of MonetDB for
the "AmbientDB" project.
@
@* Module Definition
@m
.MODULE xrpc_client;

@- HTTP client function(s)
@m

.USE lock;

.COMMAND http_post(
        str genType,
        str qid,
        lng timeout,
        lng seqnr,
        str dst,
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng itercnt,
        BAT[void, bat] ws,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[str, bat] = CMDhttp_post;
"Create and send a RPC request message to the specified destination"

.END xrpc_client;

@mil
PROC get_rpc_res ( 
        oid cont, 
        str local_name, 
        BAT[void, bat] ws, 
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values, 
        BAT[void, str] str_values) : BAT[void, bat]
{
    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    
    var pre_size  := ws.fetch(PRE_SIZE).fetch(cont);
    var pre_level := ws.fetch(PRE_LEVEL).fetch(cont).access(BAT_WRITE);
    var pre_prop  := ws.fetch(PRE_PROP).fetch(cont).access(BAT_WRITE);
    var pre_kind  := ws.fetch(PRE_KIND).fetch(cont).access(BAT_WRITE);

    var qn_prefix := ws.fetch(QN_PREFIX).fetch(cont);
    var qn_uri    := ws.fetch(QN_URI).fetch(cont);
    var qn_loc    := ws.fetch(QN_LOC).fetch(cont);
    var prop_text := ws.fetch(PROP_TEXT).fetch(cont);

    var attr_own  := ws.fetch(ATTR_OWN).fetch(cont);
    var attr_qn   := ws.fetch(ATTR_QN).fetch(cont);
    var attr_prop := ws.fetch(ATTR_PROP).fetch(cont);
    var prop_val  := ws.fetch(PROP_VAL).fetch(cont);

    # Get "pre_prop" value of an "sequence" node.
    var seq_prop;
    var err := CATCH (seq_prop := qn_loc.ord_uselect("sequence").reverse().fetch(0));
    if (not(isnil(err)))
        ERROR("get_rpc_res expects at least *one* \"<sequence>\" tag.\n");

    # Fetch the position of the first "pre_prop" value of the "sequence"
    # node.  Must use "ord_uselect" and "fetch", since the the "pre_prop"
    # value can appear more than once in the "pre_prop" bat.
    seq_prop := pre_prop.ord_uselect(seq_prop).reverse().fetch(0);

    var seq_node_level :=  pre_level.find(seq_prop).int();
    var tpe_node_level :=  seq_node_level + 1;
    var val_node_level :=  tpe_node_level + 1;
    var itercnt := 0;
    var tpe := "";
    var subtpe := "";
    var xrpc_ns := "http://monetdb.cwi.nl/XQuery";
    var xsi_ns := "http://www.w3.org/2001/XMLSchema-instance";
 
    # To reduce #iter: everything before the first "sequence" is
    # not used, so do not iterate over them.
    var i := int(seq_prop);
    var size := pre_size.fetch(0);
    while(i <= size){
        var inc := 1;
        if (not(isnil(pre_size.fetch(i)))) { # Skip holes in the BATs
            var pre   := oid(i);
            var level := pre_level.fetch(pre).int();
            var kind  := pre_kind.fetch(pre);
            var prop  := pre_prop.fetch(pre);

            if ( and(level = seq_node_level, kind='\000') ){
                var loc := qn_loc.fetch(prop);
                var uri := qn_uri.fetch(prop);
                if (and((loc = "sequence"), (uri = xrpc_ns))) {
                    itercnt :+= 1; # A new iteration starts
                }
            } else if ( and(level = tpe_node_level, kind='\000') ){
                var tpe_node_ns := qn_uri.fetch(prop);
                if (tpe_node_ns != xrpc_ns) {
                    ERROR("[get_rpc_res]: (pre=%d): " +
                          "invalid namespace of a type node.\n" +
                          "[get_rpc_res]: expected \"%s\", " +
                          "got \"%s\".\n",
                          pre, xrpc_ns, tpe_node_ns);
                }
                tpe := qn_loc.fetch(prop);
                if (tpe = "atomic-value") {
                    var tpe_qn_qn := qn_loc.ord_uselect("type").mirror();
                    var tpe_qn_ns := qn_uri.ord_uselect(xsi_ns);
                    tpe_qn_qn := tpe_qn_qn.join(tpe_qn_ns).mirror();

                    var tpe_attr_qn := attr_qn.join(tpe_qn_qn);
                    var tpe_attr_attr := attr_own.ord_uselect(pre).mirror();
                    tpe_attr_attr := tpe_attr_attr.join(tpe_attr_qn).mirror();
                    if (count(tpe_attr_attr) != 1) {
                        ERROR("get_rpc_res (batloop %d): " +
                              "\"atomic-value\" should only have one " +
                              "\"xsi:type\" attributed!\n", pre);
                    }
                    var tpe_attr_prop := tpe_attr_attr.join(attr_prop);
                    subtpe := tpe_attr_prop.join(prop_val).fetch(0);
                    subtpe := subtpe.substring(subtpe.search(":") + 2); # remove the prefix
                } else if (tpe = "document") {
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    # Replace the values of this type node with values
                    # for a document node
                    pre_level := replace(pre_level, pre, ('\000' - '\001'));
                    pre_prop  := replace(pre_prop,  pre, oid_nil);
                    pre_kind  := replace(pre_kind,  pre, '\004');
                    inc := pre_size.fetch(i);
                } else if (tpe = "attribute") {
                    var attr := attr_own.select(pre);
                    var aprop := attr.mirror().join(attr_prop);

                    res_iter.append(oid(itercnt));
                    res_item.append(aprop);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ATTR);
                    res_kind.append(k);
                }
            } else if (level = val_node_level) {
                # 'tpe' was set during the previous iteration of 'batloop'
                if ( and(tpe = "element", kind='\000') ){
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    inc := pre_size.fetch(i);
                    tpe := ""; # clean up type info
                } else if (tpe = "text") { # text value of a text node
                    if (kind != '\001'){
                        ERROR("get_rpc_res (batloop %d): a text node " +
                              "should have a single text value\n", pre);
                    }
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    tpe := ""; # clean up type info
                } else if (tpe = "atomic-value") { # string value of an atomic-value
                    var val := prop_text.fetch(prop); # value in str
                    if (subtpe = "boolean"){ 
                        var o := oid(toUpper(val) = "TRUE");
                        res_iter.append(oid(itercnt));
                        res_item.append(o);
                        res_kind.append(BOOL);
                    } else if (subtpe = "integer"){
                        var i := lng(val);
                        int_values.append(i);
                        res_iter.append(oid(itercnt));
                        res_item.append(int_values.reverse().find(i));
                        res_kind.append(INT);
                    } else if(subtpe = "decimal") {
                        var d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DEC);
                    } else if(or( (subtpe = "float"), (subtpe = "double") )) {
                        var d := dbl(val);
                        dbl_values.append(d);
                        res_iter.append(oid(itercnt));
                        res_item.append(dbl_values.reverse().find(d));
                        res_kind.append(DBL);
                    } else if(or(subtpe = "string", subtpe = "untypedAtomic")) {
                        str_values.append(val);
                        res_iter.append(oid(itercnt));
                        res_item.append(str_values.reverse().find(val));
                        res_kind.append(STR);
                    } else {
                        printf("get_rpc_res (batloop %d): atomic " +
                               "value with unsupported type \"%s\" " +
                               "ignored.\n", subtpe);
                    }
                    tpe := ""; # clean up type info
                } else if (tpe = "comment") { # text value of a comment node                
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    tpe := ""; # clean up type info
                } else if (tpe = "processing-instruction") { # text value of a PI node
                    res_iter.append(oid(itercnt));
                    res_item.append(pre);
                    var k := set_kind(local_name.leftjoin(reverse(ws.fetch(CONT_NAME))).tmark(0@0), ELEM);
                    res_kind.append(k);
                    tpe := ""; # clean up type info
                } 
            } # END 'if (level = ...)'
        } # END 'if (not(isnil(pre_size.fetch(i))))'
        i := i + inc;
    } # END 'while(i < size)'

    pre_level := ws.fetch(PRE_LEVEL).fetch(cont);
    pre_prop  := ws.fetch(PRE_PROP).fetch(cont);
    pre_kind  := ws.fetch(PRE_KIND).fetch(cont);

    return bat(void,bat,4).append(res_iter).append(res_item).append(res_kind).access(BAT_READ);
}
ADDHELP("get_rpc_res", "zhang", "April 2006",
"DESCRIPTION:\n\
This proc is used to retrieve the return values of RPC call(s), which \
are temporarily stored in the WS. It\n\
1. retrieves the right values\n\
2. builds temporary iter|item|kind BATs\n\
3. fill in the value containers",
"xrpc_client");

PROC doLoopLiftedRPC(
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    var unq_dsts := dsts.tunique().hmark(0@0);
    var steps := unq_dsts.count();
    var rpcerr_lock := lock_create(); # guards rpc_errors
    var rpc_errors := ""; # holds errors from each destination
    var rpcres_lock := lock_create(); # guards rpc_results and rpc_iter
    var rpc_results := bat(str,oid);
    var rpc_iter := bat(void,bat).seqbase(0@0);
    var off := count(ws.fetch(CONT_NAME));

    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_wsids).find(xrpc_id)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
        lock_unset(wslock);
    }
    unq_dsts @ [steps] batloop(){
        var time_xrpcClntSeria := usec();

        # get iteration numbers for this destination
        var iter_dst := [oid](rpc_dsts.ord_uselect($t).reverse());
            iter_dst := iter_dst.reverse().mirror();
        var itercnt := iter_dst.count().lng();

        # retrieve the frag of fun_vid, fun_iter, fun_item and fun_kind
        # for this iteration.

        # order of 'fun_iter' needs to be preserved, so use 'leftjoin',
        # iso. 'join'.
        var fun_iter_dst := fun_iter.leftjoin(iter_dst);
        var indices      := fun_iter_dst.mirror().hmark(0@0);
        var fun_vid_dst  := indices.fetchjoin(fun_vid).tmark(0@0);
        var fun_item_dst := indices.fetchjoin(fun_item).tmark(0@0);
        var fun_kind_dst := indices.fetchjoin(fun_kind).tmark(0@0);

        # renumber the iters, starting from 1
        fun_iter_dst := fun_iter_dst.leftjoin(iter_dst.mark(1@0));
        fun_iter_dst := [oid](fun_iter_dst.tmark(0@0));

        time_xrpcClntSeria := usec() - time_xrpcClntSeria;
        if (genType.search("timing") >= 0) {
            printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                    time_xrpcClntSeria);
        }

        var local_name := "rpc_res_00" + str(int($h)+off);
        var rpc_res, timeout := max(0LL,xrpc_timeout - (usec() - timer_start));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_qid, xrpc_seqnr, timeout, $t, module, location, method,
                    updCall, arity, itercnt, ws, fun_vid, fun_iter, fun_item,
                    fun_kind, int_values, dbl_values, dec_values, str_values));

        var time_xrpcClntDeSeria := usec();

        if (isnil(rpc_err)) {
            if (not(updCall)) {
                lock_set(rpcres_lock);
                rpc_results.insert(local_name,rpc_res);
                rpc_iter.append(iter_dst.hmark(1@0));
                lock_unset(rpcres_lock);
            }
            time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
            if (genType.search("timing") >= 0) {
                printf("XRPC_Client_DeSerialisation (insert_rpc_res): %lld microsec\n",
                        time_xrpcClntDeSeria);
            }
        } else {
            printf("doLoopLiftedRPC: error occurred at %s:\n%s\n", $t, rpc_err);
            if(xrpc_qid != "") {
                # abort a 2PC-XRPC query on error
                lock_set(xrpc_lock);
                CATCH({xrpc_statuses.replace(idx, "abort");});
                lock_unset(xrpc_lock);
                # TODO: stop immediately further execution and clean up
            } else {
                # A none-isolation XRPC query: we do not want to discard
                # results from other destinations where executions might
                # have succeeded, so we only print a message by error,
                # iso. terminate the execution with 'ERROR'
                lock_set(rpcerr_lock);
                CATCH({ rpc_errors := rpc_errors + $t + ": " + rpc_err + "\n"; });
                lock_unset(rpcerr_lock);
            }
        }
    }
    if (xrpc_qid != "") lock_set(wslock);
    lock_destroy(rpcres_lock);
    lock_destroy(rpcerr_lock);

    var time_xrpcClntDeSeria := usec();

    var res_iter := bat(void,oid).seqbase(0@0);
    var res_item := bat(void,oid).seqbase(0@0);
    var res_kind := bat(void,int).seqbase(0@0);
    var res_bats := bat(void,bat,4).seqbase(0@0);

    if(updCall){
        # If called function is an updating function, there is no
        # results to retrieve.  So, return empty BATs.
        res_bats.append(res_iter).append(res_item).append(res_kind);
        return res_bats.access(BAT_READ);
    }

    if(count(rpc_results) = 0) {
        ERROR("doLoopLiftedRPC: execution failed at all destinations:\n%s\n", rpc_errors);
    } else if(rpc_errors != "") {
        printf("doLoopLiftedRPC: execution failed at some destinations:\n%s\n", rpc_errors);
    }

    # retrieve results for this destination, and map the results back to
    # the original iteration number
    var proc_res := [get_rpc_res](
            [ws_opencoll](const ws, rpc_results.tmark(0@0), local_name, TEMP_DOC),
            rpc_results.hmark(0@0), const ws, const int_values,
            const dbl_values, const str_values);

    res_iter := proc_res.[fetch](0).[leftfetchjoin](rpc_iter);
    res_item := proc_res.[fetch](1);
    res_kind := proc_res.[fetch](2);

    # initialize res_bat with the results for the first destination
    res_bats.append(res_iter.fetch(0));
    res_bats.append(res_item.fetch(0));
    res_bats.append(res_kind.fetch(0));

    # if there were more destinations, merge the result tables 
    var i := 0;
    while ((i :+= 1) < steps) {
        # initialize res_bat with the results for the first destination 
        res_bats := merged_union(res_bats.fetch(0), res_iter.fetch(i), 
                                 res_bats.fetch(1), res_item.fetch(i), 
                                 res_bats.fetch(2), res_kind.fetch(i));
    }

    time_xrpcClntDeSeria := usec() - time_xrpcClntDeSeria;
    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_DeSerialisation (get_rpc_res):    %lld microsec\n",
                time_xrpcClntDeSeria);
    }

    return res_bats;
}
ADDHELP("doLoopLiftedRPC", "zhang", "April 2006",
"DESCRIPTION: implementation of the loop-lifted RPC",
"xrpc_client");

PROC doIterativeRPC(
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void,BAT] ws,
        BAT[oid, str] dsts,
        BAT[void,oid] fun_vid,
        BAT[void,oid] fun_iter,
        BAT[void,oid] fun_item,
        BAT[void,int] fun_kind,
        BAT[void,lng] int_values,
        BAT[void,dbl] dbl_values,
        BAT[void,dbl] dec_values,
        BAT[void,str] str_values) : BAT[void,bat]
{
    # unlock the working set while making the calls (enables circular patterns nested 2PC xrpc calls)
    var wslock;
    if (xrpc_qid != "") {  
        lock_set(xrpc_lock);
        var err := CATCH(wslock := xrpc_locks.fetch(reverse(xrpc_wsids).find(xrpc_id)));
        lock_unset(xrpc_lock);
        if (not(isnil(err))) ERROR(err);
    }

    var time_xrpcClntSeria := 0;
    var time_xrpcClntDeSeria := 0;

    var res_bats := nil;
    var h := 0;
    var t := 1;
    while (lng(h) < niters){
        # get function parameters for this destination
        var time_xrpcClntSeriaStart := usec();
        var dst := dsts.fetch(h);
        var cur_fun_iter := fun_iter.select(oid(t));
        var cur_fun_vid  := fun_vid.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_item := fun_item.fetch(cur_fun_iter.mirror()).tmark(0@0);
        var cur_fun_kind := fun_kind.fetch(cur_fun_iter.mirror()).tmark(0@0);
        # renumber cur_fun_iter, we only have one iteration
        cur_fun_iter := cur_fun_iter.tmark(0@0).project(1@0);
        time_xrpcClntSeria := time_xrpcClntSeria + (usec() - time_xrpcClntSeriaStart);

        var local_name := "rpc_res_00" + str(h+1);
        if (xrpc_qid != "") lock_unset(wslock);
        var rpc_res, timeout := max(0LL,xrpc_timeout - (usec() - timer_start));
        var rpc_err := CATCH(rpc_res := http_post(genType, xrpc_qid, xrpc_seqnr, timeout, $t, module, location, method,
                    updCall, arity, lng(1), ws, cur_fun_vid, cur_fun_iter, cur_fun_item,
                    cur_fun_kind, int_values, dbl_values, dec_values, str_values));
        if (xrpc_qid != "") lock_set(wslock);


        # add result of this iteration to result BATs
        var time_xrpcClntDeSeriaStart := usec();
        if (isnil(rpc_err)) {
            if (updCall != 1) {
                var rpc_oid := ws_opencoll(ws, rpc_res, local_name, TEMP_DOC);
                var res := get_rpc_res(rpc_oid, local_name, ws,
                                       int_values, dbl_values, str_values);
                if (isnil(res_bats)){
                    res_bats := res;
                } else {
                    # merge results of this iteration into existing results.
                    res_bats := merged_union(res_bats.fetch(0), res.fetch(0), 
                                             res_bats.fetch(1), res.fetch(1), 
                                             res_bats.fetch(2), res.fetch(2));
                }
            }
        } else {
            # We do not want to discard results from other destinations
            # where executions might have succeeded, so we only print a
            # WARNING by error, iso. terminate the execution with 'ERROR'
            printf("!WARNING: doIterativeRPC: ");
            printf("error occurred during RPC call to \"%s\".\n", dst);
            printf("!WARNING: Received error was: \n%s\n", rpc_err);
        }
        h := h + 1;
        t := t + 1;

        time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);
    }

    var time_xrpcClntDeSeriaStart := usec();
    if (not(updCall)){
        # If called function is an updating function, there is no
        # results to retrieve.  So, return empty BATs.
        var res_iter := bat(void,oid).seqbase(0@0);
        var res_item := bat(void,oid).seqbase(0@0);
        var res_kind := bat(void,int).seqbase(0@0);

        res_bats := bat(void,bat,4).seqbase(0@0);
        res_bats.append(res_iter).append(res_item).append(res_kind);
        res_bats.access(BAT_READ);
    }

    time_xrpcClntDeSeria := time_xrpcClntDeSeria + (usec() - time_xrpcClntDeSeriaStart);

    if (genType.search("timing") >= 0) {
        printf("XRPC_Client_Serialisation (get_dst_params):   %lld microsec\n",
                time_xrpcClntSeria);
        printf("Client_DeSerialisation (get_rpc_res):        %lld msec\n",
                time_xrpcClntDeSeria);
    }

    if(isnil(res_bats)) {
        ERROR("doIterativeRPC: execution of all iterations failed");
    }

    return res_bats;
}
ADDHELP("doIterativeRPC", "zhang", "April 2006",
"DESCRIPTION: make a separate RPC call for ever iteration",
"xrpc_client");

PROC doRPC(
        str module,
        str location,
        str method,
        bit updCall,
        lng arity,
        lng niters,
        BAT[void, BAT] ws,
        BAT[oid,  str] dsts,
        BAT[void, oid] fun_vid,
        BAT[void, oid] fun_iter,
        BAT[void, oid] fun_item,
        BAT[void, int] fun_kind,
        BAT[void, lng] int_values,
        BAT[void, dbl] dbl_values,
        BAT[void, dbl] dec_values,
        BAT[void, str] str_values) : BAT[void,bat]
{
    if (search(xrpc_mode,"iterative") >= 0) 
        doIterativeRPC(module, location, method, updCall, arity, niters,
                        ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
    else
        doLoopliftedRPC(module, location, method, updCall, arity, niters,
                        ws, dsts, fun_vid, fun_iter, fun_item, fun_kind, int_values, dbl_values, dec_values, str_values);
}


@h
#ifndef XRPC_CLIENT_H
#define XRPC_CLIENT_H

#define MAX_BUF_SIZE            (1024*1024)
#define NR_RETRIES              3

#endif /* XRPC_CLIENT_H */

@c
#include "pf_config.h"
#include <gdk.h>
#include "pathfinder.h"
#include "pf_support.h"
#include "shredder.h"
#include "serialize.h"
#include "xrpc_common.h"
#include "xrpc_client.h"

static buffer *
clean_up(stream *bs, lng **argcnt, lng iterc)
{
    lng i = 0;
    if(bs){
        buffer_destroy(stream_get_buffer(bs));
        stream_close(bs); stream_destroy(bs);
    }
    if(argcnt) {
        for(i = 0; i < iterc; i++) GDKfree(argcnt[i]);
        GDKfree(argcnt);
    }
    return NULL;
}

static void
handle_error_msg(char *errmsg)
{
    char *strptr, *strptr2;

    strptr = strstr(errmsg, "<env:Value");
    if(!strptr) {
        GDKerror(errmsg);
        return;
    }
    strptr = strchr(strptr, '>'); assert(strptr);
    strptr2 = strstr(++strptr, "</env:Value>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Value>.\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Code  : %s\n", strptr);
    strptr2[0] = '<';

    strptr = strstr(strptr2+12, "<env:Text");
    if(!strptr) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed: could not find \"<env:Text\".\n%s\n",
                 errmsg);
        return;
    }
    strptr = strchr(strptr, '>') + 1;
    strptr2 = strstr(strptr, "</env:Text>");
    if( (!strptr) || (!strptr2) ) {
        GDKerror("handle_error_msg: SOAP Fault message not "
                 "well-formed at \"<env:Text>\".\n%s\n", errmsg);
        return;
    }
    strptr2[0] = '\0';
    GDKerror("SOAP Fault Reason:\n%s\n", strptr);
}

/* Create a HTTP client socket.
 *
 * Returns: a socket number if succeeded, -1 otherwise.
 */
static int
setup_connection(str dst, int *port)
{
    struct in_addr      addr;
    struct sockaddr_in  sockaddr;
    struct hostent     *resolv = NULL;
    int i, ret, sock = -1, p = 0;
    str strptr = NULL;
   
    /* remove whitespace characters at the beginning and the end of the
     * string */
    while(dst[0] == ' '  || dst[0] == '\t' ||
          dst[0] == '\r' || dst[0] == '\n')
        dst++;
    i = strlen(dst) -1;
    while(dst[i] == ' '  || dst[i] == '\t' ||
          dst[i] == '\r' || dst[i] == '\n')
        i--;
    dst[i + 1] = '\0';

    strptr = strstr(dst, "://");
    if (strptr) strptr += 3; 
    else strptr = dst;

    /* 'dst' has the form 'URL[:port]' */
    if ((strptr = strchr(strptr, (int)':')) != NULL) {
        strptr[0] = '\0'; strptr++;
        p = strtol(strptr, (char **)NULL, 10);
        if (p <= 0) {
            GDKerror("setup_connection: invalid port number: %s\n", strptr);
            return -1;
        }
    } else { /* find the default port number from "monet_environment" */
        if( !(strptr = GDKgetenv("xrpc_port")) || !(*strptr) ){
            if( !(strptr = GDKgetenv("mapi_port")) ){
                GDKerror("setup_connection: could not find \"mapi_port\"\n");
                return -1;
            }
            p = atoi(strptr) + 1; 
        } else {
            p = atoi(strptr);
        }
    }

    if (isdigit((int)dst[0])) {
        if ((i = inet_addr(dst)) < 0) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return -1;
        }
        addr.s_addr = (unsigned) i;
    } else {
        if (!(resolv = gethostbyname(dst))) {
            GDKerror("setup_connection: invalid IP address \"%s\"\n", dst);
            return -1;
        }
        addr.s_addr = ((struct in_addr *)resolv->h_addr_list[0])->s_addr;
    }

    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port   = htons(p);
    sockaddr.sin_addr.s_addr = addr.s_addr;
    memset(&(sockaddr.sin_zero), '\0', 8);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        GDKerror("setup_connection: failed to create socket\n");
        return -1;
    }

    ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    for (i = NR_RETRIES; i > 0 && ret < 0; i--) {
        MT_sleep_ms(1);
        ret = connect(sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr));
    }

    if (ret < 0) {
        GDKerror("setup_connection: failed to setup connection with %s:%d\n", dst, p);
        close(sock);
        return -1;
    }

    *port = p;
    return sock;
}

/**
 * contID < 0 indicates ws[batID] is a simple BAT, i.e., a BAT without a
 * BAT tail.
 *
 * @return ws[batID] or ws[batID][contID] or NULL on error
 */
static BAT *
getBatFromContainer(BAT *ws, int batID, int contID)
{
    BAT *b = NULL, *batbat = NULL;
    BUN bun = BUN_NONE, bbun = BUN_NONE;
    oid CONTid = (oid)contID, BATid  = (oid)batID;
    BATiter wsi, batbati;

    assert(ws && batID >= 0);

    wsi = bat_iterator(ws);
    BUNfndOID(bun, wsi, (ptr)&BATid);
    if(bun == BUN_NONE) {
        GDKerror("getBatFromContainer: BAT ws[%d] not found\n",batID);
        return NULL;
    }
    if( !(batbat = BATdescriptor(*(bat*)Tloc(ws,bun))) ) {
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d]\n", batID);
        return NULL;
    }

    if(contID < 0) return batbat; /* this is a simple BAT, just return it */

    batbati = bat_iterator(batbat);
    BUNfndOID(bbun, batbati, (ptr)&CONTid);
    if(bbun == BUN_NONE) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: BAT ws[%d][%d] not found\n", batID, contID);
        return NULL;
    }
    if( !(b = BATdescriptor(*(bat*)Tloc(batbat,bbun))) ) {
        BBPunfix(BBPcacheid(batbat));
        GDKerror("getBatFromContainer: failed to fetch BAT ws[%d][%d]\n", batID, contID);
        return NULL;
    }

    BBPunfix(BBPcacheid(batbat));
    return b;
}

/**
 * Find the 'pre_kind' value of 'item_index'-th BUN of the PRE_KIND BAT
 * of the container 'contID' from the working set.
 *
 * @param ws The whole working set.
 * @param contID container ID.
 * @param item_index BUN index in the PRE_KIND BAT.
 * @return the 'pre_kind' value, or
 *         GDK_chr_min by error
 */
static chr
getELEMkind(BAT *ws, int contID, oid item_index)
{
    BATiter bi;
    BAT *b  = NULL;
    BUN bun = BUN_NONE;
    chr ret;

    if(!(b = getBatFromContainer(ws, PRE_KIND, contID)))
        return GDK_chr_min;

    if (!b->batCount){
        GDKerror("getELEMkind: %s BAT is empty.\n",
                b?BBP_logical(b->batCacheid):"NULL");
        return GDK_chr_min;
    }
    bi.b = b;
    BUNfndVOID(bun, bi, &item_index);
    if (bun == BUN_NONE){
        GDKerror("%s BAT does not contain value " OIDFMT
                 " in its head column.\n",
                 b?BBP_logical(b->batCacheid):"NULL", item_index);
        return GDK_chr_min;
    }

    ret = *(chr*)BUNtail(bi,bun);
    BBPunfix( BBPcacheid(b));
    return ret;
}

/**
 * try to receive the response message and shred it into shredBAT
 * Returns shredBAT, or
 *         NULL on error
 */
static BAT *
response2bat(
        bool timing,
        stream *in,
        char *host,
        int port,
        bool updCall)
{
    char respStatus[1024];
    int ret;
    buffer *resp;
    BAT *shredBAT;

    /* Create buffer for the RPC response message */
    resp = buffer_create(MAX_BUF_SIZE);
    if (!resp || resp->len == 0) {
        GDKerror("response2bat: failed to create buffer for XRPC response message\n");
        return NULL;
    }

    if( !(ret = stream_readline(in, respStatus, 1024)) ){
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        buffer_destroy(resp);
        return NULL;
    }

    /* We only speak HTTP/1.1 */
    if( ret < 13 || /* we should have at least "HTTP/1.1 nnn ", 13 chars */
        strstr(respStatus, "HTTP/1.1 ") != respStatus ||
        respStatus[12] != ' ' ||
        respStatus[ret -1] != '\r' ) { /* the '\n' is not returned by stream_readline() */
        GDKerror("response2bat: invalid response from %s:%d\n", host, port);
        do{ /* read and print everything we can receive */
            respStatus[ret -1] = '\0'; /* overwrite '\r' */
            GDKerror("%s\n", respStatus);
            ret = stream_readline(in, respStatus, 1024);
        } while (ret > 0);
        buffer_destroy(resp);
        return NULL;
    }
    respStatus[ret -1] = '\0';

    do{ /* read the HTTP header and throw it away */
        ret = stream_readline(in, resp->buf, 1024);
        if(ret == 1 && resp->buf[0] == '\r')
            ret = 0; /* end-of-HTTP-header found */
    } while (ret > 0);
    if (ret < 0) {
        GDKerror("response2bat: failed to receive response from %s:%d", host, port);
        buffer_destroy(resp);
        return NULL;
    }

    /* Now, we can check the response status */
    if(respStatus[9] != '2' || respStatus[10] != '0' || respStatus[11] != '0') {
        GDKerror("HTTP Error Code  : %s\n", respStatus+9);

        resp->pos = 0;
        do{ /* read the SOAP Fault message */
            ret = stream_read(in, (resp->buf + resp->pos), 1, (resp->len - resp->pos));
            if (ret > 0) resp->pos += ret;
        } while (ret > 0);
        if (ret < 0) {
            GDKerror("response2bat: failed to receive response from %s:%d", host, port);
            return NULL;
        }
        resp->buf[resp->pos] = 0;
        handle_error_msg(resp->buf);
        buffer_destroy(resp);
        return NULL;
    }

    /* Start timing Client DeSerialisation */
    lng time_xrpcClntDeSeria = GDKusec();
    if (!(shredBAT = BATnew(TYPE_str, TYPE_bat, 32))){
        GDKerror("response2bat: failed to malloc shredBAT\n");
        buffer_destroy(resp);
        return NULL;
    }

    if (!updCall) {
        if(shred(shredBAT, NULL, NULL, in, 0, NULL, NULL, NULL) ==GDK_FAIL) {
            GDKerror("response2bat: invalid XRPC response received\n");
            BBPreclaim(shredBAT);
            buffer_destroy(resp);
            return NULL;
        }
    }
    /* Stop timing Client DeSerialisation */
    time_xrpcClntDeSeria = GDKusec() - time_xrpcClntDeSeria;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Client_DeSerialisation (response2bat):   " LLFMT " microsec\n",
                time_xrpcClntDeSeria);
    }

    return shredBAT;
}

static buffer *
byvalue_request(
        bool timing,
        str genType,
        str qid,
        lng seqnr,
        lng timeout,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool updCall,
        lng arity,
        lng iterc,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    BATiter fun_itemi, fun_kindi;
    int ret = -1;
    buffer *b = NULL;
    stream *bs = NULL;
    /* Hold the temp BATs after the RPC response has been shredded: */
    oid *fvid_lst = NULL, *fiter_lst = NULL, *fitem_lst = NULL;
    int *fkind_lst = NULL;
    lng *intVals = NULL;
    dbl *dblVals = NULL;
    oid cnt = oid_nil;
    /* BATs hold item|kind of a node parameter */
    BAT *node_item = NULL, *node_kind = NULL;

    lng i, a, arg_offset = 0;
    lng my_argc = 0, my_iter = 0;
    lng **argcnt = NULL; /* #items each [iter][param] contains */

    /* BATs needed for serializing attributes */
    BAT *attr_qn = NULL, *attr_prop = NULL;
    BAT *qn_prefix = NULL, *qn_loc = NULL, *prop_val = NULL;
    BATiter strValsi;

    (void) dec_values;

    /* Start timing Client Serialisation */
    lng time_xrpcClntSeria = GDKusec();

    fvid_lst  = (oid*) Tloc(fun_vid, BUNfirst(fun_vid));
    fiter_lst = (oid*) Tloc(fun_iter, BUNfirst(fun_iter));
    fitem_lst = (oid*) Tloc(fun_item, BUNfirst(fun_item));
    fkind_lst = (int*) Tloc(fun_kind, BUNfirst(fun_kind));
    intVals   = (lng*) Tloc(int_values, BUNfirst(int_values));
    dblVals   = (dbl*) Tloc(dbl_values, BUNfirst(dbl_values));
    strValsi  = bat_iterator(str_values);
    
    /* Create buffer for the RPC request message */
    if((b = buffer_create(MAX_BUF_SIZE)) && b->len > 0) {
        if (!(bs = buffer_wastream(b, "xrpcrequest"))) {
            GDKerror("byvalue_request: failed to create buffer_wastream\n");
            buffer_destroy(b);
            return NULL;
        }
    } else {
        GDKerror("byvalue_request: failed to create outgoing buffer\n");
        return NULL;
    }

    if (!(argcnt = GDKmalloc(iterc * sizeof(lng*)))) {
        GDKerror("byvalue_request: failed to malloc argcnt\n");
        return clean_up(bs, argcnt, iterc);
    }
    for (i = 0; i < iterc; i++) {
        /* we allocate at least _one_ argcnt for each parameter, so that
         * we have a place to note that a function has zero parameter */
        if (!(argcnt[i] = GDKmalloc((arity>0?arity:1) * sizeof(lng)))) {
            GDKerror("byvalue_request: failed to malloc argcnt[" SZFMT "]\n", i);
            return clean_up(bs, argcnt, iterc);
        }
        argcnt[i][0] = 0;
        for (a = 1; a < arity; a++) {
            argcnt[i][a] = 0;
        }
    }

    /* Calculate the number of values contained by every parameter of
     * every iteration. */
    i = a = 0; /* i: iter counter; a: arg counter */
    for (cnt = 0; cnt < BATcount(fun_vid); cnt++){
        i = fiter_lst[cnt];
        a = fvid_lst[cnt];
        argcnt[i-1][a]++;
    }

    /* soap env header and xrpc request header */
    ret = stream_printf(bs, SOAP_ENVELOPE);
    if (ret < 0) {
        return clean_up(bs, argcnt, iterc);
    }

    if(qid && *qid) { /* an XRPC query that requires 2PC */
        char *ts = strrchr(qid, '|'); assert(ts);
        /* temporarily cut-off 'timestamp' by replacing '|' with '\0' */
        ts[0] = '\0'; ts++;

        ret = stream_printf(bs,
                "<xrpc:queryID xrpc:host=\"%s\" xrpc:querynr=\"%s\" xrpc:timeout=\""LLFMT"\">",
                qid, ts, timeout);
        assert(ret > 0);
        --ts; ts[0] = '|'; /* undo changes in qid */
    }

    for (my_iter = 0; my_iter < iterc; my_iter++) {
        if (arity == 0) {
            assert(stream_write(bs, "<xrpc:call/>", 1, 12) == 12);
            continue;
        }

        assert(stream_write(bs, "<xrpc:call>", 1, 11) == 11); /* start an iteration */
        for (my_argc = 0; my_argc < arity; my_argc++) {
            if (argcnt[my_iter][my_argc] == 0) {
                assert(stream_write(bs, "<xrpc:sequence/>", 1, 16) == 16);
                continue;
            }
            arg_offset = 0;
            /* add the 'argcnt' of all arg-s before 'me': */
            for (a = 0; a < my_argc; a++) {
                for (i = 0; i < iterc; i++)
                    arg_offset += argcnt[i][a];
            }
            /* add the 'argcnt' of iter-s before 'me': */
            for (i = 0; i < my_iter; i++) {
                arg_offset += argcnt[i][my_argc];
            }
            /* now 'arg_offset' contains the start position of the
             * values of my_iter and my_argc in the fun_* BATs */

            assert(stream_write(bs, "<xrpc:sequence>", 1, 15) == 15); /* start a parameter */
            int k;
            chr elem_kind = 0;
            oid item = 0;
            int cmbn_cont_kind = 0, cur_kind = 0, contID = 0;
            for (k= 0; k < argcnt[my_iter][my_argc]; k++) {

                a = arg_offset + k; /* index into fun_item|fun_kind */
                item = fitem_lst[a];
                cmbn_cont_kind = fkind_lst[a];
                cur_kind = XTRACT_KIND(cmbn_cont_kind);
                contID = XTRACT_CONT(cmbn_cont_kind);

                switch (cur_kind) {
                    case BOOL:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:boolean\">%s</xrpc:atomic-value>",
                                intVals[item] == TRUE ? "true" : "false");
                        assert(ret > 0);
                        break;
                    case INT:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:integer\">%lld</xrpc:atomic-value>",
                                intVals[item]);
                        assert(ret > 0);
                        break;
                    case DEC:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:decimal\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        assert(ret > 0);
                        break;
                    case DBL:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:double\">%f</xrpc:atomic-value>",
                                dblVals[item]);
                        assert(ret > 0);
                        break;
                    case STR:
                    case U_A:
                        ret = stream_printf(bs,
                                "<xrpc:atomic-value xsi:type=\"xs:string\">%s</xrpc:atomic-value>",
                                (char*)BUNtail(strValsi, item));
                        assert(ret > 0);
                        break;
                    case ATTR:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);

                        attr_qn   = getBatFromContainer(ws, ATTR_QN, contID);
                        attr_prop = getBatFromContainer(ws, ATTR_PROP, contID);
                        prop_val  = getBatFromContainer(ws, PROP_VAL, contID);
                        qn_prefix = getBatFromContainer(ws, QN_PREFIX, contID);
                        qn_loc    = getBatFromContainer(ws, QN_LOC, contID);
                        if( (!attr_qn) || (!attr_prop) || (!prop_val) ||
                            (!qn_prefix) || (!qn_loc) ){
                            return clean_up(bs, argcnt, iterc);
                        }

                        BATiter attr_qni = bat_iterator(attr_qn);
                        BATiter qn_prefixi = bat_iterator(qn_prefix);
                        BATiter qn_loci = bat_iterator(qn_loc);
                        BATiter attr_propi = bat_iterator(attr_prop);
                        BATiter prop_vali = bat_iterator(prop_val);
                        
                        i = *(oid*)BUNtail(fun_itemi, a);
                        a = *(oid*)BUNtail(attr_qni, i);
                        char *prefix = (char*)BUNtail(qn_prefixi, a);
                        char *loc    = (char*)BUNtail(qn_loci,    a);
                        a = *(oid*)BUNtail(attr_propi, i);
                        char *attr_val = (char*)BUNtail(prop_vali, a);

                        assert(stream_write(bs, "<xrpc:attribute ", 1, 16) == 16);
                        if (prefix && *prefix){
                            ret = stream_printf(bs, "%s:", prefix);
                            assert(ret > 0);
                        }
                        ret = stream_printf(bs, "%s=\"%s\"/>", loc, attr_val);
                        assert(ret > 0);
                        break;
                    }
                    case ELEM:
                    {
                        contID = XTRACT_CONT(cmbn_cont_kind);
                        elem_kind = getELEMkind(ws, contID, item);
                        if (elem_kind == GDK_chr_min) {
                            return clean_up(bs, argcnt, iterc);
                        }
                        switch(elem_kind) {
                            case 0: assert(stream_write(bs, "<xrpc:element>", 1, 14) == 14);
                                    break;
                            case 1: assert(stream_write(bs, "<xrpc:text>", 1, 11) == 11);
                                    break;
                            case 2: assert(stream_write(bs, "<xrpc:comment>", 1, 14) == 14);
                                    break;
                            case 3: assert(stream_write(bs, "<xrpc:processing-instruction>", 1, 29) == 29);
                                    break;
                            case 4: assert(stream_write(bs, "<xrpc:document>", 1, 15) == 15);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */   break;
                            default:
                                GDKerror("byvalue_request: call%d/sequence%d/item%d has "
                                        "invalid type %d\n", my_iter, my_argc, i);
                                return clean_up(bs, argcnt, iterc);
                        }
                        /* print body of the node */
                        node_item = BUNins( BATnew(TYPE_void, TYPE_oid, 1),
                                            BUNhead(fun_itemi, a),
                                            BUNtail(fun_itemi, a), FALSE );
                        node_kind = BUNins( BATnew(TYPE_void, TYPE_int, 1),
                                            BUNhead(fun_kindi, a),
                                            BUNtail(fun_kindi, a), FALSE );
                        xquery_print_result_driver(bs,
                                "xml-noheader-noroot", NULL, NULL, NULL, NULL,
                                ws, 1,
                                node_item, node_item, node_item, node_kind,
                                int_values, dbl_values, str_values);

                        if(BBPreclaim(node_item) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        if(BBPreclaim(node_kind) == -1){
                            GDKerror("byvalue_request: failed to destroy BAT \"node_item\", "
                                    "because it is in use by other process!");
                            GDKerror("THIS SHOULD NEVER HAPPEN!!!");
                            return clean_up(bs, argcnt, iterc);
                        }

                        switch(elem_kind) {
                            case 0: assert(stream_write(bs, "</xrpc:element>", 1, 15) == 15);
                                    break;
                            case 1: assert(stream_write(bs, "</xrpc:text>", 1, 12) == 12);
                                    break;
                            case 2: assert(stream_write(bs, "</xrpc:comment>", 1, 15) == 15);
                                    break;
                            case 3: assert(stream_write(bs, "</xrpc:processing-instruction>", 1, 30) == 30);
                                    break;
                            case 4: assert(stream_write(bs, "</xrpc:document>", 1, 16) == 16);
                                    break;
                            case 5: /* COLLECTION: nothing to be done, here */    break;
                            default:
                                GDKerror("byvalue_request: should have never reached here!");
                                return clean_up(bs, argcnt, iterc);
                        }
                    }   break;
                    default:
                        GDKerror("byvalue_request: call%d/sequence%d/item%d has invalid type %d\n",
                                my_iter, my_argc, i);
                        return clean_up(bs, argcnt, iterc);
                }
            }
            assert(stream_write(bs, "</xrpc:sequence>", 1, 16) == 16);
        }
        assert(stream_write(bs, "</xrpc:call>", 1, 12) == 12);
    }
    assert(stream_write(bs, "</xrpc:request></env:Body></env:Envelope>\n", 1, 42) == 42);
    /* Stop timing Client Serialisation */
    time_xrpcClntSeria = GDKusec() - time_xrpcClntSeria;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Client_Serialisation (create_req_msg):   " LLFMT " microsec\n",
                time_xrpcClntSeria);
    }

    return stream_get_buffer(bs);
}

int
CMDhttp_post(
        BAT **res,
        str genType,
        str qid,
        lng *seqnr,
        lng *timeout,
        str dst,
        str rpc_module,
        str rpc_uri,
        str rpc_method,
        bool *updCall,
        lng *arity,
        lng *itercnt,
        BAT *ws,
        BAT *fun_vid,
        BAT *fun_iter,
        BAT *fun_item,
        BAT *fun_kind,
        BAT *int_values,
        BAT *dbl_values,
        BAT *dec_values,
        BAT *str_values)
{
    int sock = -1, port = -1;
    stream *in = NULL, *out = NULL;
    buffer *req = NULL;
    size_t bytes_sent = 0;
    BAT *shredBAT = NULL;
    bool timing = (genType && strstr(genType, "timing")) ? TRUE : FALSE;

    ERRORcheck((*itercnt) < 0, "CMDhttp_post: itercnt must not be negative (<0).\n");
    ERRORcheck((*arity) < 0, "CMDhttp_post: arity must not be negative (<0).\n");
    ERRORcheck(!BAThdense(ws), "CMDhttp_post: head of 'ws' must be dense.\n");
    ERRORcheck(!BAThdense(fun_vid), "CMDhttp_post: head of 'fun_vid' must be dense.\n");
    ERRORcheck(!BAThdense(fun_iter), "CMDhttp_post: head of 'fun_iter' must be dense.\n");
    ERRORcheck(!BAThdense(fun_item), "CMDhttp_post: head of 'fun_item' must be dense.\n");
    ERRORcheck(!BAThdense(fun_kind), "CMDhttp_post: head of 'fun_kind' must be dense.\n");
    ERRORcheck(!BAThdense(int_values), "CMDhttp_post: head of 'int_values' must be dense.\n");
    ERRORcheck(!BAThdense(dbl_values), "CMDhttp_post: head of 'dbl_values' must be dense.\n");
    ERRORcheck(!BAThdense(dec_values), "CMDhttp_post: head of 'dec_values' must be dense.\n");
    ERRORcheck(!BAThdense(str_values), "CMDhttp_post: head of 'str_values' must be dense.\n");

    if ((sock = setup_connection(dst, &port)) < 0)
        return GDK_FAIL;
    if (!(out = socket_wastream(sock, "http_send"))) {
        GDKerror("do_simple_query: failed to create socket_wastream for sending XRPC request\n");
        close(sock);
        return GDK_FAIL;
    }

    if(!(req = byvalue_request(timing, genType, qid, *seqnr, *timeout, rpc_module, rpc_uri, rpc_method,
                    *updCall, *arity, *itercnt, ws, fun_vid, fun_iter,
                    fun_item, fun_kind, int_values, dbl_values,
                    dec_values, str_values))){
        stream_close(out); stream_destroy(out);
        return GDK_FAIL;
    }
    req->buf[req->pos] = '\0';

    /* Start timing Network Send Client2Server */
    lng time_xrpcClnt2Serv = GDKusec();
    bytes_sent = stream_printf(out,
            "POST %s HTTP/1.1\r\n"
            "Host: %s:%d\r\n"
            "Accept: text/html, text/xml, application/soap+xml\r\n"
            "Accept-Language: en-uk en-us\r\n"
            "Content-Type: text/html; charset=\"utf-8\"\r\n"
            "Content-Length: " SZFMT "\r\n\r\n"
            "%s",
            XRPC_REQ_CALLBACK, dst, port, req->pos, req->buf);
    if (bytes_sent < req->pos) {
        GDKerror("do_simple_query: failed to send XRPC request.");
        stream_close(out); stream_destroy(out);
        buffer_destroy(req);
        close(sock);
        return GDK_FAIL;
    }
    /* Stop timing Network Send Client2Server */
    time_xrpcClnt2Serv= GDKusec() - time_xrpcClnt2Serv;
    if (timing) {
        stream_printf(GDKout,
                "XRPC_Network_Client_2_Server:  " LLFMT " microsec\n"
                "XRPC_Data_Sent:                " SZFMT " bytes\n\n",
                time_xrpcClnt2Serv,
                bytes_sent);
    }

    if( !(in = socket_rastream(sock, "http_receive")) ){
        GDKerror("do_simple_query: failed to create socket_rastream\n");
        return GDK_FAIL;
    }
    shredBAT = response2bat(timing, in, dst, port, *updCall);

    stream_close(out); stream_destroy(out);
    stream_close(in); stream_destroy(in);
    buffer_destroy(req);

    if(!shredBAT) return GDK_FAIL;
    *res = shredBAT;
    return GDK_SUCCEED;
}
/* vim:set shiftwidth=4 expandtab: */
