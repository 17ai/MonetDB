# pathfinder.mx
#
# Monet runtime support for the Pathfinder XQuery compiler
#
# Copyright Notice:
# -----------------
# 
# The contents of this file are subject to the MonetDB Public
# License Version 1.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the ``Pathfinder'' system. The Initial
# Developer of the Original Code is the Database & Information
# Systems Group at the University of Konstanz, Germany. Portions
# created by U Konstanz are Copyright (C) 2000-2004 University
# of Konstanz. All Rights Reserved.
#
# Contributors:
#         Torsten Grust <torsten.grust@uni-konstanz.de>
#         Maurice van Keulen <M.van.Keulen@bigfoot.com>
#         Jens Teubner <jens.teubner@uni-konstanz.de>
#
# $Id$
#

@f pathfinder
@a Torsten Teggy Grust
@a Maurice van Keulen
@a Henning Rode
@a Jan Flokstra
@t Runtime Support for the Pathfinder XQuery Compiler

@m
.MODULE pathfinder;

.COMMAND xquery_document(
		str,		# mode, "xml" or "sax"
		BAT[oid,any],	# the document oid's
		BAT[void,int],
		BAT[void,chr],
		BAT[void,oid],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,oid],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str]
	) : void = xquery_document_main;
 "C interface to Xquery document printing routine"

.COMMAND xquery_result(
		str,		# mode, "xml" or "sax"
		BAT[void,oid],	# item
		BAT[void,chr],	# kind
		BAT[void,int],	# The int  value BAT
		BAT[void,dbl],	# The dbl  value BAT
		BAT[void,dbl],	# The dec  value BAT
		BAT[void,str],	# The str  value BAT
		BAT[void,int],
		BAT[void,chr],
		BAT[void,oid],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str],
		BAT[void,oid],
		BAT[void,str],
		BAT[void,str],
		BAT[void,str]
	) : void = xquery_result_main;
 "C interface to Xquery result sequence printing routine"

@:prec_foll(following)@
@:prec_foll(preceding)@

@= prec_foll
.COMMAND @1_void (BAT[void,int] pre_size,
               BAT[oid,any] ctx,
               BAT[void,oid] doc_pre,
	       int height,
               int upperbound) : BAT[oid,void] = PF@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  doc_pre: table of document fragments (doc id, preorder start value)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @1 axis from the given context."
@m
@:scj_cmd(descorself,descendant-or-self)@
@:scj_cmd(desc,descendant)@
@:scj_cmd(ancorself,ancestor-or-self)@
@:scj_cmd(anc,ancestor)@

@= scj_cmd
.COMMAND scj_@1(BAT[void,int] pre_size,
                BAT[oid,any] ctx,
                int height,
                int upperbound): BAT[oid,void] = PFscj_@1_void;
"PARAMETERS
  pre_size: the complete size BAT (preorder rank, size)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
@:lev_cmd(child,child)@
@:lev_cmd(parent,parent)@
@:lev_cmd(fs,following-sibling)@
@:lev_cmd(ps,preceding-sibling)@

@= lev_cmd
.COMMAND lev_@1(BAT[void,chr] pre_level,
                BAT[oid,any] ctx,
		int height,
                int upperbound) : BAT[oid,void] = PFlev_@1;
"PARAMETERS
  pre_level: the complete level BAT (preorder rank, level)
  ctx: context node sequence (preorder rank, *)
  height: document height
  upperbound: upperbound for size of result context node sequence
DESCRIPTION
axis step evaluation on the @2 axis from the given context."
@m
.END pathfinder;

@mil
#############################################
# Document management functions
#
# - import_doc
# - delete_doc
# - compress_properties
# - doc_to_working_set
#
# Each imported XML-document is stored as a collection of persistent BATs 
# whose name starts with the name of the BAT and ends with the document ID. 
# The execution of an XQuery is not performed on the persistent BATs, but on 
# the transient 'working set', a global document collection represented
# by the T*-BATs.
#
# Each collection contains the following BATs:
# - pre_size    : BAT[oid,int]  pre-value of node / and its descendant size,
# - pre_level   : BAT[oid,chr]  pre-value of node / and its level,
# - pre_prop    : BAT[oid,oid]  pre-value of node / and property ID,
# - pre_kind    : BAT[oid,chr]  pre-value of node / and property ID,
#
# - prop_ns      : BAT[oid,str]  property ID / and name space,
# - prop_loc     : BAT[oid,str]  property ID / and local name,
# - prop_text    : BAT[oid,str]  property ID / and text,
# - prop_com     : BAT[oid,str]  property ID / and comment,
# - prop_ins     : BAT[oid,str]  property ID / and processing instruction,
# - prop_tgt     : BAT[oid,str]  property ID / and processing instruction target,
#
# - attr_ns   : BAT[oid,str]  attribute ID / and name space of attribute names
# - attr_loc  : BAT[oid,str]  attribute ID / and local name of attribute names
# - attr_val  : BAT[oid,str]  attribute ID / value of attribute nodes
# - attr_own  : BAT[oid,oid]  attribute ID / pre-value of owner
#
# Global information on persistent stored documents:
# - doc_name    : BAT[oid,str]  document ID / document name
# - doc_height  : BAT[oid,int]  document ID / height of document
# 
# Information on documents/fragments in the working set:
# - Tdoc_pre : BAT[oid,oid] document ID / pre-value of document node in working set
# - Tdoc_name : BAT[oid,str] document ID / name of document (only if name exists)
# - Theight : int height of the working set

# DEFINITION of constants concerning the data model
const DOC_BASE := 0@0;
const PRE_BASE := 0@0;
const ATTR_BASE := 1073741824@0; #2 * 2^29
const ELEMENT := chr(0);
const TEXT := chr(1);
const COMMENT := chr(2);
const PI := chr(3);
const DOCUMENT := chr(4);

# INITIALIZATION of working set (T*-BATs)
var Tpre_size;
var Tpre_level;
var Tpre_prop;
var Tpre_kind;
var Tprop_ns;
var Tprop_loc;
var Tprop_text;
var Tprop_com;
var Tprop_ins;
var Tprop_tgt;
var Tattr_ns;
var Tattr_loc;
var Tattr_val;
var Tattr_own;
var Tdoc_pre;
var Tdoc_name;
var Theight;
clear_working_set();

# called by compress_properties
PROC compress_val(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                  str batname) : void :=
{
    prop_val := bat(batname);
    
    var cprval_newprop := prop_val.reverse.kunique.mark(PRE_BASE);
    var prop_newprop := prop_val.join(cprval_newprop);
    pre_newprop.insert(pre_prop.join(prop_newprop));

    # replace persistent prop_val by the new compressed BAT
    prop_val := nil;
    bat(batname).persists(false).rename(batname + "_");
    cprval_newprop.reverse.persists(true).bbpname(batname);
}

# called by compress_properties
PROC compress_val(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                  str batname1, str batname2) : void :=
{
    prop_val1 := bat(batname1);
    prop_val2 := bat(batname2);
    
    # ":" is added to distinguish between "foo:bar" and "fo:obar"
    var prop_val12 := prop_val1.[+](":").[+](prop_val2);
    var cprval12_prop := prop_val12.reverse.kunique;
    var cprval12_newprop := cprval12_prop.mark(PRE_BASE);
    
    var prop_newprop := prop_val12.join(cprval12_newprop);
    pre_newprop.insert(pre_prop.join(prop_newprop));
    
    var cprval1_prop := prop_val1.semijoin(cprval12_prop.reverse).reverse;
    var cprval2_prop := prop_val2.semijoin(cprval12_prop.reverse).reverse;
    
    var cprval1_newprop := cprval1_prop.join(prop_newprop);
    var cprval2_newprop := cprval2_prop.join(prop_newprop);
    
    # replace persistent prop_val1/2 by the new compressed BATs
    prop_val1 := nil;
    bat(batname1).persists(false).rename(batname1 + "_");
    cprval1_newprop.reverse.persists(true).bbpname(batname1);
    prop_val2 := nil;
    bat(batname2).persists(false).rename(batname2 + "_");
    cprval2_newprop.reverse.persists(true).bbpname(batname2);
}

PROC compress_properties(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := str(int(doc_name.reverse.find(name)));
    
    var batname := "pre_prop" + docid;
    var pre_prop := bat(batname);
    var pre_kind := bat("pre_kind" + docid);
    var pre_newprop := new(oid,oid);
   
    # eliminate property duplicates in each BAT prop_*
    # (in case of tag-names and PIs every unique combination of
    #  ns:loc, (resp. tgt:ins) gets a property ID)
    pre_newprop.insert(pre_prop.semijoin(pre_kind.select(DOCUMENT)));
    var tmp := pre_prop.semijoin(pre_kind.select(ELEMENT));
    compress_val(tmp, pre_newprop, ("prop_loc" + docid), ("prop_ns" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(TEXT));
    compress_val(tmp, pre_newprop, ("prop_text" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(COMMENT));
    compress_val(tmp, pre_newprop, ("prop_com" + docid));
    tmp := pre_prop.semijoin(pre_kind.select(PI));
    compress_val(tmp, pre_newprop, ("prop_ins" + docid), ("prop_tgt" + docid));
    
    # replace persistent pre_prop by the new BAT with compressed property IDs
    pre_newprop := pre_newprop.sort.reverse.mark(PRE_BASE).reverse;
    pre_prop := nil;
    bat(batname).persists(false).rename(batname + "_");
    pre_newprop.persists(true).bbpname(batname);
    
    commit;
}
ADDHELP("compress_properties", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
compression of property duplicates\n\
(this function should be called if the loader was used without property compression)",
"pathfinder");

# called by "doc_to_working_set" when importing properties
PROC add_properties(BAT[oid,oid] pre_prop, BAT[oid,oid] pre_newprop,
                    BAT[void,str] Tprop_val, str batname) : oid :=
{
    # get the actual property ID offset
    var new_prop_base := oid(int(Tprop_val.seqbase) + Tprop_val.count);

    # get the <prop/val> BAT of the new document
    var prop_val := bat(batname);

    # import all new property values and replace the corresponding
    # property IDs 
    var prop_newprop := prop_val.mirror.mark(new_prop_base);
    pre_newprop.insert(pre_prop.join(prop_newprop));
    Tprop_val.insert(prop_val.reverse.mark(new_prop_base).reverse);

    return new_prop_base;
}

PROC doc_to_working_set(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := doc_name.reverse.find(name);

    var new_pre_base := oid(int(PRE_BASE) + Tpre_size.count);
    
    # create document entry for Tdoc_pre, Tdoc_name and update max-height;
    Tdoc_pre.insert(nil, new_pre_base);
    Tdoc_name.insert(nil, name);
    Theight := max(Theight, doc_height.find(docid));

    docid := str(int(docid));

    # append the size and level table to the respective T-BATs
    Tpre_size.insert(bat("pre_size" + docid).reverse.mark(new_pre_base).reverse);
    Tpre_level.insert(bat("pre_level" + docid).reverse.mark(new_pre_base).reverse);
    Tpre_kind.insert(bat("pre_kind" + docid).reverse.mark(new_pre_base).reverse);

    # append the property BATs
    var pre_prop := bat("pre_prop" + docid).reverse.mark(new_pre_base).reverse;
    var pre_newprop := new(oid,oid);
    
    pre_newprop.insert(pre_prop.semijoin(Tpre_kind.select(DOCUMENT)));
    var tmp := pre_prop.semijoin(Tpre_kind.select(ELEMENT));
    tmp_seqbase := add_properties(tmp, pre_newprop, Tprop_loc, "prop_loc" + docid);
    Tprop_ns.insert(bat("prop_ns" + docid).reverse.mark(tmp_seqbase).reverse);
    tmp := pre_prop.semijoin(Tpre_kind.select(TEXT));
    add_properties(tmp, pre_newprop, Tprop_text, "prop_text" + docid);
    tmp := pre_prop.semijoin(Tpre_kind.select(COMMENT));
    add_properties(tmp, pre_newprop, Tprop_com, "prop_com" + docid);
    tmp := pre_prop.semijoin(Tpre_kind.select(PI));
    tmp_seqbase := add_properties(tmp, pre_newprop, Tprop_ins, "prop_ins" + docid);
    Tprop_tgt.insert(bat("prop_tgt" + docid).reverse.mark(tmp_seqbase).reverse);
    
    pre_newprop := pre_newprop.sort.reverse.mark(new_pre_base).reverse;
    Tpre_prop.insert(pre_newprop);

    # append the attribute tables to the respective T-BATs
    var new_attr_base := oid(int(ATTR_BASE) + Tattr_own.count);

    Tattr_ns.insert(bat("attr_ns" + docid).reverse.mark(new_attr_base).reverse);
    Tattr_loc.insert(bat("attr_loc" + docid).reverse.mark(new_attr_base).reverse);
    Tattr_val.insert(bat("attr_val" + docid).reverse.mark(new_attr_base).reverse);

    # the debugmask instructions helps to pass the sorted property,
    # which would be lost otherwise after the [+](int) instruction
    tmp := bat("attr_own" + docid).reverse.mark(new_attr_base).reverse;
    tmp := tmp.[int];
    var orgDebugMask := debugmask();
    var newDebugMask := or(or(2,8),orgDebugMask);
    debugmask(newDebugMask);
    tmp := tmp.[+](int(new_pre_base) - int(PRE_BASE));
    debugmask(orgDebugMask);
    tmp := tmp.[oid];
    Tattr_own.insert(tmp);
}
ADDHELP("doc_to_working_set", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
Load persistent document into working set (T-BATs).",
"pathfinder");

PROC clear_working_set() : void :=
{
    Tpre_size := new(void,int).seqbase(PRE_BASE);
    Tpre_level := new(void,chr).seqbase(PRE_BASE);
    Tpre_prop := new(void,oid).seqbase(PRE_BASE);
    Tpre_kind := new(void,chr).seqbase(PRE_BASE);
    Tprop_ns := new(void,str).seqbase(PRE_BASE);
    Tprop_loc := new(void,str).seqbase(PRE_BASE);
    Tprop_text := new(void,str).seqbase(PRE_BASE);
    Tprop_com := new(void,str).seqbase(PRE_BASE);
    Tprop_ins := new(void,str).seqbase(PRE_BASE);
    Tprop_tgt := new(void,str).seqbase(PRE_BASE);
    Tattr_ns := new(void,str).seqbase(ATTR_BASE);
    Tattr_loc := new(void,str).seqbase(ATTR_BASE);
    Tattr_val := new(void,str).seqbase(ATTR_BASE);
    Tattr_own := new(void,oid).seqbase(ATTR_BASE);
    Tdoc_pre := new(void,oid).seqbase(DOC_BASE);
    Tdoc_name := new(void,str).seqbase(DOC_BASE);
    Theight := 0;
}
ADDHELP("clear_working_set", "rode", "Dec 2003",
"DESCRIPITON:\n\
Empty the working set (T-BATs).",
"pathfinder");

PROC delete_doc(str name) : void :=
{
    if (not(doc_name.reverse.exist(name)))
	ERROR("Document %s does not exist\n",name);
    var docid := doc_name.reverse.find(name);
    
    doc_name.delete(docid);
    doc_height.delete(docid);
    
    docid := str(int(docid));
    bat("pre_size" + docid).persists(false);
    bat("pre_level" + docid).persists(false);
    bat("pre_prop" + docid).persists(false);
    bat("pre_kind" + docid).persists(false);
    bat("prop_ns" + docid).persists(false);
    bat("prop_loc" + docid).persists(false);
    bat("prop_text" + docid).persists(false);
    bat("prop_com" + docid).persists(false);
    bat("prop_tgt" + docid).persists(false);
    bat("prop_ins" + docid).persists(false);
    bat("attr_ns" + docid).persists(false);
    bat("attr_loc" + docid).persists(false);
    bat("attr_val" + docid).persists(false);
    bat("attr_own" + docid).persists(false);
    
    commit;
}
ADDHELP("delete_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
delete the persistent BATS that store the document.",
"pathfinder");

PROC import_doc(str flnm, str name) : void :=
{
    # create doc_name table in case it does not exist
    if (not(view_bbp_name.reverse.exist("doc_name")))
    {    
        new(oid,str).persists(true).bbpname("doc_name");
        new(oid,int).persists(true).bbpname("doc_height");
    }
    var docid;
    if (doc_name.count = 0) docid := DOC_BASE;
    else docid := oid(int(doc_name.reverse.max) + 1);
    
    if (doc_name.reverse.exist(name))
	ERROR("Document %s already exists\n",name);

    module("ascii_io");

    printf(">>> Importing '%s' with name '%s'\n",flnm,name);

    # column/line separators (4 columns)
    var seps4 := new (void, str);
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, ",");
    seps4.insert (nil, "\n");

    # column/line separators (2 columns)
    var seps2 := new (void, str);
    seps2.insert (nil, ",");
    seps2.insert (nil, "\n");

    # column/line separators (1 column)
    var seps1 := new (void, str);
    seps1.insert (nil, "\n");

    # table pre|size|level|prop|kind 
    var pre := new (void, str);
    pre.insert (nil, "size");
    pre.insert (nil, "level");
    pre.insert (nil, "prop");
    pre.insert (nil, "kind");

    # column types
    var pre_ty := new (void, str);
    pre_ty.insert (nil, "int");
    pre_ty.insert (nil, "sht");
    pre_ty.insert (nil, "oid");
    pre_ty.insert (nil, "sht");

    # table prop|ns|loc
    var tag := new (void, str);
    tag.insert (nil, "ns");
    tag.insert (nil, "loc");

    # column types
    var tag_ty := new (void, str);
    tag_ty.insert (nil, "str");
    tag_ty.insert (nil, "str");

    # table prop|text
    var text := new (void, str);
    text.insert (nil, "text");

    # column types
    var text_ty := new (void, str);
    text_ty.insert (nil, "str");

    # table prop|com
    var com := new (void, str);
    com.insert (nil, "com");

    # column types
    var com_ty := new (void, str);
    com_ty.insert (nil, "str");

    # table prop|tgt|ins
    var pi := new (void, str);
    pi.insert (nil, "tgt");
    pi.insert (nil, "ins");

    # column types
    var pi_ty := new (void, str);
    pi_ty.insert (nil, "str");
    pi_ty.insert (nil, "str");

    # table att|own|ns|loc|val
    var att := new (void, str);
    att.insert (nil, "own");
    att.insert (nil, "ns");
    att.insert (nil, "loc");
    att.insert (nil, "val");

    # column types
    var att_ty := new (void, str);
    att_ty.insert (nil, "oid");
    att_ty.insert (nil, "str");
    att_ty.insert (nil, "str");
    att_ty.insert (nil, "str");

    # load table pre|size|level|prop|kind 
    tmp := load(pre, seps4, pre_ty, flnm + ".pre", -1);
    
    doc_name.insert(docid, name);
    doc_height.insert(docid, tmp.find("level").max + 1);
    docid := str(int(docid));

    tmp.find("size").persists(true).bbpname("pre_size" + docid);
    tmp.find("level").[chr].copy.persists(true).bbpname("pre_level" + docid);
    tmp.find("prop").persists(true).bbpname("pre_prop" + docid);
    tmp.find("kind").[chr].copy.persists(true).bbpname("pre_kind" + docid);

    # load table prop|ns|loc
    tmp := load(tag, seps2, tag_ty, flnm + ".tag", -1);
    tmp.find("ns").persists(true).bbpname("prop_ns" + docid);
    tmp.find("loc").persists(true).bbpname("prop_loc" + docid);

    # load table prop|text
    tmp := load(text, seps1, text_ty, flnm + ".text", -1);
    tmp.find("text").persists(true).bbpname("prop_text" + docid);

    # load table prop|com
    tmp := load(com, seps1, com_ty, flnm + ".com", -1);
    tmp.find("com").persists(true).bbpname("prop_com" + docid);

    # load table prop|tgt|ins
    tmp := load(pi, seps2, pi_ty, flnm + ".pi", -1);
    tmp.find("tgt").persists(true).bbpname("prop_tgt" + docid);
    tmp.find("ins").persists(true).bbpname("prop_ins" + docid);

    # load table att|own|ns|loc|val
    tmp := load(att, seps4, att_ty, flnm + ".@", -1);
    tmp.find("ns").persists(true).bbpname("attr_ns" + docid);
    tmp.find("loc").persists(true).bbpname("attr_loc" + docid);
    tmp.find("val").persists(true).bbpname("attr_val" + docid);
    tmp.find("own").persists(true).bbpname("attr_own" + docid);

    # save all persistent BATs
    commit;
}
ADDHELP("import_doc", "rode", "Nov 2003",
"PARAMETERS:\n\
str file name (\"/anypath/foo.xml\" if loader output is located in \"/anypath/foo.xml.*\")\n\
str document name in database\n\
DESCRIPITON:\n\
Import files generated by the loader as persistent document.",
"pathfinder");

#############################################
# XML print functions / XML Serialization
#
# - xml_print()
# - xml_print(str docname)
# - xml_print(BAT[oid,any] context set)
#
# The xml_print function serializes the information stored in the
# collection of BATs. Thus, it restores fragments of the textual
# representation of the XML-document.
# xml_print() can be either called without argument, which causes
# printing of the whole working set, or related to a specific document
# or context set. In the latter case, for each node within the context
# set, the node itself and its descendant fragment is printed (even if
# this means to repeatedly print the same information, when context 
# nodes relate to each other on the descendant axis).
#

PROC xquery_document(str mode) : void :=
{
	xquery_document(
		mode,
		Tdoc_pre.reverse,
		Tpre_size,
		Tpre_kind,
		Tpre_prop,
		Tprop_ns,
		Tprop_loc,
		Tprop_text,
		Tprop_com,
		Tprop_tgt,
		Tprop_ins,
		Tattr_own,
		Tattr_ns,
		Tattr_loc,
		Tattr_val
	);
}
ADDHELP("xquery_document", "flokstra", "Jul 2004",
"PARAMETERS:\n\
mode parameter, either \"xml\" or \"sax\" \n\
DESCRIPTION:\n\
Print Xquery document. The mode determines the output type. In \"xml\"\n\
mode a plain xml document will be printed. In \"sax\" mode the output will\n\
be a SAXstream to be interpreted by the Sax-O-Phone package.",
"pathfinder");

PROC xquery_result(str mode, BAT[void,oid] item, BAT[void,chr] kind, BAT[void,int] intVAL, BAT[void,dbl] dblVAL, BAT[void,dbl] decVAL, BAT[void,str] strVAL) : void :=
{
	xquery_result(
		mode,
		item,
		kind,
		intVAL,
		dblVAL,
		decVAL,
		strVAL,
		Tpre_size,
		Tpre_kind,
		Tpre_prop,
		Tprop_ns,
		Tprop_loc,
		Tprop_text,
		Tprop_com,
		Tprop_tgt,
		Tprop_ins,
		Tattr_own,
		Tattr_ns,
		Tattr_loc,
		Tattr_val
	);
}
ADDHELP("xquery_result", "flokstra", "Jul 2004",
"PARAMETERS:\n\
mode  : either \"xml\" or \"sax\" \n\
item  : the item BAT of the pathFinder result\n\
kind  : the kind BAT of the pathFinder result\n\
intVal: the BAT containing the values of this type\n\
dblVal: the BAT containing the values of this type\n\
decVal: the BAT containing the values of this type\n\
strVal: the BAT containing the values of this type\n\
DESCRIPTION:\n\
Print Xquery result sequence. The mode determines the output type. In \"xml\"\n\
mode a plain xml document will be printed. In \"sax\" mode the output will\n\
be a SAXstream to be interpreted by the Sax-O-Phone package.\n\
The other parameters are the BATs containing the data set.",
"pathfinder");


PROC attr_print(oid pre) : void :=
{
    var attr_list := Tattr_own.uselect(pre);
    var name;
    attr_list@batloop
    {
	# recompose name
	name := Tattr_ns.fetch($h);
	if (name != "") name :+= ":";
	name :+= Tattr_loc.fetch($h);
	# TODO: distinguish quot and apos enclosed attributes
        printf(" %s=\"%s\"", name, Tattr_val.fetch($h));
    }
}

PROC node_print(oid pre, BAT[oid,str] S) : void :=
{
    var kind := Tpre_kind.fetch(pre);
    var prop := Tpre_prop.fetch(pre);
	
    printf("pre=%d, kind=%d, prop=%d\n",pre,kind,prop);
    if (kind = ELEMENT)
    {    
	# recompose tag name
	var tag := Tprop_ns.fetch(prop);
	if (tag != "") tag :+= ":";
	tag :+= Tprop_loc.fetch(prop);
	
        printf("<%s",tag);
	attr_print(pre);
	printf(">");

	# push node on S
	S.insert(oid(int(pre) + Tpre_size.fetch(pre)), tag);
    }
    else if (kind = TEXT)
        printf("%s",Tprop_text.fetch(prop));
    else if (kind = COMMENT)
        printf("<!--%s-->",Tprop_com.fetch(prop));
    else if (kind = PI)
        printf("<?%s %s?>",Tprop_tgt.fetch(prop), Tprop_ins.fetch(prop));
    else if (kind = DOCUMENT)
	S.insert(oid(int(pre) + Tpre_size.fetch(pre)), "");
}

PROC endtag_print(oid pre, BAT[oid,str] S) : void :=
{
    # pseudocode of this procedure:
    # while (pre > S.top()) print(name(S.pop()));
    var i := S.count - 1;
    var popped := S.reverse.select(oid(nil), pre, true, false).reverse;
    var poplimit := i - popped.count;
    var tag;
    
    while (i > poplimit)
    {
        # the 'tag != ""'-check is needed, to suppress output
        # if a document node is popped from the stack
        tag := S.fetch(i);
	if (tag != "") printf("</%s>", tag);
	i :-= 1;
    }
    
    S.delete(popped);
}

PROC xml_print(BAT[oid,any] CS) : void :=
{
    if (CS.count = 0) return; 
    
    # line feed
    printf("\n");

    # node stack (storing pre+size and the name of a node)
    var S := new(oid,str);
    
    # cursor moving over the pre values
    var pre;
    var lastpre := Tpre_size.reverse.fetch(Tpre_size.count - 1);
   
    # for all nodes in the context set do ...
    CS@batloop{
        
	pre := $h;
        
	# missing "do...while"-loops in mil ... 
	node_print(pre, S);
	pre := oid(int(pre) + 1);
        endtag_print(pre, S);
	
        while ((S.count > 0) and (pre <= lastpre))
	{
	    node_print(pre, S);
	    pre := oid(int(pre) + 1);
            endtag_print(pre, S);
        }
	# line feed
	printf("\n\n");
    }
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
BAT[oid,any] context set\n\
DESCRIPITON:\n\
Print XML-fragment enclosed by each context node.",
"pathfinder");

PROC xml_print() : void :=
{
    xml_print(Tdoc_pre.reverse);
}
ADDHELP("xml_print", "rode", "Dec 2003",
"DESCRIPITON:\n\
Print all XML-documents in the working set.",
"pathfinder");

PROC xml_print(str name) : void :=
{
    if (not(Tdoc_name.reverse.exist(name)))
	ERROR("Document %s does not exist in working set\n",name);
    var docid := int(Tdoc_name.reverse.find(name));	
    xml_print(Tdoc_pre.slice(docid,docid).reverse);
}
ADDHELP("xml_print", "rode", "Dec 2003",
"PARAMETERS:\n\
str document name\n\
DESCRIPITON:\n\
Print XML-document with the specified name.",
"pathfinder");

#############################################
# MIL WRAPPER for AXIS STEPS 
#
# In order to simplify the invocation of the axis steps functions, this
# interface provides...
# 

PROC descendant(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_desc(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("descendant", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant axis of the ctx-nodes.",
"pathfinder");

PROC descendant_or_self(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_descorself(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("descendant_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the descendant-or-self axis of the ctx-nodes.",
"pathfinder");

PROC ancestor(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_anc(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("ancestor", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor axis of the ctx-nodes.",
"pathfinder");

PROC ancestor_or_self(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return scj_ancorself(Tpre_size, ctx, Theight, Tpre_size.count);
}
ADDHELP("ancestor_or_self", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the ancestor-or-self axis of the ctx-nodes.",
"pathfinder");

PROC child(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_child(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("child", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the child axis of the ctx-nodes.",
"pathfinder");

PROC parent(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_parent(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("parent", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the parent axis of the ctx-nodes.",
"pathfinder");

PROC following_sibling(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_fs(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("following_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the following-sibling axis of the ctx-nodes.",
"pathfinder");

PROC preceding_sibling(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return lev_ps(Tpre_level, ctx, Theight, Tpre_level.count);
}
ADDHELP("preceding_sibling", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the preceding-sibling axis of the ctx-nodes.",
"pathfinder");

PROC following(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return following_void(Tpre_size, ctx, Tdoc_pre, Theight, Tpre_size.count);
}
ADDHELP("following", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the following axis of the ctx-nodes.",
"pathfinder");

PROC preceding(BAT[oid,any] ctx) : BAT[oid,void] :=
{
    return preceding_void(Tpre_size, ctx, Tdoc_pre, Theight, Tpre_size.count);
}
ADDHELP("preceding", "rode", "Jan 2004",
"PARAMETERS:\n\
BAT[oid,any] ctx context set\n\
DESCRIPITON:\n\
returns all nodes on the preceding axis of the ctx-nodes.",
"pathfinder");


@:loop_lifted_scj_step1(ancestor)@
@:loop_lifted_scj_step1(ancestor_or_self)@
@:loop_lifted_scj_step1(child)@
@:loop_lifted_scj_step1(descendant)@
@:loop_lifted_scj_step1(descendant_or_self)@
@:loop_lifted_scj_step1(following)@
@:loop_lifted_scj_step1(following_sibling)@
@:loop_lifted_scj_step1(parent)@
@:loop_lifted_scj_step1(preceding)@
@:loop_lifted_scj_step1(preceding_sibling)@

# expanding of the return_type
@= jRetType
bat[oid,oid]
@= jReturn
result_scj := pruned_input.reverse.leftfetchjoin(ctx_dn);
@= unjRetType
bat[void,bat]
@= unjReturn
result_scj := bat(void,bat).insert(nil,pruned_input).insert(nil,ctx_dn);
@ 
# expansion of the different return types
@= loop_lifted_scj_step1
@:loop_lifted_scj_step2(@1,_joined,@:jRetType@,@:jReturn)@
@:loop_lifted_scj_step2(@1,_unjoined,@:unjRetType@,@:unjReturn@)@
@
#==================================================================
# expansions of the loop lifted scj
@= comma
,
@
# kind argument
@= kind
@:comma@chr kind
@
# code for kind testing
@= kindcode
        temp1_scj := temp1_scj.mirror.leftfetchjoin(Tpre_kind);
        temp1_scj := temp1_scj.[=](kind).select(true);
@
# tagname argument
@= tagname
@:comma@bat[oid, oid] propID
@
# code for tagname testing
@= tagnamecode
        temp1_scj := temp1_scj.mirror.leftfetchjoin(Tpre_prop);
        temp1_scj := temp1_scj.leftjoin(propID);
        temp1_scj := temp1_scj.mirror.leftfetchjoin(Tpre_kind);
        temp1_scj := temp1_scj.[=](ELEMENT).select(true);
@
# resetting the tagname
@= resetpropID
propID := nil;
@
# expanding the scj for the different tests
@= loop_lifted_scj_step2
@:loop_lifted_scj_step3(@1,@2,,@3,,,@4)@
@:loop_lifted_scj_step3(@1,_with_kind_test@2,@:kind@,@3,@:kindcode@,,@4)@
@:loop_lifted_scj_step3(@1,_with_tagname_test@2,@:tagname@,@3,@:tagnamecode@,@:resetpropID@,@4)@
@
#==================================================================
# actual definition of the scj proc
@= loop_lifted_scj_step3
# change back the first two input parameters to bat[void,oid]
proc loop_lifted_@1_step@2 (bat[oid, oid] iter, bat[oid, oid] item@3) : @4 :=
{
   var offset := 0;
   var pruned_input := bat(void,oid).access(BAT_APPEND).seqbase(0@0);
   var ctx_dn := bat(void,oid).access(BAT_APPEND).seqbase(0@0);

   var sorting := iter.reverse.sort.reverse.mark(0@0).reverse;
   iter := sorting.leftfetchjoin(iter);
   item := sorting.leftfetchjoin(item);
   sorting := nil;

   var uniqueIter_count := {count}(iter.reverse, iter.tunique);
   uniqueIter_count := uniqueIter_count.[-](1);

   var temp1_scj;
   var seqb;

   uniqueIter_count@batloop ()
   {
   	temp1_scj := item.slice(offset, offset + int($t)).reverse.sort;
	temp1_scj := temp1_scj.@1;

	# possible test
	@5

   	seqb := count (ctx_dn);
   	seqb := oid (seqb);
   	temp1_scj := temp1_scj.mark(seqb).reverse;
   	ctx_dn.insert(temp1_scj);

   	temp1_scj := temp1_scj.project($h);
   	pruned_input.insert(temp1_scj);

   	offset := offset + $t + 1;
   }

   offset := nil;
   temp1_scj := nil;
   seqb := nil;
   uniqueIter_count := nil;
   iter := nil;
   item := nil;
   @6 # propID := nil;

   ctx_dn.access(BAT_READ);
   pruned_input.access(BAT_READ);

   var result_scj;
   @7
   return result_scj;
}
@
@mil

proc merged_union (bat[any::1,any::2] first, bat[any::1, any::2] second) : bat[any::1,any::2] :=
{
   var count_fst := first.count;
   var count_snd := second.count;
   var size_new := count_fst + count_snd;

   # creates the bats for the comparison
   var iter_fst := {count}(first.reverse, first.tunique);
   var iter_snd := {count}(second.reverse, second.tunique);
   iter_fst := iter_fst.[-](1);
   iter_snd := iter_snd.[-](1);

   # initialization of the counting variables
   var i := 0;
   var j := 0;
   # maximum for the while loop over the both bats
   var iter_count_fst := iter_fst.count;
   var iter_count_snd := iter_snd.count;
   # set the first offset to 0 that the slice starts at the beginning
   var offset_fst := 0;
   var offset_snd := 0;

   if (first.head = "void")
      eval ("var result := bat(void, " + first.tail + 
         ", size_new).seqbase(0@0);");
   else
      eval ("var result := bat(" + first.head + ", " + first.tail + 
         ", size_new);");

   # iterates until one of the input tables is completely consumed
   while ((i < iter_count_fst) and (j < iter_count_snd))
   {
          # if the value of the first argument is bigger
          # than the value of the second argument ...
          if (iter_fst.reverse.fetch(i) > iter_snd.reverse.fetch(j))
          {
             next_slice := second.slice (offset_snd, 
                                         (offset_snd + iter_snd.fetch(j)));
             result.insert(next_slice);
             offset_snd := offset_snd + iter_snd.fetch(j) + 1;
             j :+= 1;
          }
          else
          {
             next_slice := first.slice (offset_fst, 
                                        (offset_fst + iter_fst.fetch(i)));
             result.insert(next_slice);
             offset_fst := offset_fst + iter_fst.fetch(i) + 1;
             i :+= 1;
          }
   }
   # if the second argument is completely consumed the rest of the
   # first argument is appended to the result for each pair
   if ((i < iter_count_fst) and (j = iter_count_snd))
   {
      next_slice := first.slice (offset_fst, count_fst);
      result.insert(next_slice);
   }
   # if the first argument is completely consumed the rest of the
   # second argument is appended to the result for each pair
   if ((i = iter_count_fst) and (j < iter_count_snd))
   {
      next_slice := second.slice (offset_snd, count_snd);
      result.insert(next_slice);
   }
   return result;
}
ADDHELP("merged_union", "tsheyar", "June 2004",
"PARAMETERS:\n\
BAT[any::1,any::2] first, BAT[any::1,any::2] second\n\
DESCRIPITON:\n\
general case of merged union where the result set is the same like\n\
for a normal union.\n\
intertwines first and second corresponding to their tail values.\n\
If first and second are sorted on tail then the result is also sorted on tail.",
"pathfinder");

proc merged_union (bat[void,any::1] first, bat[void, any::1] second) : bat[void,any::1] :=
{
   var count_fst := first.count;
   var count_snd := second.count;
   var size_new := count_fst + count_snd;

   # creates the bats for the comparison
   var iter_fst := {count}(first.reverse, first.tunique);
   var iter_snd := {count}(second.reverse, second.tunique);
   iter_fst := iter_fst.[-](1);
   iter_snd := iter_snd.[-](1);

   # initialization of the counting variables
   var i := 0;
   var j := 0;
   # maximum for the while loop over the both bats
   var iter_count_fst := iter_fst.count;
   var iter_count_snd := iter_snd.count;
   # set the first offset to 0 that the slice starts at the beginning
   var offset_fst := 0;
   var offset_snd := 0;

   eval ("var result := bat(void," + first.tail + 
         ", size_new).seqbase(0@0);");

   # iterates until one of the input tables is completely consumed
   while ((i < iter_count_fst) and (j < iter_count_snd))
   {
          # if the value of the first argument is bigger
          # than the value of the second argument ...
          if (iter_fst.reverse.fetch(i) > iter_snd.reverse.fetch(j))
          {
             next_slice := second.slice (offset_snd, 
                                         (offset_snd + iter_snd.fetch(j)));
             result.insert(next_slice);
             offset_snd := offset_snd + iter_snd.fetch(j) + 1;
             j :+= 1;
          }
          else
          {
             next_slice := first.slice (offset_fst, 
                                        (offset_fst + iter_fst.fetch(i)));
             result.insert(next_slice);
             offset_fst := offset_fst + iter_fst.fetch(i) + 1;
             i :+= 1;
          }
   }
   # if the second argument is completely consumed the rest of the
   # first argument is appended to the result for each pair
   if ((i < iter_count_fst) and (j = iter_count_snd))
   {
      next_slice := first.slice (offset_fst, count_fst);
      result.insert(next_slice);
   }
   # if the first argument is completely consumed the rest of the
   # second argument is appended to the result for each pair
   if ((i = iter_count_fst) and (j < iter_count_snd))
   {
      next_slice := second.slice (offset_snd, count_snd);
      result.insert(next_slice);
   }
   return result.reverse.mark(0@0).reverse;
}
ADDHELP("merged_union", "tsheyar", "June 2004",
"PARAMETERS:\n\
BAT[void,any::1] first, BAT[void,any::1] second\n\
DESCRIPITON:\n\
intertwines first and second corresponding to their tail values.\n\
If first and second are sorted on tail then the result is also sorted on tail.",
"pathfinder");

proc merged_union (bat[void,any::1] first, bat[void, any::1] second, ..bat[void,any]..) : bat[void,bat] :=
{
   # tests the input for a even number of arguments
   if (($0%2) != 0) ERROR ("odd number of arguments");
   var count_fst := first.count;
   var count_snd := second.count;
   var size_new := count_fst + count_snd;
   var k := 1;

   # tests if the types of pairs fit
   while ((k :+= 2) < $0)
   {
      if (((($(k).tail != "void") or ($(k+1).tail != "oid"))
          and
          (($(k).tail != "oid") or ($(k+1).tail != "void")))
           and
           ($(k).tail != $(k+1).tail))
              ERROR ("tails of argument %i and %i don't fit", k, (k+1));

      if ($(k).count != count_fst)
         ERROR ("argument %i has the wrong size (found: %i, expected: %i)",
                k, $(k).count, count_fst);
      if ($(k+1).count != count_snd)
         ERROR ("argument %i has the wrong size (found: %i, expected: %i)",
                (k+1), $(k+1).count, count_snd);
   }

   # creates the bats for the comparison
   var iter_fst := {count}(first.reverse, first.tunique);
   var iter_snd := {count}(second.reverse, second.tunique);
   iter_fst := iter_fst.[-](1);
   iter_snd := iter_snd.[-](1);

   # initialization of the counting variables
   var i := 0;
   var j := 0;
   # maximum for the while loop over the both bats
   var iter_count_fst := iter_fst.count;
   var iter_count_snd := iter_snd.count;
   # set the first offset to 0 that the slice starts at the beginning
   var offset_fst := 0;
   var offset_snd := 0;

   # creates resulting bats for the variables with the necessary types
   # (it has to be done in one expression because otherwise the variables would be
   # deleted after the block "{ }")
   k := -1;
   while ((k :+= 2) < $0)
      if ($(k).tail = "void")
         eval ("var var" + str(k) + " := bat (void, oid, size_new).seqbase(0@0);");
      else
         eval ("var var" + str(k) + " := bat(void, "
               + $(k).tail + ", size_new).seqbase(0@0);");

   # iterates until one of the input tables is completely consumed
   while ((i < iter_count_fst) and (j < iter_count_snd))
   {
          # if the value of the first argument is bigger
          # than the value of the second argument ...
          if (iter_fst.reverse.fetch(i) > iter_snd.reverse.fetch(j))
          {
             # for each pair a slice is transferred to the output bat of the pair
             k := 1;
             while (k < $0)
             {
                next_slice := $(k+1).slice (offset_snd, 
                                            (offset_snd + iter_snd.fetch(j)));
                eval ("var" + str(k) + ".insert(next_slice);");
                k :+= 2;
             }
             offset_snd := offset_snd + iter_snd.fetch(j) + 1;
             j :+= 1;
          }
          else
          {
             k := 1;
             while (k < $0)
             {
                next_slice := $(k).slice (offset_fst, 
                                          (offset_fst + iter_fst.fetch(i)));
                eval ("var" + str(k) + ".insert(next_slice);");
                k :+= 2;
             }
             offset_fst := offset_fst + iter_fst.fetch(i) + 1;
             i :+= 1;
          }
   }
   # if the second argument is completely consumed the rest of the
   # first argument is appended to the result for each pair
   if ((i < iter_count_fst) and (j = iter_count_snd))
   {
      k := 1;
      while (k < $0)
      {
         next_slice := $(k).slice (offset_fst, count_fst);
         eval ("var" + str(k) + ".insert(next_slice);");
         k :+= 2;
      }
   }
   # if the first argument is completely consumed the rest of the
   # second argument is appended to the result for each pair
   if ((i = iter_count_fst) and (j < iter_count_snd))
   {
      k := 1;
      while (k < $0)
      {
         next_slice := $(k+1).slice (offset_snd, count_snd);
         eval ("var" + str(k) + ".insert(next_slice);");
         k :+= 2;
      }
   }
   
   count_fst := nil;
   count_snd := nil;
   size_new := nil;
   iter_fst := nil;
   iter_snd := nil;
   i := nil;
   j := nil;
   iter_count_fst := nil;
   iter_count_snd := nil;
   offset_fst := nil;
   offset_snd := nil;

   # the merged pairs are inserted into a result bat
   var result := bat(void,bat).seqbase(0@0);
   k := 1;
   while (k < $0)
   {
      eval ("result.insert(nil,var" + str(k) + ".reverse.mark(0@0).reverse);");
      eval ("var" + str(k) + " := nil;");
      k :+= 2;
   }
   k := nil;
 
   return result;
}
ADDHELP("merged_union", "tsheyar", "June 2004",
"PARAMETERS:\n\
even number of BAT[void,any] with pairs of the same tail type\n\
DESCRIPITON:\n\
merges pairs of bats according to the sorting of the first pair.",
"pathfinder");

