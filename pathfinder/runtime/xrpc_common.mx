@' Copyright Notice:
@' -----------------
@'
@' The contents of this file are subject to the Pathfinder Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License.  You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/PathfinderLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
@' the License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the Pathfinder system.
@'
@' The Original Code has initially been developed by the Database &
@' Information Systems Group at the University of Konstanz, Germany and
@' is now maintained by the Database Systems Group at the Technische
@' Universitaet Muenchen, Germany.  Portions created by the University of
@' Konstanz and the Technische Universitaet Muenchen are Copyright (C)
@' 2000-2005 University of Konstanz and (C) 2005-2008 Technische
@' Universitaet Muenchen, respectively.  All Rights Reserved.
@'
@' $Id$
@f xrpc_common
@a Ying Zhang
@t Includes header files, definitions shared by the XRPC server and XRPC client

@m
.MODULE xrpc_common;

.COMMAND my_hostname() : str = CMDmy_hostname;
"Returns the hostname of the localhost."

.PRELUDE = xrpc_common_prelude;
.END xrpc_common;

@h
#ifndef XRPC_COMMON_H
#define XRPC_COMMON_H

#include <mapi/mapi.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <stream_socket.h>

#ifdef _WIN32   /* Windows specific */
    #include <winsock.h>
    #define snprintf _snprintf
    #ifndef __MINGW32__
        #pragma comment(lib, "ws2_32")
    #endif
#else           /* UNIX specific */
    #include <sys/select.h>
    #include <sys/types.h>	/* used by socket */
    #include <sys/socket.h>
    #include <unistd.h> /* gethostname() */
    #include <netinet/in.h> /* hton and ntoh */
    #include <arpa/inet.h>  /* dotted IP addr to and from 32-bits int */
    #include <netdb.h>      /* gethostbyname(), h_errno */
    #include <errno.h>
    #include <ctype.h>
#endif

#define ISOLATION_NONE          1
#define ISOLATION_REPEATABLE    2
#define ISOLATION_2PC           3

#define XRPCLOCK_IDX            6

#define XRPC_REQ_CALLBACK       "/xrpc"

#define MXQ_ADMIN   "http://monetdb.cwi.nl/XQuery/admin/"

#define SOAP_NS     "http://www.w3.org/2003/05/soap-envelope"
#define XDT_NS      "http://www.w3.org/2005/xpath-datatypes"
#define XS_NS       "http://www.w3.org/2001/XMLSchema"
#define XSI_NS      "http://www.w3.org/2001/XMLSchema-instance"
#define XRPC_NS     "http://monetdb.cwi.nl/XQuery"
#define XRPC_LOC    "http://monetdb.cwi.nl/XQuery/XRPC.xsd"
#define WSCOOR_NS   "http://docs.oasis-open.org/ws-tx/wscoor/2006/06"
#define WSAT_NS     "http://docs.oasis-open.org/ws-tx/wsat/2006/06"

#define HTTP_200_OK\
            "HTTP/1.1 200 OK\r\n"\
            "Content-type: text/xml; charset=\"utf-8\"\r\n\r\n"

#define SOAP_ENVELOPE\
    "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"\
    "<env:Envelope xmlns:env=\"" SOAP_NS "\""\
                 " xmlns:xrpc=\"" XRPC_NS "\""\
                 " xmlns:xdt=\"" XDT_NS "\" "\
                 " xmlns:xs=\"" XS_NS "\""\
                 " xmlns:xsi=\"" XSI_NS "\""\
                 " xsi:schemaLocation=\"" XRPC_NS " " XRPC_LOC "\">"

#define XRPC_WS_QID\
      "<wscoor:CoordinationContext xmlns:wscoor=\""WSCOOR_NS"\""\
                 "env:mustUnderstand=\"true\">"\
        "<wscoor:Identifier>%s</wscoor:Identifier>"\
        "<wscoor:Expires>%s</wscoor:Expires>"\
        "<wscoor:CoordinationType>" WSAT_NS "</wscoor:CoordinationType>"\
      "</wscoor:CoordinationContext>"

#define XRPC_REQ_HEADER\
    "<env:Body>"\
      "<xrpc:request xrpc:module=\"%s\""\
                   " xrpc:location=\"%s\""\
                   " xrpc:method=\"%s\""\
                   " xrpc:arity=\"%lld\""\
                   " xrpc:iter-count=\"%lld\""\
                   " xrpc:updCall=\"%s\">"

#define XRPC_RES_HEADER\
    "<env:Body>"\
      "<xrpc:response xrpc:module=\"%s\""\
                    " xrpc:method=\"%s\">"

#define XRPC_HTTP_CALL "<xrpc:call>"                                    \
                         "<xrpc:sequence>"                              \
                           "<xrpc:atomic-value xsi:type=\"xs:string\">" \
                             "%s"                                       \
                           "</xrpc:atomic-value>"                       \
                         "</xrpc:sequence>"                             \
                       "</xrpc:call>"

#define XRPC_PUT_CALL  "<xrpc:call>"                                    \
                         "<xrpc:sequence>"                              \
                           "<xrpc:atomic-value xsi:type=\"xs:string\">" \
                             "%s"                                       \
                           "</xrpc:atomic-value>"                       \
                         "</xrpc:sequence>"                             \
                         "<xrpc:sequence>"                              \
                           "<xrpc:element>%s</xrpc:element>"            \
                         "</xrpc:sequence>"                             \
                       "</xrpc:call>"

#define XRPC_FOOTER     "</xrpc:request>"   \
                      "</env:Body>"         \
                    "</env:Envelope>\n"

/* exports for xrpc_server.mx and serialize_dflt.mx */
int check_timeout_by_idx(oid qid_idx);
int check_timeout_by_qid(char *qid, lng timeout);

extern int xrpc_port;
extern char *xrpc_hostname;
extern BAT *xrpc_qids;
extern BAT *xrpc_timeouts;
extern BAT *xrpc_statuses;
extern BAT *xrpc_locks;
extern BAT *xrpc_wsids;

#endif /* XRPC_COMMON_H */

@c
#include "pf_config.h"
#include "xrpc_common.h"
#include "pf_support.h"

int CMDmy_hostname(char **res)
{
    int ret = 0, len = HOST_NAME_MAX > 255 ? HOST_NAME_MAX : 255;
    char err[1024];

    char *hname = GDKmalloc(len);
    if(!hname) {
        GDKerror("CMDmy_hostname: failed to malloc 'hname'\n");
        return GDK_FAIL;
    }
    
    errno = 0;
    ret = gethostname(hname, len);
    if(ret < 0) {
        snprintf(err, 1024, "CMDmy_hostname: gethostname() failed: %s.\n", strerror(errno));
        return GDK_FAIL;
    }

    *res = hname;
    return GDK_SUCCEED;
}

/* return: 1: timedout; 0: not timedout; -1: not found; -2: other errors */
int
check_timeout_by_qid(char *qid, lng timeout)
{
    BATiter qidsi = bat_iterator(xrpc_qids);
    oid qid_idx = oid_nil;
    BUN bun_qid = BUN_NONE;
    int ret = 1;

    if(timeout > GDKusec())
        return 0; /* not timed out */

    MT_set_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
    if((bun_qid = BUNfnd(BATmirror(xrpc_qids), qid)) ==  BUN_NONE) {
        GDKerror("check_timeout_by_qid: "
                 "could not find QID \"%s\" in the meta-BAT "
                 "\"xrpc_qids\"\n", qid);
        ret = -1;
    }
    qid_idx =  *(oid*)BUNtail(qidsi, bun_qid);
    if(!BUNreplace(xrpc_statuses, &qid_idx, "timedout", FALSE)){
        MT_unset_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
        GDKerror("check_timeout_by_qid: "
                 "failed to change the status of query \"%s\" into "
                 "\"timedout\"\n", qid);
        ret = -2;
    }
    MT_unset_lock(PF_XRPC_LOCK, "check_timeout_by_qid");
    return ret; /* timed out */
}

/* return: 1: timedout; 0: not timedout; -1: not found; -2: other errors */
int
check_timeout_by_idx(oid qid_idx)
{
    BATiter qidsi = bat_iterator(xrpc_qids);
    BATiter timeoutsi = bat_iterator(xrpc_timeouts);
    BUN bun_qid = BUN_NONE, bun_to = BUN_NONE;
    char err[1024];
    int ret = 1;

    MT_set_lock(PF_XRPC_LOCK, "check_timeout_by_idx");
    BUNfndVOID(bun_qid, qidsi, &qid_idx);
    BUNfndVOID(bun_to, timeoutsi, &qid_idx);
    if(bun_qid == BUN_NONE || bun_to == BUN_NONE) {
        snprintf(err, 1024, "check_timeout_by_idx: "OIDFMT"-th BUN not "
                            "found in the xrpc_* meta-BATs!\n", qid_idx);
        ret = -1;
    } else {
        char *qid = (char*)BUNtail(qidsi, bun_qid);
        char *to_str = (char*)BUNtail(timeoutsi, bun_to); 
        assert(qid && to_str);
        lng to = strtoll(to_str, NULL, 10);
        if(to <= 0) {
            snprintf(err, 1024, "check_timeout_by_idx: invalid value of "
                                "timeout: \"%s\"!\n", to_str);
        } else if (to > GDKusec()) {
            ret = 0; /* not timed out */
        } else if(!BUNreplace(xrpc_statuses, &qid_idx, "timedout", FALSE)){
            snprintf(err, 1024, "check_timeout_by_idx: failed to change "
                            "the status of query \"%s\" into "
                            "\"timedout\"\n", qid);
        }
    }
    MT_unset_lock(PF_XRPC_LOCK, "check_timeout_by_idx");
    if(ret < 0) GDKerror(err);
    return ret;
}

@= xrpc_bat
    xrpc_@1 = BATnew(TYPE_void,ATOMindex("@2"),1024);
    if (xrpc_@1 == NULL) GDKfatal("failed to create xrpc_@1");
    BATseqbase(xrpc_@1, 1);
    BBPrename(xrpc_@1->batCacheid, "xrpc_@1");
@c
BAT *xrpc_qids = NULL, *xrpc_statuses = NULL, *xrpc_timeouts = NULL, *xrpc_locks = NULL, *xrpc_wsids = NULL;
char *xrpc_hostname = NULL;
int xrpc_port = 0;

bat*
xrpc_common_prelude(void) {
    @:xrpc_bat(qids,str)@
    @:xrpc_bat(statuses,str)@
    @:xrpc_bat(timeouts,lng)@
    @:xrpc_bat(locks,lock)@
    @:xrpc_bat(wsids,lng)@
    CMDmy_hostname(&xrpc_hostname);
    return NULL;
}
